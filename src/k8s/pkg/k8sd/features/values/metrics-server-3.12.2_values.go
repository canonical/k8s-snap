// Code generated by running "./CHART_VALUES_STRUCT_GENERATOR -files=coredns-1.36.0_values.yaml,cilium-1.16.3_values.yaml,ck-loadbalancer_values.yaml,metallb-0.14.8_values.yaml,rawfile-csi-0.9.0_values.yaml,metrics-server-3.12.2_values.yaml -pkg=values -out-dir=../../../src/k8s/pkg/k8sd/features/values -advanced-types=true -unsafe-field=true". DO NOT EDIT.
//
// This file was autogenerated by the CHART_VALUES_STRUCT_GENERATOR tool on 2024-12-16.
// Any changes will be overwritten.
//
// These files are generated from the values.yaml files in the k8s/manifests/charts directory.
//
// Package values contains the Go structs representing the values of the Helm chart.
package values

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
)

type MetricsServer3122Values_Image struct {
	// Default value in yaml: registry.k8s.io/metrics-server/metrics-server
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	//  Overrides the image tag whose default is v{{ .Chart.AppVersion }}
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	// Default value in yaml: IfNotPresent
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_ServiceAccount struct {
	//  Specifies whether a service account should be created
	//
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	//  Annotations to add to the service account
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  The name of the service account to use.
	//  If not set and create is true, a name is generated using the fullname template
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
	//  The list of secrets mountable by this service account.
	//  See https://kubernetes.io/docs/reference/labels-annotations-taints/#enforce-mountable-secrets
	Secrets *[]any `json:"secrets,omitempty" yaml:"secrets,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_ServiceAccount) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_Rbac struct {
	//  Specifies whether RBAC resources should be created
	//
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	//  Note: PodSecurityPolicy will not be created when Kubernetes version is 1.25 or later.
	//
	// Default value in yaml: false
	PspEnabled *bool `json:"pspEnabled,omitempty" yaml:"pspEnabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_Rbac) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_ApiService struct {
	//  Specifies if the v1beta1.metrics.k8s.io API service should be created.
	//
	//  You typically want this enabled! If you disable API service creation you have to
	//  manage it outside of this chart for e.g horizontal pod autoscaling to
	//  work with this release.
	//
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	//  Annotations to add to the API service
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  Specifies whether to skip TLS verification
	//
	// Default value in yaml: true
	InsecureSkipTlsverify *bool `json:"insecureSkipTLSVerify,omitempty" yaml:"insecureSkipTLSVerify,omitempty"`
	//  The PEM encoded CA bundle for TLS verification
	CaBundle *string `json:"caBundle,omitempty" yaml:"caBundle,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_ApiService) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_SecurityContext_SeccompProfile struct {
	// Default value in yaml: RuntimeDefault
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_SecurityContext_SeccompProfile) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_SecurityContext_Capabilities struct {
	// Default value in yaml:
	// - ALL
	Drop *[]string `json:"drop,omitempty" yaml:"drop,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_SecurityContext_Capabilities) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_SecurityContext struct {
	// Default value in yaml: false
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty"`
	// Default value in yaml: true
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty" yaml:"readOnlyRootFilesystem,omitempty"`
	// Default value in yaml: true
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty"`
	// Default value in yaml: 1000
	RunAsUser      *int64                                                  `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty"`
	SeccompProfile *MetricsServer3122Values_SecurityContext_SeccompProfile `json:"seccompProfile,omitempty" yaml:"seccompProfile,omitempty"`
	Capabilities   *MetricsServer3122Values_SecurityContext_Capabilities   `json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_SecurityContext) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_HostNetwork struct {
	//  Specifies if metrics-server should be started in hostNetwork mode.
	//
	//  You would require this enabled if you use alternate overlay networking for pods and
	//  API server unable to communicate with metrics-server. As an example, this is required
	//  if you use Weave network on EKS
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_HostNetwork) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_PodDisruptionBudget struct {
	//  https://kubernetes.io/docs/tasks/run-application/configure-pdb/
	//
	// Default value in yaml: false
	Enabled        *bool   `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	MinAvailable   *string `json:"minAvailable,omitempty" yaml:"minAvailable,omitempty"`
	MaxUnavailable *string `json:"maxUnavailable,omitempty" yaml:"maxUnavailable,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_PodDisruptionBudget) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_LivenessProbe_HttpGet struct {
	// Default value in yaml: /livez
	Path *string `json:"path,omitempty" yaml:"path,omitempty"`
	// Default value in yaml: https
	Port *string `json:"port,omitempty" yaml:"port,omitempty"`
	// Default value in yaml: HTTPS
	Scheme *string `json:"scheme,omitempty" yaml:"scheme,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_LivenessProbe_HttpGet) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_LivenessProbe struct {
	HttpGet *MetricsServer3122Values_LivenessProbe_HttpGet `json:"httpGet,omitempty" yaml:"httpGet,omitempty"`
	// Default value in yaml: 0
	InitialDelaySeconds *int64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty"`
	// Default value in yaml: 10
	PeriodSeconds *int64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty"`
	// Default value in yaml: 3
	FailureThreshold *int64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_LivenessProbe) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_ReadinessProbe_HttpGet struct {
	// Default value in yaml: /readyz
	Path *string `json:"path,omitempty" yaml:"path,omitempty"`
	// Default value in yaml: https
	Port *string `json:"port,omitempty" yaml:"port,omitempty"`
	// Default value in yaml: HTTPS
	Scheme *string `json:"scheme,omitempty" yaml:"scheme,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_ReadinessProbe_HttpGet) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_ReadinessProbe struct {
	HttpGet *MetricsServer3122Values_ReadinessProbe_HttpGet `json:"httpGet,omitempty" yaml:"httpGet,omitempty"`
	// Default value in yaml: 20
	InitialDelaySeconds *int64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty"`
	// Default value in yaml: 10
	PeriodSeconds *int64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty"`
	// Default value in yaml: 3
	FailureThreshold *int64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_ReadinessProbe) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_Service struct {
	// Default value in yaml: ClusterIP
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`
	// Default value in yaml: 443
	Port        *int64          `json:"port,omitempty" yaml:"port,omitempty"`
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//   Add these labels to have metrics-server show up in `kubectl cluster-info`
	//   kubernetes.io/cluster-service: "true"
	//   kubernetes.io/name: "Metrics-server"
	Labels *map[string]any `json:"labels,omitempty" yaml:"labels,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_Service) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_AddonResizer_Image struct {
	// Default value in yaml: registry.k8s.io/autoscaling/addon-resizer
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	// Default value in yaml: 1.8.21
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_AddonResizer_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_AddonResizer_SecurityContext_SeccompProfile struct {
	// Default value in yaml: RuntimeDefault
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_AddonResizer_SecurityContext_SeccompProfile) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_AddonResizer_SecurityContext_Capabilities struct {
	// Default value in yaml:
	// - ALL
	Drop *[]string `json:"drop,omitempty" yaml:"drop,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_AddonResizer_SecurityContext_Capabilities) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_AddonResizer_SecurityContext struct {
	// Default value in yaml: false
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty"`
	// Default value in yaml: true
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty" yaml:"readOnlyRootFilesystem,omitempty"`
	// Default value in yaml: true
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty"`
	// Default value in yaml: 1000
	RunAsUser      *int64                                                               `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty"`
	SeccompProfile *MetricsServer3122Values_AddonResizer_SecurityContext_SeccompProfile `json:"seccompProfile,omitempty" yaml:"seccompProfile,omitempty"`
	Capabilities   *MetricsServer3122Values_AddonResizer_SecurityContext_Capabilities   `json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_AddonResizer_SecurityContext) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_AddonResizer_Resources_Requests struct {
	// Default value in yaml: 40m
	Cpu *string `json:"cpu,omitempty" yaml:"cpu,omitempty"`
	// Default value in yaml: 25Mi
	Memory *string `json:"memory,omitempty" yaml:"memory,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_AddonResizer_Resources_Requests) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_AddonResizer_Resources_Limits struct {
	// Default value in yaml: 40m
	Cpu *string `json:"cpu,omitempty" yaml:"cpu,omitempty"`
	// Default value in yaml: 25Mi
	Memory *string `json:"memory,omitempty" yaml:"memory,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_AddonResizer_Resources_Limits) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_AddonResizer_Resources struct {
	Requests *MetricsServer3122Values_AddonResizer_Resources_Requests `json:"requests,omitempty" yaml:"requests,omitempty"`
	Limits   *MetricsServer3122Values_AddonResizer_Resources_Limits   `json:"limits,omitempty" yaml:"limits,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_AddonResizer_Resources) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_AddonResizer_Nanny struct {
	// Default value in yaml: 0m
	Cpu *string `json:"cpu,omitempty" yaml:"cpu,omitempty"`
	// Default value in yaml: 1m
	ExtraCpu *string `json:"extraCpu,omitempty" yaml:"extraCpu,omitempty"`
	// Default value in yaml: 0Mi
	Memory *string `json:"memory,omitempty" yaml:"memory,omitempty"`
	// Default value in yaml: 2Mi
	ExtraMemory *string `json:"extraMemory,omitempty" yaml:"extraMemory,omitempty"`
	// Default value in yaml: 100
	MinClusterSize *int64 `json:"minClusterSize,omitempty" yaml:"minClusterSize,omitempty"`
	// Default value in yaml: 300000
	PollPeriod *int64 `json:"pollPeriod,omitempty" yaml:"pollPeriod,omitempty"`
	// Default value in yaml: 5
	Threshold *int64 `json:"threshold,omitempty" yaml:"threshold,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_AddonResizer_Nanny) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_AddonResizer struct {
	// Default value in yaml: false
	Enabled         *bool                                                 `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	Image           *MetricsServer3122Values_AddonResizer_Image           `json:"image,omitempty" yaml:"image,omitempty"`
	SecurityContext *MetricsServer3122Values_AddonResizer_SecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`
	Resources       *MetricsServer3122Values_AddonResizer_Resources       `json:"resources,omitempty" yaml:"resources,omitempty"`
	Nanny           *MetricsServer3122Values_AddonResizer_Nanny           `json:"nanny,omitempty" yaml:"nanny,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_AddonResizer) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_Metrics struct {
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_Metrics) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_ServiceMonitor struct {
	// Default value in yaml: false
	Enabled          *bool           `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	AdditionalLabels *map[string]any `json:"additionalLabels,omitempty" yaml:"additionalLabels,omitempty"`
	// Default value in yaml: 1m
	Interval *string `json:"interval,omitempty" yaml:"interval,omitempty"`
	// Default value in yaml: 10s
	ScrapeTimeout     *string `json:"scrapeTimeout,omitempty" yaml:"scrapeTimeout,omitempty"`
	MetricRelabelings *[]any  `json:"metricRelabelings,omitempty" yaml:"metricRelabelings,omitempty"`
	Relabelings       *[]any  `json:"relabelings,omitempty" yaml:"relabelings,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_ServiceMonitor) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  limits:
//    cpu:
//    memory:
type MetricsServer3122Values_Resources_Requests struct {
	// Default value in yaml: 100m
	Cpu *string `json:"cpu,omitempty" yaml:"cpu,omitempty"`
	// Default value in yaml: 200Mi
	Memory *string `json:"memory,omitempty" yaml:"memory,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_Resources_Requests) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  See https://github.com/kubernetes-sigs/metrics-server#scaling
type MetricsServer3122Values_Resources struct {
	//  limits:
	//    cpu:
	//    memory:
	Requests *MetricsServer3122Values_Resources_Requests `json:"requests,omitempty" yaml:"requests,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_Resources) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type MetricsServer3122Values_TmpVolume struct {
	EmptyDir *map[string]any `json:"emptyDir,omitempty" yaml:"emptyDir,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values_TmpVolume) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

// MetricsServer3122Values represents the values of the metrics-server-3.12.2_values.yaml chart
type MetricsServer3122Values struct {
	Image *MetricsServer3122Values_Image `json:"image,omitempty" yaml:"image,omitempty"`
	//  - name: registrySecretName
	ImagePullSecrets   *[]any                                   `json:"imagePullSecrets,omitempty" yaml:"imagePullSecrets,omitempty"`
	NameOverride       *string                                  `json:"nameOverride,omitempty" yaml:"nameOverride,omitempty"`
	FullnameOverride   *string                                  `json:"fullnameOverride,omitempty" yaml:"fullnameOverride,omitempty"`
	ServiceAccount     *MetricsServer3122Values_ServiceAccount  `json:"serviceAccount,omitempty" yaml:"serviceAccount,omitempty"`
	Rbac               *MetricsServer3122Values_Rbac            `json:"rbac,omitempty" yaml:"rbac,omitempty"`
	ApiService         *MetricsServer3122Values_ApiService      `json:"apiService,omitempty" yaml:"apiService,omitempty"`
	CommonLabels       *map[string]any                          `json:"commonLabels,omitempty" yaml:"commonLabels,omitempty"`
	PodLabels          *map[string]any                          `json:"podLabels,omitempty" yaml:"podLabels,omitempty"`
	PodAnnotations     *map[string]any                          `json:"podAnnotations,omitempty" yaml:"podAnnotations,omitempty"`
	PodSecurityContext *map[string]any                          `json:"podSecurityContext,omitempty" yaml:"podSecurityContext,omitempty"`
	SecurityContext    *MetricsServer3122Values_SecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`
	// Default value in yaml: system-cluster-critical
	PriorityClassName *string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty"`
	// Default value in yaml: 10250
	ContainerPort *int64                               `json:"containerPort,omitempty" yaml:"containerPort,omitempty"`
	HostNetwork   *MetricsServer3122Values_HostNetwork `json:"hostNetwork,omitempty" yaml:"hostNetwork,omitempty"`
	// Default value in yaml: 1
	Replicas             *int64  `json:"replicas,omitempty" yaml:"replicas,omitempty"`
	RevisionHistoryLimit *string `json:"revisionHistoryLimit,omitempty" yaml:"revisionHistoryLimit,omitempty"`
	//    type: RollingUpdate
	//    rollingUpdate:
	//      maxSurge: 0
	//      maxUnavailable: 1
	UpdateStrategy      *map[string]any                              `json:"updateStrategy,omitempty" yaml:"updateStrategy,omitempty"`
	PodDisruptionBudget *MetricsServer3122Values_PodDisruptionBudget `json:"podDisruptionBudget,omitempty" yaml:"podDisruptionBudget,omitempty"`
	// Default value in yaml:
	// - --cert-dir=/tmp
	// - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname
	// - --kubelet-use-node-status-port
	// - --metric-resolution=15s
	DefaultArgs    *[]string                               `json:"defaultArgs,omitempty" yaml:"defaultArgs,omitempty"`
	Args           *[]any                                  `json:"args,omitempty" yaml:"args,omitempty"`
	LivenessProbe  *MetricsServer3122Values_LivenessProbe  `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty"`
	ReadinessProbe *MetricsServer3122Values_ReadinessProbe `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty"`
	Service        *MetricsServer3122Values_Service        `json:"service,omitempty" yaml:"service,omitempty"`
	AddonResizer   *MetricsServer3122Values_AddonResizer   `json:"addonResizer,omitempty" yaml:"addonResizer,omitempty"`
	Metrics        *MetricsServer3122Values_Metrics        `json:"metrics,omitempty" yaml:"metrics,omitempty"`
	ServiceMonitor *MetricsServer3122Values_ServiceMonitor `json:"serviceMonitor,omitempty" yaml:"serviceMonitor,omitempty"`
	//  See https://github.com/kubernetes-sigs/metrics-server#scaling
	Resources                 *MetricsServer3122Values_Resources `json:"resources,omitempty" yaml:"resources,omitempty"`
	ExtraVolumeMounts         *[]any                             `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty"`
	ExtraVolumes              *[]any                             `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty"`
	NodeSelector              *map[string]any                    `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty"`
	Tolerations               *[]any                             `json:"tolerations,omitempty" yaml:"tolerations,omitempty"`
	Affinity                  *map[string]any                    `json:"affinity,omitempty" yaml:"affinity,omitempty"`
	TopologySpreadConstraints *[]any                             `json:"topologySpreadConstraints,omitempty" yaml:"topologySpreadConstraints,omitempty"`
	DnsConfig                 *map[string]any                    `json:"dnsConfig,omitempty" yaml:"dnsConfig,omitempty"`
	//  Annotations to add to the deployment
	DeploymentAnnotations *map[string]any                    `json:"deploymentAnnotations,omitempty" yaml:"deploymentAnnotations,omitempty"`
	SchedulerName         *string                            `json:"schedulerName,omitempty" yaml:"schedulerName,omitempty"`
	TmpVolume             *MetricsServer3122Values_TmpVolume `json:"tmpVolume,omitempty" yaml:"tmpVolume,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *MetricsServer3122Values) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetricsServer3122Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetricsServer3122Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

// mergeMaps recursively merges map B into map A.
// The name is unique to prevent conflicts with other autogenerated files in this package.
func mergeMapsMetricsServer3122Values(a, b map[string]any) {
	for key, bValue := range b {
		if aValue, ok := a[key]; ok {
			aMap, aIsMap := aValue.(map[string]any)
			bMap, bIsMap := bValue.(map[string]any)
			if aIsMap && bIsMap {
				mergeMapsMetricsServer3122Values(aMap, bMap)
				continue
			}
		}
		a[key] = bValue
	}
}
