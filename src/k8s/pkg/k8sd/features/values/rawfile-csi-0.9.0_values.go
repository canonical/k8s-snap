// Code generated by running "./CHART_VALUES_STRUCT_GENERATOR -files=coredns-1.36.0_values.yaml,cilium-1.16.3_values.yaml,ck-loadbalancer_values.yaml,metallb-0.14.8_values.yaml,rawfile-csi-0.9.0_values.yaml,metrics-server-3.12.2_values.yaml -pkg=values -out-dir=../../../src/k8s/pkg/k8sd/features/values -advanced-types=true -unsafe-field=true". DO NOT EDIT.
//
// This file was autogenerated by the CHART_VALUES_STRUCT_GENERATOR tool on 2024-12-16.
// Any changes will be overwritten.
//
// These files are generated from the values.yaml files in the k8s/manifests/charts directory.
//
// Package values contains the Go structs representing the values of the Helm chart.
package values

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
)

type RawfileCsi090Values_Defaults_Image struct {
	// Default value in yaml: docker.io/openebs/rawfile-localpv
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	// Default value in yaml: 0.8.0
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	// Default value in yaml: Always
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *RawfileCsi090Values_Defaults_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsRawfileCsi090Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type RawfileCsi090Values_Defaults_Resources_Limits struct {
	// Default value in yaml: 1
	Cpu *int64 `json:"cpu,omitempty" yaml:"cpu,omitempty"`
	// Default value in yaml: 100Mi
	Memory *string `json:"memory,omitempty" yaml:"memory,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *RawfileCsi090Values_Defaults_Resources_Limits) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsRawfileCsi090Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type RawfileCsi090Values_Defaults_Resources_Requests struct {
	// Default value in yaml: 10m
	Cpu *string `json:"cpu,omitempty" yaml:"cpu,omitempty"`
	// Default value in yaml: 100Mi
	Memory *string `json:"memory,omitempty" yaml:"memory,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *RawfileCsi090Values_Defaults_Resources_Requests) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsRawfileCsi090Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type RawfileCsi090Values_Defaults_Resources struct {
	Limits   *RawfileCsi090Values_Defaults_Resources_Limits   `json:"limits,omitempty" yaml:"limits,omitempty"`
	Requests *RawfileCsi090Values_Defaults_Resources_Requests `json:"requests,omitempty" yaml:"requests,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *RawfileCsi090Values_Defaults_Resources) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsRawfileCsi090Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type RawfileCsi090Values_Defaults struct {
	Image     *RawfileCsi090Values_Defaults_Image     `json:"image,omitempty" yaml:"image,omitempty"`
	Resources *RawfileCsi090Values_Defaults_Resources `json:"resources,omitempty" yaml:"resources,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *RawfileCsi090Values_Defaults) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsRawfileCsi090Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type RawfileCsi090Values_Controller struct {
	// Default value in yaml:
	// - csi-driver
	// - --disable-metrics
	CsiDriverArgs *[]string `json:"csiDriverArgs,omitempty" yaml:"csiDriverArgs,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *RawfileCsi090Values_Controller) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsRawfileCsi090Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type RawfileCsi090Values_Images struct {
	// Default value in yaml: registry.k8s.io/sig-storage/csi-node-driver-registrar:v2.10.1
	CsiNodeDriverRegistrar *string `json:"csiNodeDriverRegistrar,omitempty" yaml:"csiNodeDriverRegistrar,omitempty"`
	// Default value in yaml: registry.k8s.io/sig-storage/csi-provisioner:v5.0.1
	CsiProvisioner *string `json:"csiProvisioner,omitempty" yaml:"csiProvisioner,omitempty"`
	// Default value in yaml: registry.k8s.io/sig-storage/csi-resizer:v1.11.1
	CsiResizer *string `json:"csiResizer,omitempty" yaml:"csiResizer,omitempty"`
	// Default value in yaml: registry.k8s.io/sig-storage/csi-snapshotter:v8.0.1
	CsiSnapshotter *string `json:"csiSnapshotter,omitempty" yaml:"csiSnapshotter,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *RawfileCsi090Values_Images) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsRawfileCsi090Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type RawfileCsi090Values_Node_Storage struct {
	// Default value in yaml: /var/csi/rawfile
	Path *string `json:"path,omitempty" yaml:"path,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *RawfileCsi090Values_Node_Storage) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsRawfileCsi090Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type RawfileCsi090Values_Node_Metrics struct {
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *RawfileCsi090Values_Node_Metrics) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsRawfileCsi090Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type RawfileCsi090Values_Node struct {
	Storage *RawfileCsi090Values_Node_Storage `json:"storage,omitempty" yaml:"storage,omitempty"`
	Metrics *RawfileCsi090Values_Node_Metrics `json:"metrics,omitempty" yaml:"metrics,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *RawfileCsi090Values_Node) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsRawfileCsi090Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type RawfileCsi090Values_StorageClass struct {
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: csi-rawfile-default
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
	// Default value in yaml: true
	IsDefault *bool `json:"isDefault,omitempty" yaml:"isDefault,omitempty"`
	// Default value in yaml: Delete
	ReclaimPolicy *string `json:"reclaimPolicy,omitempty" yaml:"reclaimPolicy,omitempty"`
	// Default value in yaml: WaitForFirstConsumer
	VolumeBindingMode *string `json:"volumeBindingMode,omitempty" yaml:"volumeBindingMode,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *RawfileCsi090Values_StorageClass) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsRawfileCsi090Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type RawfileCsi090Values_ServiceMonitor struct {
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: 1m
	Interval *string `json:"interval,omitempty" yaml:"interval,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *RawfileCsi090Values_ServiceMonitor) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsRawfileCsi090Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

// RawfileCsi090Values represents the values of the rawfile-csi-0.9.0_values.yaml chart
type RawfileCsi090Values struct {
	// Default value in yaml: rawfile.csi.openebs.io
	ProvisionerName  *string                             `json:"provisionerName,omitempty" yaml:"provisionerName,omitempty"`
	Defaults         *RawfileCsi090Values_Defaults       `json:"defaults,omitempty" yaml:"defaults,omitempty"`
	Controller       *RawfileCsi090Values_Controller     `json:"controller,omitempty" yaml:"controller,omitempty"`
	Images           *RawfileCsi090Values_Images         `json:"images,omitempty" yaml:"images,omitempty"`
	Node             *RawfileCsi090Values_Node           `json:"node,omitempty" yaml:"node,omitempty"`
	StorageClass     *RawfileCsi090Values_StorageClass   `json:"storageClass,omitempty" yaml:"storageClass,omitempty"`
	ImagePullSecrets *[]any                              `json:"imagePullSecrets,omitempty" yaml:"imagePullSecrets,omitempty"`
	ServiceMonitor   *RawfileCsi090Values_ServiceMonitor `json:"serviceMonitor,omitempty" yaml:"serviceMonitor,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *RawfileCsi090Values) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsRawfileCsi090Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsRawfileCsi090Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

// mergeMaps recursively merges map B into map A.
// The name is unique to prevent conflicts with other autogenerated files in this package.
func mergeMapsRawfileCsi090Values(a, b map[string]any) {
	for key, bValue := range b {
		if aValue, ok := a[key]; ok {
			aMap, aIsMap := aValue.(map[string]any)
			bMap, bIsMap := bValue.(map[string]any)
			if aIsMap && bIsMap {
				mergeMapsRawfileCsi090Values(aMap, bMap)
				continue
			}
		}
		a[key] = bValue
	}
}
