// Code generated by running "./CHART_VALUES_STRUCT_GENERATOR -files=coredns-1.36.0_values.yaml,cilium-1.16.3_values.yaml,ck-loadbalancer_values.yaml,metallb-0.14.8_values.yaml,rawfile-csi-0.9.0_values.yaml,metrics-server-3.12.2_values.yaml -pkg=values -out-dir=../../../src/k8s/pkg/k8sd/features/values -advanced-types=true -unsafe-field=true". DO NOT EDIT.
//
// This file was autogenerated by the CHART_VALUES_STRUCT_GENERATOR tool on 2024-12-16.
// Any changes will be overwritten.
//
// These files are generated from the values.yaml files in the k8s/manifests/charts directory.
//
// Package values contains the Go structs representing the values of the Helm chart.
package values

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
)

//  To configure MetalLB, you must specify ONE of the following two
//  options.
//
type Metallb0148Values_Rbac struct {
	//  create specifies whether to install and use RBAC rules.
	//
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Rbac) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  the image to be used for the kuberbacproxy container
type Metallb0148Values_Prometheus_RbacProxy struct {
	// Default value in yaml: gcr.io/kubebuilder/kube-rbac-proxy
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	// Default value in yaml: v0.12.0
	Tag        *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus_RbacProxy) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Prometheus Operator PodMonitors
type Metallb0148Values_Prometheus_PodMonitor struct {
	//  enable support for Prometheus Operator
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  optional additionnal labels for podMonitors
	AdditionalLabels *map[string]any `json:"additionalLabels,omitempty" yaml:"additionalLabels,omitempty"`
	//  optional annotations for podMonitors
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  Job label for scrape target
	//
	// Default value in yaml: app.kubernetes.io/name
	JobLabel *string `json:"jobLabel,omitempty" yaml:"jobLabel,omitempty"`
	//  Scrape interval. If not set, the Prometheus default scrape interval is used.
	Interval *string `json:"interval,omitempty" yaml:"interval,omitempty"`
	//  	metric relabel configs to apply to samples before ingestion.
	//  - action: keep
	//    regex: 'kube_(daemonset|deployment|pod|namespace|node|statefulset).+'
	//    sourceLabels: [__name__]
	MetricRelabelings *[]any `json:"metricRelabelings,omitempty" yaml:"metricRelabelings,omitempty"`
	//  	relabel configs to apply to samples before ingestion.
	//  - sourceLabels: [__meta_kubernetes_pod_node_name]
	//    separator: ;
	//    regex: ^(.*)$
	//    target_label: nodename
	//    replacement: $1
	//    action: replace
	Relabelings *[]any `json:"relabelings,omitempty" yaml:"relabelings,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus_PodMonitor) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  optional tls configuration for the speaker serviceMonitor, in case
//  secure metrics are enabled.
type Metallb0148Values_Prometheus_ServiceMonitor_Speaker_TlsConfig struct {
	// Default value in yaml: true
	InsecureSkipVerify *bool `json:"insecureSkipVerify,omitempty" yaml:"insecureSkipVerify,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus_ServiceMonitor_Speaker_TlsConfig) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Prometheus_ServiceMonitor_Speaker struct {
	//  optional additional labels for the speaker serviceMonitor
	AdditionalLabels *map[string]any `json:"additionalLabels,omitempty" yaml:"additionalLabels,omitempty"`
	//  optional additional annotations for the speaker serviceMonitor
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  optional tls configuration for the speaker serviceMonitor, in case
	//  secure metrics are enabled.
	TlsConfig *Metallb0148Values_Prometheus_ServiceMonitor_Speaker_TlsConfig `json:"tlsConfig,omitempty" yaml:"tlsConfig,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus_ServiceMonitor_Speaker) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  optional tls configuration for the controller serviceMonitor, in case
//  secure metrics are enabled.
type Metallb0148Values_Prometheus_ServiceMonitor_Controller_TlsConfig struct {
	// Default value in yaml: true
	InsecureSkipVerify *bool `json:"insecureSkipVerify,omitempty" yaml:"insecureSkipVerify,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus_ServiceMonitor_Controller_TlsConfig) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Prometheus_ServiceMonitor_Controller struct {
	//  optional additional labels for the controller serviceMonitor
	AdditionalLabels *map[string]any `json:"additionalLabels,omitempty" yaml:"additionalLabels,omitempty"`
	//  optional additional annotations for the controller serviceMonitor
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  optional tls configuration for the controller serviceMonitor, in case
	//  secure metrics are enabled.
	TlsConfig *Metallb0148Values_Prometheus_ServiceMonitor_Controller_TlsConfig `json:"tlsConfig,omitempty" yaml:"tlsConfig,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus_ServiceMonitor_Controller) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Prometheus Operator ServiceMonitors. To be used as an alternative
//  to podMonitor, supports secure metrics.
type Metallb0148Values_Prometheus_ServiceMonitor struct {
	//  enable support for Prometheus Operator
	//
	// Default value in yaml: false
	Enabled    *bool                                                   `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	Speaker    *Metallb0148Values_Prometheus_ServiceMonitor_Speaker    `json:"speaker,omitempty" yaml:"speaker,omitempty"`
	Controller *Metallb0148Values_Prometheus_ServiceMonitor_Controller `json:"controller,omitempty" yaml:"controller,omitempty"`
	//  Job label for scrape target
	//
	// Default value in yaml: app.kubernetes.io/name
	JobLabel *string `json:"jobLabel,omitempty" yaml:"jobLabel,omitempty"`
	//  Scrape interval. If not set, the Prometheus default scrape interval is used.
	Interval *string `json:"interval,omitempty" yaml:"interval,omitempty"`
	//  	metric relabel configs to apply to samples before ingestion.
	//  - action: keep
	//    regex: 'kube_(daemonset|deployment|pod|namespace|node|statefulset).+'
	//    sourceLabels: [__name__]
	MetricRelabelings *[]any `json:"metricRelabelings,omitempty" yaml:"metricRelabelings,omitempty"`
	//  	relabel configs to apply to samples before ingestion.
	//  - sourceLabels: [__meta_kubernetes_pod_node_name]
	//    separator: ;
	//    regex: ^(.*)$
	//    target_label: nodename
	//    replacement: $1
	//    action: replace
	Relabelings *[]any `json:"relabelings,omitempty" yaml:"relabelings,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus_ServiceMonitor) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Prometheus_PrometheusRule_StaleConfig_Labels struct {
	// Default value in yaml: warning
	Severity *string `json:"severity,omitempty" yaml:"severity,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus_PrometheusRule_StaleConfig_Labels) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  MetalLBStaleConfig
type Metallb0148Values_Prometheus_PrometheusRule_StaleConfig struct {
	// Default value in yaml: true
	Enabled *bool                                                           `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	Labels  *Metallb0148Values_Prometheus_PrometheusRule_StaleConfig_Labels `json:"labels,omitempty" yaml:"labels,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus_PrometheusRule_StaleConfig) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Prometheus_PrometheusRule_ConfigNotLoaded_Labels struct {
	// Default value in yaml: warning
	Severity *string `json:"severity,omitempty" yaml:"severity,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus_PrometheusRule_ConfigNotLoaded_Labels) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  MetalLBConfigNotLoaded
type Metallb0148Values_Prometheus_PrometheusRule_ConfigNotLoaded struct {
	// Default value in yaml: true
	Enabled *bool                                                               `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	Labels  *Metallb0148Values_Prometheus_PrometheusRule_ConfigNotLoaded_Labels `json:"labels,omitempty" yaml:"labels,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus_PrometheusRule_ConfigNotLoaded) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Prometheus_PrometheusRule_AddressPoolExhausted_Labels struct {
	// Default value in yaml: alert
	Severity *string `json:"severity,omitempty" yaml:"severity,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus_PrometheusRule_AddressPoolExhausted_Labels) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  MetalLBAddressPoolExhausted
type Metallb0148Values_Prometheus_PrometheusRule_AddressPoolExhausted struct {
	// Default value in yaml: true
	Enabled *bool                                                                    `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	Labels  *Metallb0148Values_Prometheus_PrometheusRule_AddressPoolExhausted_Labels `json:"labels,omitempty" yaml:"labels,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus_PrometheusRule_AddressPoolExhausted) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Prometheus_PrometheusRule_AddressPoolUsage_ThresholdsItem_Labels struct {
	// Default value in yaml: warning
	Severity *string `json:"severity,omitempty" yaml:"severity,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus_PrometheusRule_AddressPoolUsage_ThresholdsItem_Labels) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Prometheus_PrometheusRule_AddressPoolUsage_ThresholdsItem struct {
	// Default value in yaml: 75
	Percent *int64                                                                              `json:"percent,omitempty" yaml:"percent,omitempty"`
	Labels  *Metallb0148Values_Prometheus_PrometheusRule_AddressPoolUsage_ThresholdsItem_Labels `json:"labels,omitempty" yaml:"labels,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus_PrometheusRule_AddressPoolUsage_ThresholdsItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Prometheus_PrometheusRule_AddressPoolUsage struct {
	// Default value in yaml: true
	Enabled    *bool                                                                          `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	Thresholds *[]Metallb0148Values_Prometheus_PrometheusRule_AddressPoolUsage_ThresholdsItem `json:"thresholds,omitempty" yaml:"thresholds,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus_PrometheusRule_AddressPoolUsage) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Prometheus_PrometheusRule_BgpSessionDown_Labels struct {
	// Default value in yaml: alert
	Severity *string `json:"severity,omitempty" yaml:"severity,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus_PrometheusRule_BgpSessionDown_Labels) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  MetalLBBGPSessionDown
type Metallb0148Values_Prometheus_PrometheusRule_BgpSessionDown struct {
	// Default value in yaml: true
	Enabled *bool                                                              `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	Labels  *Metallb0148Values_Prometheus_PrometheusRule_BgpSessionDown_Labels `json:"labels,omitempty" yaml:"labels,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus_PrometheusRule_BgpSessionDown) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Prometheus Operator alertmanager alerts
type Metallb0148Values_Prometheus_PrometheusRule struct {
	//  enable alertmanager alerts
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  optional additionnal labels for prometheusRules
	AdditionalLabels *map[string]any `json:"additionalLabels,omitempty" yaml:"additionalLabels,omitempty"`
	//  optional annotations for prometheusRules
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  MetalLBStaleConfig
	StaleConfig *Metallb0148Values_Prometheus_PrometheusRule_StaleConfig `json:"staleConfig,omitempty" yaml:"staleConfig,omitempty"`
	//  MetalLBConfigNotLoaded
	ConfigNotLoaded *Metallb0148Values_Prometheus_PrometheusRule_ConfigNotLoaded `json:"configNotLoaded,omitempty" yaml:"configNotLoaded,omitempty"`
	//  MetalLBAddressPoolExhausted
	AddressPoolExhausted *Metallb0148Values_Prometheus_PrometheusRule_AddressPoolExhausted `json:"addressPoolExhausted,omitempty" yaml:"addressPoolExhausted,omitempty"`
	AddressPoolUsage     *Metallb0148Values_Prometheus_PrometheusRule_AddressPoolUsage     `json:"addressPoolUsage,omitempty" yaml:"addressPoolUsage,omitempty"`
	//  MetalLBBGPSessionDown
	BgpSessionDown *Metallb0148Values_Prometheus_PrometheusRule_BgpSessionDown `json:"bgpSessionDown,omitempty" yaml:"bgpSessionDown,omitempty"`
	ExtraAlerts    *[]any                                                      `json:"extraAlerts,omitempty" yaml:"extraAlerts,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus_PrometheusRule) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Prometheus struct {
	//  scrape annotations specifies whether to add Prometheus metric
	//  auto-collection annotations to pods. See
	//  https://github.com/prometheus/prometheus/blob/release-2.1/documentation/examples/prometheus-kubernetes.yml
	//  for a corresponding Prometheus configuration. Alternatively, you
	//  may want to use the Prometheus Operator
	//  (https://github.com/coreos/prometheus-operator) for more powerful
	//  monitoring configuration. If you use the Prometheus operator, this
	//  can be left at false.
	//
	// Default value in yaml: false
	ScrapeAnnotations *bool `json:"scrapeAnnotations,omitempty" yaml:"scrapeAnnotations,omitempty"`
	//  port both controller and speaker will listen on for metrics
	//
	// Default value in yaml: 7472
	MetricsPort *int64 `json:"metricsPort,omitempty" yaml:"metricsPort,omitempty"`
	//  if set, enables rbac proxy on the controller and speaker to expose
	//  the metrics via tls.
	//  secureMetricsPort: 9120
	//
	//  the name of the secret to be mounted in the speaker pod
	//  to expose the metrics securely. If not present, a self signed
	//  certificate to be used.
	SpeakerMetricsTlssecret *string `json:"speakerMetricsTLSSecret,omitempty" yaml:"speakerMetricsTLSSecret,omitempty"`
	//  the name of the secret to be mounted in the controller pod
	//  to expose the metrics securely. If not present, a self signed
	//  certificate to be used.
	ControllerMetricsTlssecret *string `json:"controllerMetricsTLSSecret,omitempty" yaml:"controllerMetricsTLSSecret,omitempty"`
	//  prometheus doens't have the permission to scrape all namespaces so we give it permission to scrape metallb's one
	//
	// Default value in yaml: true
	RbacPrometheus *bool `json:"rbacPrometheus,omitempty" yaml:"rbacPrometheus,omitempty"`
	//  the service account used by prometheus
	//  required when " .Values.prometheus.rbacPrometheus == true " and " .Values.prometheus.podMonitor.enabled=true or prometheus.serviceMonitor.enabled=true "
	ServiceAccount *string `json:"serviceAccount,omitempty" yaml:"serviceAccount,omitempty"`
	//  the namespace where prometheus is deployed
	//  required when " .Values.prometheus.rbacPrometheus == true " and " .Values.prometheus.podMonitor.enabled=true or prometheus.serviceMonitor.enabled=true "
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty"`
	//  the image to be used for the kuberbacproxy container
	RbacProxy *Metallb0148Values_Prometheus_RbacProxy `json:"rbacProxy,omitempty" yaml:"rbacProxy,omitempty"`
	//  Prometheus Operator PodMonitors
	PodMonitor *Metallb0148Values_Prometheus_PodMonitor `json:"podMonitor,omitempty" yaml:"podMonitor,omitempty"`
	//  Prometheus Operator ServiceMonitors. To be used as an alternative
	//  to podMonitor, supports secure metrics.
	ServiceMonitor *Metallb0148Values_Prometheus_ServiceMonitor `json:"serviceMonitor,omitempty" yaml:"serviceMonitor,omitempty"`
	//  Prometheus Operator alertmanager alerts
	PrometheusRule *Metallb0148Values_Prometheus_PrometheusRule `json:"prometheusRule,omitempty" yaml:"prometheusRule,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Prometheus) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  command: /controller
//  webhookMode: enabled
type Metallb0148Values_Controller_Image struct {
	// Default value in yaml: quay.io/metallb/controller
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	Tag        *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Controller_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  @param controller.updateStrategy.type Metallb controller deployment strategy type.
//  ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
//  e.g:
//  strategy:
//   type: RollingUpdate
//   rollingUpdate:
//     maxSurge: 25%
//     maxUnavailable: 25%
//
type Metallb0148Values_Controller_Strategy struct {
	// Default value in yaml: RollingUpdate
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Controller_Strategy) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Controller_ServiceAccount struct {
	//  Specifies whether a ServiceAccount should be created
	//
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	//  The name of the ServiceAccount to use. If not set and create is
	//  true, a name is generated using the fullname template
	Name        *string         `json:"name,omitempty" yaml:"name,omitempty"`
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Controller_ServiceAccount) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Controller_SecurityContext struct {
	// Default value in yaml: true
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty"`
	//  nobody
	//
	// Default value in yaml: 65534
	RunAsUser *int64 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty"`
	// Default value in yaml: 65534
	FsGroup *int64 `json:"fsGroup,omitempty" yaml:"fsGroup,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Controller_SecurityContext) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Controller_LivenessProbe struct {
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: 3
	FailureThreshold *int64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty"`
	// Default value in yaml: 10
	InitialDelaySeconds *int64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty"`
	// Default value in yaml: 10
	PeriodSeconds *int64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty"`
	// Default value in yaml: 1
	SuccessThreshold *int64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty"`
	// Default value in yaml: 1
	TimeoutSeconds *int64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Controller_LivenessProbe) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Controller_ReadinessProbe struct {
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: 3
	FailureThreshold *int64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty"`
	// Default value in yaml: 10
	InitialDelaySeconds *int64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty"`
	// Default value in yaml: 10
	PeriodSeconds *int64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty"`
	// Default value in yaml: 1
	SuccessThreshold *int64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty"`
	// Default value in yaml: 1
	TimeoutSeconds *int64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Controller_ReadinessProbe) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  controller contains configuration specific to the MetalLB cluster
//  controller.
type Metallb0148Values_Controller struct {
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Controller log level. Must be one of: `all`, `debug`, `info`, `warn`, `error` or `none`
	//
	// Default value in yaml: info
	LogLevel *string `json:"logLevel,omitempty" yaml:"logLevel,omitempty"`
	//  command: /controller
	//  webhookMode: enabled
	Image *Metallb0148Values_Controller_Image `json:"image,omitempty" yaml:"image,omitempty"`
	//  @param controller.updateStrategy.type Metallb controller deployment strategy type.
	//  ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
	//  e.g:
	//  strategy:
	//   type: RollingUpdate
	//   rollingUpdate:
	//     maxSurge: 25%
	//     maxUnavailable: 25%
	//
	Strategy        *Metallb0148Values_Controller_Strategy        `json:"strategy,omitempty" yaml:"strategy,omitempty"`
	ServiceAccount  *Metallb0148Values_Controller_ServiceAccount  `json:"serviceAccount,omitempty" yaml:"serviceAccount,omitempty"`
	SecurityContext *Metallb0148Values_Controller_SecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`
	Resources       *map[string]any                               `json:"resources,omitempty" yaml:"resources,omitempty"`
	//  limits:
	//  cpu: 100m
	//  memory: 100Mi
	NodeSelector      *map[string]any                              `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty"`
	Tolerations       *[]any                                       `json:"tolerations,omitempty" yaml:"tolerations,omitempty"`
	PriorityClassName *string                                      `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty"`
	RuntimeClassName  *string                                      `json:"runtimeClassName,omitempty" yaml:"runtimeClassName,omitempty"`
	Affinity          *map[string]any                              `json:"affinity,omitempty" yaml:"affinity,omitempty"`
	PodAnnotations    *map[string]any                              `json:"podAnnotations,omitempty" yaml:"podAnnotations,omitempty"`
	Labels            *map[string]any                              `json:"labels,omitempty" yaml:"labels,omitempty"`
	LivenessProbe     *Metallb0148Values_Controller_LivenessProbe  `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty"`
	ReadinessProbe    *Metallb0148Values_Controller_ReadinessProbe `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty"`
	// Default value in yaml: VersionTLS12
	TlsMinVersion   *string `json:"tlsMinVersion,omitempty" yaml:"tlsMinVersion,omitempty"`
	TlsCipherSuites *string `json:"tlsCipherSuites,omitempty" yaml:"tlsCipherSuites,omitempty"`
	ExtraContainers *[]any  `json:"extraContainers,omitempty" yaml:"extraContainers,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Controller) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Speaker_Memberlist struct {
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: 7946
	MlBindPort         *int64  `json:"mlBindPort,omitempty" yaml:"mlBindPort,omitempty"`
	MlBindAddrOverride *string `json:"mlBindAddrOverride,omitempty" yaml:"mlBindAddrOverride,omitempty"`
	// Default value in yaml: /etc/ml_secret_key
	MlSecretKeyPath *string `json:"mlSecretKeyPath,omitempty" yaml:"mlSecretKeyPath,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Speaker_Memberlist) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Speaker_ExcludeInterfaces struct {
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Speaker_ExcludeInterfaces) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Speaker_Image struct {
	// Default value in yaml: quay.io/metallb/speaker
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	Tag        *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Speaker_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  @param speaker.updateStrategy.type Speaker daemonset strategy type
//  ref: https://kubernetes.io/docs/tasks/manage-daemon/update-daemon-set/
//
type Metallb0148Values_Speaker_UpdateStrategy struct {
	//  StrategyType
	//  Can be set to RollingUpdate or OnDelete
	//
	//
	// Default value in yaml: RollingUpdate
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Speaker_UpdateStrategy) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Speaker_ServiceAccount struct {
	//  Specifies whether a ServiceAccount should be created
	//
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	//  The name of the ServiceAccount to use. If not set and create is
	//  true, a name is generated using the fullname template
	Name        *string         `json:"name,omitempty" yaml:"name,omitempty"`
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Speaker_ServiceAccount) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Speaker_LivenessProbe struct {
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: 3
	FailureThreshold *int64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty"`
	// Default value in yaml: 10
	InitialDelaySeconds *int64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty"`
	// Default value in yaml: 10
	PeriodSeconds *int64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty"`
	// Default value in yaml: 1
	SuccessThreshold *int64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty"`
	// Default value in yaml: 1
	TimeoutSeconds *int64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Speaker_LivenessProbe) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Speaker_ReadinessProbe struct {
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: 3
	FailureThreshold *int64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty"`
	// Default value in yaml: 10
	InitialDelaySeconds *int64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty"`
	// Default value in yaml: 10
	PeriodSeconds *int64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty"`
	// Default value in yaml: 1
	SuccessThreshold *int64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty"`
	// Default value in yaml: 1
	TimeoutSeconds *int64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Speaker_ReadinessProbe) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Speaker_StartupProbe struct {
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: 30
	FailureThreshold *int64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty"`
	// Default value in yaml: 5
	PeriodSeconds *int64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Speaker_StartupProbe) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Speaker_Frr_Image struct {
	// Default value in yaml: quay.io/frrouting/frr
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	// Default value in yaml: 9.1.0
	Tag        *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Speaker_Frr_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  frr contains configuration specific to the MetalLB FRR container,
//  for speaker running alongside FRR.
type Metallb0148Values_Speaker_Frr struct {
	// Default value in yaml: true
	Enabled *bool                                `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	Image   *Metallb0148Values_Speaker_Frr_Image `json:"image,omitempty" yaml:"image,omitempty"`
	// Default value in yaml: 7473
	MetricsPort *int64 `json:"metricsPort,omitempty" yaml:"metricsPort,omitempty"`
	//  if set, enables a rbac proxy sidecar container on the speaker to
	//  expose the frr metrics via tls.
	//  secureMetricsPort: 9121
	//
	Resources *map[string]any `json:"resources,omitempty" yaml:"resources,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Speaker_Frr) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Speaker_Reloader struct {
	Resources *map[string]any `json:"resources,omitempty" yaml:"resources,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Speaker_Reloader) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Speaker_FrrMetrics struct {
	Resources *map[string]any `json:"resources,omitempty" yaml:"resources,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Speaker_FrrMetrics) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  speaker contains configuration specific to the MetalLB speaker
//  daemonset.
type Metallb0148Values_Speaker struct {
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  command: /speaker
	//  -- Speaker log level. Must be one of: `all`, `debug`, `info`, `warn`, `error` or `none`
	//
	// Default value in yaml: info
	LogLevel *string `json:"logLevel,omitempty" yaml:"logLevel,omitempty"`
	// Default value in yaml: true
	TolerateMaster    *bool                                        `json:"tolerateMaster,omitempty" yaml:"tolerateMaster,omitempty"`
	Memberlist        *Metallb0148Values_Speaker_Memberlist        `json:"memberlist,omitempty" yaml:"memberlist,omitempty"`
	ExcludeInterfaces *Metallb0148Values_Speaker_ExcludeInterfaces `json:"excludeInterfaces,omitempty" yaml:"excludeInterfaces,omitempty"`
	//  ignore the exclude-from-external-loadbalancer label
	//
	// Default value in yaml: false
	IgnoreExcludeLb *bool                            `json:"ignoreExcludeLB,omitempty" yaml:"ignoreExcludeLB,omitempty"`
	Image           *Metallb0148Values_Speaker_Image `json:"image,omitempty" yaml:"image,omitempty"`
	//  @param speaker.updateStrategy.type Speaker daemonset strategy type
	//  ref: https://kubernetes.io/docs/tasks/manage-daemon/update-daemon-set/
	//
	UpdateStrategy  *Metallb0148Values_Speaker_UpdateStrategy `json:"updateStrategy,omitempty" yaml:"updateStrategy,omitempty"`
	ServiceAccount  *Metallb0148Values_Speaker_ServiceAccount `json:"serviceAccount,omitempty" yaml:"serviceAccount,omitempty"`
	SecurityContext *map[string]any                           `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`
	//  Defines a secret name for the controller to generate a memberlist encryption secret
	//  By default secretName: {{ "metallb.fullname" }}-memberlist
	//
	//  secretName:
	Resources *map[string]any `json:"resources,omitempty" yaml:"resources,omitempty"`
	//  limits:
	//  cpu: 100m
	//  memory: 100Mi
	NodeSelector      *map[string]any `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty"`
	Tolerations       *[]any          `json:"tolerations,omitempty" yaml:"tolerations,omitempty"`
	PriorityClassName *string         `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty"`
	Affinity          *map[string]any `json:"affinity,omitempty" yaml:"affinity,omitempty"`
	//  Selects which runtime class will be used by the pod.
	RuntimeClassName *string                                   `json:"runtimeClassName,omitempty" yaml:"runtimeClassName,omitempty"`
	PodAnnotations   *map[string]any                           `json:"podAnnotations,omitempty" yaml:"podAnnotations,omitempty"`
	Labels           *map[string]any                           `json:"labels,omitempty" yaml:"labels,omitempty"`
	LivenessProbe    *Metallb0148Values_Speaker_LivenessProbe  `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty"`
	ReadinessProbe   *Metallb0148Values_Speaker_ReadinessProbe `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty"`
	StartupProbe     *Metallb0148Values_Speaker_StartupProbe   `json:"startupProbe,omitempty" yaml:"startupProbe,omitempty"`
	//  frr contains configuration specific to the MetalLB FRR container,
	//  for speaker running alongside FRR.
	Frr             *Metallb0148Values_Speaker_Frr        `json:"frr,omitempty" yaml:"frr,omitempty"`
	Reloader        *Metallb0148Values_Speaker_Reloader   `json:"reloader,omitempty" yaml:"reloader,omitempty"`
	FrrMetrics      *Metallb0148Values_Speaker_FrrMetrics `json:"frrMetrics,omitempty" yaml:"frrMetrics,omitempty"`
	ExtraContainers *[]any                                `json:"extraContainers,omitempty" yaml:"extraContainers,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Speaker) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Metallb0148Values_Crds struct {
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: Fail
	ValidationFailurePolicy *string `json:"validationFailurePolicy,omitempty" yaml:"validationFailurePolicy,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Crds) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  frrk8s contains the configuration related to using an frrk8s instance
//  (github.com/metallb/frr-k8s) as the backend for the BGP implementation.
//  This allows configuring additional frr parameters in combination to those
//  applied by MetalLB.
type Metallb0148Values_Frrk8S struct {
	//  if set, enables frrk8s as a backend. This is mutually exclusive to frr
	//  mode.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: false
	External  *bool   `json:"external,omitempty" yaml:"external,omitempty"`
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values_Frrk8S) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

// Metallb0148Values represents the values of the metallb-0.14.8_values.yaml chart
type Metallb0148Values struct {
	ImagePullSecrets  *[]any  `json:"imagePullSecrets,omitempty" yaml:"imagePullSecrets,omitempty"`
	NameOverride      *string `json:"nameOverride,omitempty" yaml:"nameOverride,omitempty"`
	FullnameOverride  *string `json:"fullnameOverride,omitempty" yaml:"fullnameOverride,omitempty"`
	LoadBalancerClass *string `json:"loadBalancerClass,omitempty" yaml:"loadBalancerClass,omitempty"`
	//  To configure MetalLB, you must specify ONE of the following two
	//  options.
	//
	Rbac       *Metallb0148Values_Rbac       `json:"rbac,omitempty" yaml:"rbac,omitempty"`
	Prometheus *Metallb0148Values_Prometheus `json:"prometheus,omitempty" yaml:"prometheus,omitempty"`
	//  controller contains configuration specific to the MetalLB cluster
	//  controller.
	Controller *Metallb0148Values_Controller `json:"controller,omitempty" yaml:"controller,omitempty"`
	//  speaker contains configuration specific to the MetalLB speaker
	//  daemonset.
	Speaker *Metallb0148Values_Speaker `json:"speaker,omitempty" yaml:"speaker,omitempty"`
	Crds    *Metallb0148Values_Crds    `json:"crds,omitempty" yaml:"crds,omitempty"`
	//  frrk8s contains the configuration related to using an frrk8s instance
	//  (github.com/metallb/frr-k8s) as the backend for the BGP implementation.
	//  This allows configuring additional frr parameters in combination to those
	//  applied by MetalLB.
	Frrk8S *Metallb0148Values_Frrk8S `json:"frrk8s,omitempty" yaml:"frrk8s,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Metallb0148Values) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsMetallb0148Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsMetallb0148Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

// mergeMaps recursively merges map B into map A.
// The name is unique to prevent conflicts with other autogenerated files in this package.
func mergeMapsMetallb0148Values(a, b map[string]any) {
	for key, bValue := range b {
		if aValue, ok := a[key]; ok {
			aMap, aIsMap := aValue.(map[string]any)
			bMap, bIsMap := bValue.(map[string]any)
			if aIsMap && bIsMap {
				mergeMapsMetallb0148Values(aMap, bMap)
				continue
			}
		}
		a[key] = bValue
	}
}
