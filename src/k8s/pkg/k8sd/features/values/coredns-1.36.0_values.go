// Code generated by running "./CHART_VALUES_STRUCT_GENERATOR -files=coredns-1.36.0_values.yaml,cilium-1.16.3_values.yaml,ck-loadbalancer_values.yaml,metallb-0.14.8_values.yaml,rawfile-csi-0.9.0_values.yaml,metrics-server-3.12.2_values.yaml -pkg=values -out-dir=../../../src/k8s/pkg/k8sd/features/values -advanced-types=true -unsafe-field=true". DO NOT EDIT.
//
// This file was autogenerated by the CHART_VALUES_STRUCT_GENERATOR tool on 2024-12-16.
// Any changes will be overwritten.
//
// These files are generated from the values.yaml files in the k8s/manifests/charts directory.
//
// Package values contains the Go structs representing the values of the Helm chart.
package values

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
)

type Coredns1360Values_Image struct {
	// Default value in yaml: coredns/coredns
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	//  Overrides the image tag whose default is the chart appVersion.
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	// Default value in yaml: IfNotPresent
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`
	//  Optionally specify an array of imagePullSecrets.
	//  Secrets must be manually created in the namespace.
	//  ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
	//
	//  pullSecrets:
	//    - name: myRegistryKeySecretName
	PullSecrets *[]any `json:"pullSecrets,omitempty" yaml:"pullSecrets,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Coredns1360Values_Resources_Limits struct {
	// Default value in yaml: 100m
	Cpu *string `json:"cpu,omitempty" yaml:"cpu,omitempty"`
	// Default value in yaml: 128Mi
	Memory *string `json:"memory,omitempty" yaml:"memory,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_Resources_Limits) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Coredns1360Values_Resources_Requests struct {
	// Default value in yaml: 100m
	Cpu *string `json:"cpu,omitempty" yaml:"cpu,omitempty"`
	// Default value in yaml: 128Mi
	Memory *string `json:"memory,omitempty" yaml:"memory,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_Resources_Requests) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Coredns1360Values_Resources struct {
	Limits   *Coredns1360Values_Resources_Limits   `json:"limits,omitempty" yaml:"limits,omitempty"`
	Requests *Coredns1360Values_Resources_Requests `json:"requests,omitempty" yaml:"requests,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_Resources) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Coredns1360Values_RollingUpdate struct {
	// Default value in yaml: 1
	MaxUnavailable *int64 `json:"maxUnavailable,omitempty" yaml:"maxUnavailable,omitempty"`
	// Default value in yaml: 25%
	MaxSurge *string `json:"maxSurge,omitempty" yaml:"maxSurge,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_RollingUpdate) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Coredns1360Values_Prometheus_Service_Annotations struct {
	// Default value in yaml: true
	PrometheusIoscrape *string `json:"prometheus.io/scrape,omitempty" yaml:"prometheus.io/scrape,omitempty"`
	// Default value in yaml: 9153
	PrometheusIoport *string `json:"prometheus.io/port,omitempty" yaml:"prometheus.io/port,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_Prometheus_Service_Annotations) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Coredns1360Values_Prometheus_Service struct {
	// Default value in yaml: false
	Enabled     *bool                                             `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	Annotations *Coredns1360Values_Prometheus_Service_Annotations `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	Selector    *map[string]any                                   `json:"selector,omitempty" yaml:"selector,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_Prometheus_Service) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Coredns1360Values_Prometheus_Monitor struct {
	// Default value in yaml: false
	Enabled          *bool           `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	AdditionalLabels *map[string]any `json:"additionalLabels,omitempty" yaml:"additionalLabels,omitempty"`
	Namespace        *string         `json:"namespace,omitempty" yaml:"namespace,omitempty"`
	Interval         *string         `json:"interval,omitempty" yaml:"interval,omitempty"`
	Selector         *map[string]any `json:"selector,omitempty" yaml:"selector,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_Prometheus_Monitor) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Coredns1360Values_Prometheus struct {
	Service *Coredns1360Values_Prometheus_Service `json:"service,omitempty" yaml:"service,omitempty"`
	Monitor *Coredns1360Values_Prometheus_Monitor `json:"monitor,omitempty" yaml:"monitor,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_Prometheus) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Coredns1360Values_Service struct {
	//  clusterIP: ""
	//  clusterIPs: []
	//  loadBalancerIP: ""
	//  loadBalancerClass: ""
	//  externalIPs: []
	//  externalTrafficPolicy: ""
	//  ipFamilyPolicy: ""
	//  trafficDistribution: PreferClose
	//  The name of the Service
	//  If not set, a name is generated using the fullname template
	Name        *string         `json:"name,omitempty" yaml:"name,omitempty"`
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  Pod selector
	Selector *map[string]any `json:"selector,omitempty" yaml:"selector,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_Service) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Coredns1360Values_ServiceAccount struct {
	// Default value in yaml: false
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	//  The name of the ServiceAccount to use
	//  If not set and create is true, a name is generated using the fullname template
	Name        *string         `json:"name,omitempty" yaml:"name,omitempty"`
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_ServiceAccount) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Coredns1360Values_Rbac struct {
	//  If true, create & use RBAC resources
	//
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	//  If true, create and use PodSecurityPolicy
	//  The name of the ServiceAccount to use.
	//  If not set and create is true, a name is generated using the fullname template
	//  name:
	//
	// Default value in yaml: false
	PspEnable *bool `json:"pspEnable,omitempty" yaml:"pspEnable,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_Rbac) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Coredns1360Values_SecurityContext_Capabilities struct {
	// Default value in yaml:
	// - NET_BIND_SERVICE
	Add *[]string `json:"add,omitempty" yaml:"add,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_SecurityContext_Capabilities) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Configure SecurityContext for Pod.
//  Ensure that required linux capability to bind port number below 1024 is assigned (`CAP_NET_BIND_SERVICE`).
type Coredns1360Values_SecurityContext struct {
	Capabilities *Coredns1360Values_SecurityContext_Capabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_SecurityContext) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Coredns1360Values_ServersItem_ZonesItem struct {
	// Default value in yaml: .
	Zone *string `json:"zone,omitempty" yaml:"zone,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_ServersItem_ZonesItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- expose the service on a different port
//  servicePort: 5353
//  If serviceType is nodePort you can specify nodePort here
//  nodePort: 30053
//  hostPort: 53
type Coredns1360Values_ServersItem_PluginsItem struct {
	// Default value in yaml: errors
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_ServersItem_PluginsItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Default zone is what Kubernetes recommends:
//  https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/#coredns-configmap-options
type Coredns1360Values_ServersItem struct {
	Zones *[]Coredns1360Values_ServersItem_ZonesItem `json:"zones,omitempty" yaml:"zones,omitempty"`
	// Default value in yaml: 53
	Port *int64 `json:"port,omitempty" yaml:"port,omitempty"`
	//  -- expose the service on a different port
	//  servicePort: 5353
	//  If serviceType is nodePort you can specify nodePort here
	//  nodePort: 30053
	//  hostPort: 53
	Plugins *[]Coredns1360Values_ServersItem_PluginsItem `json:"plugins,omitempty" yaml:"plugins,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_ServersItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  To use the livenessProbe, the health plugin needs to be enabled in CoreDNS' server config
type Coredns1360Values_LivenessProbe struct {
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: 60
	InitialDelaySeconds *int64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty"`
	// Default value in yaml: 10
	PeriodSeconds *int64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty"`
	// Default value in yaml: 5
	TimeoutSeconds *int64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty"`
	// Default value in yaml: 5
	FailureThreshold *int64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty"`
	// Default value in yaml: 1
	SuccessThreshold *int64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_LivenessProbe) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  To use the readinessProbe, the ready plugin needs to be enabled in CoreDNS' server config
type Coredns1360Values_ReadinessProbe struct {
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: 30
	InitialDelaySeconds *int64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty"`
	// Default value in yaml: 10
	PeriodSeconds *int64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty"`
	// Default value in yaml: 5
	TimeoutSeconds *int64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty"`
	// Default value in yaml: 5
	FailureThreshold *int64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty"`
	// Default value in yaml: 1
	SuccessThreshold *int64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_ReadinessProbe) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Alternative configuration for HPA deployment if wanted
//  Create HorizontalPodAutoscaler object.
//
//  hpa:
//    enabled: false
//    minReplicas: 1
//    maxReplicas: 10
//    metrics:
//     metrics:
//     - type: Resource
//       resource:
//         name: memory
//         target:
//           type: Utilization
//           averageUtilization: 60
//     - type: Resource
//       resource:
//         name: cpu
//         target:
//           type: Utilization
//           averageUtilization: 60
//
type Coredns1360Values_Hpa struct {
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: 1
	MinReplicas *int64 `json:"minReplicas,omitempty" yaml:"minReplicas,omitempty"`
	// Default value in yaml: 2
	MaxReplicas *int64 `json:"maxReplicas,omitempty" yaml:"maxReplicas,omitempty"`
	Metrics     *[]any `json:"metrics,omitempty" yaml:"metrics,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_Hpa) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Optionally specify some extra flags to pass to cluster-proprtional-autoscaler.
//  Useful for e.g. the nodelabels flag.
//  customFlags:
//    - --nodelabels=topology.kubernetes.io/zone=us-east-1a
//
type Coredns1360Values_Autoscaler_Image struct {
	// Default value in yaml: registry.k8s.io/cpa/cluster-proportional-autoscaler
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	// Default value in yaml: 1.8.5
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	// Default value in yaml: IfNotPresent
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`
	//  Optionally specify an array of imagePullSecrets.
	//  Secrets must be manually created in the namespace.
	//  ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
	//
	//  pullSecrets:
	//    - name: myRegistryKeySecretName
	PullSecrets *[]any `json:"pullSecrets,omitempty" yaml:"pullSecrets,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_Autoscaler_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Coredns1360Values_Autoscaler_Resources_Requests struct {
	// Default value in yaml: 20m
	Cpu *string `json:"cpu,omitempty" yaml:"cpu,omitempty"`
	// Default value in yaml: 10Mi
	Memory *string `json:"memory,omitempty" yaml:"memory,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_Autoscaler_Resources_Requests) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Coredns1360Values_Autoscaler_Resources_Limits struct {
	// Default value in yaml: 20m
	Cpu *string `json:"cpu,omitempty" yaml:"cpu,omitempty"`
	// Default value in yaml: 10Mi
	Memory *string `json:"memory,omitempty" yaml:"memory,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_Autoscaler_Resources_Limits) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  resources for autoscaler pod
type Coredns1360Values_Autoscaler_Resources struct {
	Requests *Coredns1360Values_Autoscaler_Resources_Requests `json:"requests,omitempty" yaml:"requests,omitempty"`
	Limits   *Coredns1360Values_Autoscaler_Resources_Limits   `json:"limits,omitempty" yaml:"limits,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_Autoscaler_Resources) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Options for autoscaler configmap
type Coredns1360Values_Autoscaler_Configmap struct {
	//  Annotations for the coredns-autoscaler configmap
	//  i.e. strategy.spinnaker.io/versioned: "false" to ensure configmap isn't renamed
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_Autoscaler_Configmap) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Enables the livenessProbe for cluster-proportional-autoscaler - this requires version 1.8.0+ of the autoscaler
type Coredns1360Values_Autoscaler_LivenessProbe struct {
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: 10
	InitialDelaySeconds *int64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty"`
	// Default value in yaml: 5
	PeriodSeconds *int64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty"`
	// Default value in yaml: 5
	TimeoutSeconds *int64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty"`
	// Default value in yaml: 3
	FailureThreshold *int64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty"`
	// Default value in yaml: 1
	SuccessThreshold *int64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_Autoscaler_LivenessProbe) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Configue a cluster-proportional-autoscaler for coredns
//  See https://github.com/kubernetes-incubator/cluster-proportional-autoscaler
type Coredns1360Values_Autoscaler struct {
	//  Enabled the cluster-proportional-autoscaler
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  Number of cores in the cluster per coredns replica
	//
	// Default value in yaml: 256
	CoresPerReplica *int64 `json:"coresPerReplica,omitempty" yaml:"coresPerReplica,omitempty"`
	//  Number of nodes in the cluster per coredns replica
	//
	// Default value in yaml: 16
	NodesPerReplica *int64 `json:"nodesPerReplica,omitempty" yaml:"nodesPerReplica,omitempty"`
	//  Min size of replicaCount
	//
	// Default value in yaml: 0
	Min *int64 `json:"min,omitempty" yaml:"min,omitempty"`
	//  Max size of replicaCount (default of 0 is no max)
	//
	// Default value in yaml: 0
	Max *int64 `json:"max,omitempty" yaml:"max,omitempty"`
	//  Whether to include unschedulable nodes in the nodes/cores calculations - this requires version 1.8.0+ of the autoscaler
	//
	// Default value in yaml: false
	IncludeUnschedulableNodes *bool `json:"includeUnschedulableNodes,omitempty" yaml:"includeUnschedulableNodes,omitempty"`
	//  If true does not allow single points of failure to form
	//
	// Default value in yaml: true
	PreventSinglePointFailure *bool `json:"preventSinglePointFailure,omitempty" yaml:"preventSinglePointFailure,omitempty"`
	//  Annotations for the coredns proportional autoscaler pods
	PodAnnotations *map[string]any `json:"podAnnotations,omitempty" yaml:"podAnnotations,omitempty"`
	//  Optionally specify some extra flags to pass to cluster-proprtional-autoscaler.
	//  Useful for e.g. the nodelabels flag.
	//  customFlags:
	//    - --nodelabels=topology.kubernetes.io/zone=us-east-1a
	//
	Image *Coredns1360Values_Autoscaler_Image `json:"image,omitempty" yaml:"image,omitempty"`
	//  Optional priority class to be used for the autoscaler pods. priorityClassName used if not set.
	PriorityClassName *string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty"`
	//  expects input structure as per specification https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#affinity-v1-core
	Affinity *map[string]any `json:"affinity,omitempty" yaml:"affinity,omitempty"`
	//  Node labels for pod assignment
	//  Ref: https://kubernetes.io/docs/user-guide/node-selection/
	NodeSelector *map[string]any `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty"`
	//  expects input structure as per specification https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#toleration-v1-core
	Tolerations *[]any `json:"tolerations,omitempty" yaml:"tolerations,omitempty"`
	//  resources for autoscaler pod
	Resources *Coredns1360Values_Autoscaler_Resources `json:"resources,omitempty" yaml:"resources,omitempty"`
	//  Options for autoscaler configmap
	Configmap *Coredns1360Values_Autoscaler_Configmap `json:"configmap,omitempty" yaml:"configmap,omitempty"`
	//  Enables the livenessProbe for cluster-proportional-autoscaler - this requires version 1.8.0+ of the autoscaler
	LivenessProbe *Coredns1360Values_Autoscaler_LivenessProbe `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty"`
	//  optional array of sidecar containers
	//  - name: some-container-name
	//    image: some-image:latest
	//    imagePullPolicy: Always
	ExtraContainers *[]any `json:"extraContainers,omitempty" yaml:"extraContainers,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_Autoscaler) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Coredns1360Values_Deployment struct {
	// Default value in yaml: false
	SkipConfig *bool `json:"skipConfig,omitempty" yaml:"skipConfig,omitempty"`
	// Default value in yaml: true
	Enabled *bool   `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	Name    *string `json:"name,omitempty" yaml:"name,omitempty"`
	//  Annotations for the coredns deployment
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  Pod selector
	Selector *map[string]any `json:"selector,omitempty" yaml:"selector,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values_Deployment) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

// Coredns1360Values represents the values of the coredns-1.36.0_values.yaml chart
type Coredns1360Values struct {
	Image *Coredns1360Values_Image `json:"image,omitempty" yaml:"image,omitempty"`
	// Default value in yaml: 1
	ReplicaCount  *int64                           `json:"replicaCount,omitempty" yaml:"replicaCount,omitempty"`
	Resources     *Coredns1360Values_Resources     `json:"resources,omitempty" yaml:"resources,omitempty"`
	RollingUpdate *Coredns1360Values_RollingUpdate `json:"rollingUpdate,omitempty" yaml:"rollingUpdate,omitempty"`
	// Default value in yaml: 30
	TerminationGracePeriodSeconds *int64 `json:"terminationGracePeriodSeconds,omitempty" yaml:"terminationGracePeriodSeconds,omitempty"`
	//   cluster-autoscaler.kubernetes.io/safe-to-evict: "false"
	PodAnnotations *map[string]any `json:"podAnnotations,omitempty" yaml:"podAnnotations,omitempty"`
	// Default value in yaml: ClusterIP
	ServiceType    *string                           `json:"serviceType,omitempty" yaml:"serviceType,omitempty"`
	Prometheus     *Coredns1360Values_Prometheus     `json:"prometheus,omitempty" yaml:"prometheus,omitempty"`
	Service        *Coredns1360Values_Service        `json:"service,omitempty" yaml:"service,omitempty"`
	ServiceAccount *Coredns1360Values_ServiceAccount `json:"serviceAccount,omitempty" yaml:"serviceAccount,omitempty"`
	Rbac           *Coredns1360Values_Rbac           `json:"rbac,omitempty" yaml:"rbac,omitempty"`
	//  isClusterService specifies whether chart should be deployed as cluster-service or normal k8s app.
	//
	// Default value in yaml: true
	IsClusterService *bool `json:"isClusterService,omitempty" yaml:"isClusterService,omitempty"`
	//  Optional priority class to be used for the coredns pods. Used for autoscaler if autoscaler.priorityClassName not set.
	PriorityClassName *string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty"`
	//  Configure the pod level securityContext.
	PodSecurityContext *map[string]any `json:"podSecurityContext,omitempty" yaml:"podSecurityContext,omitempty"`
	//  Configure SecurityContext for Pod.
	//  Ensure that required linux capability to bind port number below 1024 is assigned (`CAP_NET_BIND_SERVICE`).
	SecurityContext *Coredns1360Values_SecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`
	//  Default zone is what Kubernetes recommends:
	//  https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/#coredns-configmap-options
	Servers *[]Coredns1360Values_ServersItem `json:"servers,omitempty" yaml:"servers,omitempty"`
	//  Complete example with all the options:
	//  - zones:                 # the `zones` block can be left out entirely, defaults to "."
	//    - zone: hello.world.   # optional, defaults to "."
	//      scheme: tls://       # optional, defaults to "" (which equals "dns://" in CoreDNS)
	//    - zone: foo.bar.
	//      scheme: dns://
	//      use_tcp: true        # set this parameter to optionally expose the port on tcp as well as udp for the DNS protocol
	//                           # Note that this will not work if you are also exposing tls or grpc on the same server
	//    port: 12345            # optional, defaults to "" (which equals 53 in CoreDNS)
	//    plugins:               # the plugins to use for this server block
	//    - name: kubernetes     # name of plugin, if used multiple times ensure that the plugin supports it!
	//      parameters: foo bar  # list of parameters after the plugin
	//      configBlock: |-      # if the plugin supports extra block style config, supply it here
	//        hello world
	//        foo bar
	//
	//  Extra configuration that is applied outside of the default zone block.
	//  Example to include additional config files, which may come from extraVolumes:
	//  extraConfig:
	//    import:
	//      parameters: /opt/coredns/*.conf
	ExtraConfig *map[string]any `json:"extraConfig,omitempty" yaml:"extraConfig,omitempty"`
	//  To use the livenessProbe, the health plugin needs to be enabled in CoreDNS' server config
	LivenessProbe *Coredns1360Values_LivenessProbe `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty"`
	//  To use the readinessProbe, the ready plugin needs to be enabled in CoreDNS' server config
	ReadinessProbe *Coredns1360Values_ReadinessProbe `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty"`
	//  expects input structure as per specification https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#affinity-v1-core
	//  for example:
	//    affinity:
	//      nodeAffinity:
	//       requiredDuringSchedulingIgnoredDuringExecution:
	//         nodeSelectorTerms:
	//         - matchExpressions:
	//           - key: foo.bar.com/role
	//             operator: In
	//             values:
	//             - master
	Affinity *map[string]any `json:"affinity,omitempty" yaml:"affinity,omitempty"`
	//  expects input structure as per specification https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#topologyspreadconstraint-v1-core
	//  and supports Helm templating.
	//  For example:
	//    topologySpreadConstraints:
	//      - labelSelector:
	//          matchLabels:
	//            app.kubernetes.io/name: '{{ template "coredns.name" . }}'
	//            app.kubernetes.io/instance: '{{ .Release.Name }}'
	//        topologyKey: topology.kubernetes.io/zone
	//        maxSkew: 1
	//        whenUnsatisfiable: ScheduleAnyway
	//      - labelSelector:
	//          matchLabels:
	//            app.kubernetes.io/name: '{{ template "coredns.name" . }}'
	//            app.kubernetes.io/instance: '{{ .Release.Name }}'
	//        topologyKey: kubernetes.io/hostname
	//        maxSkew: 1
	//        whenUnsatisfiable: ScheduleAnyway
	TopologySpreadConstraints *[]any `json:"topologySpreadConstraints,omitempty" yaml:"topologySpreadConstraints,omitempty"`
	//  Node labels for pod assignment
	//  Ref: https://kubernetes.io/docs/user-guide/node-selection/
	NodeSelector *map[string]any `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty"`
	//  expects input structure as per specification https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#toleration-v1-core
	//  for example:
	//    tolerations:
	//    - key: foo.bar.com/role
	//      operator: Equal
	//      value: master
	//      effect: NoSchedule
	Tolerations *[]any `json:"tolerations,omitempty" yaml:"tolerations,omitempty"`
	//  https://kubernetes.io/docs/tasks/run-application/configure-pdb/#specifying-a-poddisruptionbudget
	PodDisruptionBudget *map[string]any `json:"podDisruptionBudget,omitempty" yaml:"podDisruptionBudget,omitempty"`
	//  configure custom zone files as per https://coredns.io/2017/05/08/custom-dns-entries-for-kubernetes/
	//   - filename: example.db
	//     domain: example.com
	//     contents: |
	//       example.com.   IN SOA sns.dns.icann.com. noc.dns.icann.com. 2015082541 7200 3600 1209600 3600
	//       example.com.   IN NS  b.iana-servers.net.
	//       example.com.   IN NS  a.iana-servers.net.
	//       example.com.   IN A   192.168.99.102
	//       *.example.com. IN A   192.168.99.102
	ZoneFiles *[]any `json:"zoneFiles,omitempty" yaml:"zoneFiles,omitempty"`
	//  optional array of sidecar containers
	ExtraContainers *[]any `json:"extraContainers,omitempty" yaml:"extraContainers,omitempty"`
	//  - name: some-container-name
	//    image: some-image:latest
	//    imagePullPolicy: Always
	//  optional array of extra volumes to create
	ExtraVolumes *[]any `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty"`
	//  - name: some-volume-name
	//    emptyDir: {}
	//  optional array of mount points for extraVolumes
	//  - name: some-volume-name
	//    mountPath: /etc/wherever
	ExtraVolumeMounts *[]any `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty"`
	//  optional array of secrets to mount inside coredns container
	//  possible usecase: need for secure connection with etcd backend
	//  - name: etcd-client-certs
	//    mountPath: /etc/coredns/tls/etcd
	//    defaultMode: 420
	//  - name: some-fancy-secret
	//    mountPath: /etc/wherever
	//    defaultMode: 440
	ExtraSecrets *[]any `json:"extraSecrets,omitempty" yaml:"extraSecrets,omitempty"`
	//  optional array of environment variables for coredns container
	//  possible usecase: provides username and password for etcd user authentications
	//  - name: WHATEVER_ENV
	//    value: whatever
	//  - name: SOME_SECRET_ENV
	//    valueFrom:
	//      secretKeyRef:
	//        name: some-secret-name
	//        key: secret-key
	Env *[]any `json:"env,omitempty" yaml:"env,omitempty"`
	//  To support legacy deployments using CoreDNS with the "k8s-app: kube-dns" label selectors.
	//  See https://github.com/coredns/helm/blob/master/charts/coredns/README.md#adopting-existing-coredns-resources
	//  k8sAppLabelOverride: "kube-dns"
	//
	//  Custom labels to apply to Deployment, Pod, Configmap, Service, ServiceMonitor. Including autoscaler if enabled.
	CustomLabels *map[string]any `json:"customLabels,omitempty" yaml:"customLabels,omitempty"`
	//  Custom annotations to apply to Deployment, Pod, Configmap, Service, ServiceMonitor. Including autoscaler if enabled.
	CustomAnnotations *map[string]any `json:"customAnnotations,omitempty" yaml:"customAnnotations,omitempty"`
	//  Alternative configuration for HPA deployment if wanted
	//  Create HorizontalPodAutoscaler object.
	//
	//  hpa:
	//    enabled: false
	//    minReplicas: 1
	//    maxReplicas: 10
	//    metrics:
	//     metrics:
	//     - type: Resource
	//       resource:
	//         name: memory
	//         target:
	//           type: Utilization
	//           averageUtilization: 60
	//     - type: Resource
	//       resource:
	//         name: cpu
	//         target:
	//           type: Utilization
	//           averageUtilization: 60
	//
	Hpa *Coredns1360Values_Hpa `json:"hpa,omitempty" yaml:"hpa,omitempty"`
	//  Configue a cluster-proportional-autoscaler for coredns
	//  See https://github.com/kubernetes-incubator/cluster-proportional-autoscaler
	Autoscaler *Coredns1360Values_Autoscaler `json:"autoscaler,omitempty" yaml:"autoscaler,omitempty"`
	Deployment *Coredns1360Values_Deployment `json:"deployment,omitempty" yaml:"deployment,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Coredns1360Values) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCoredns1360Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCoredns1360Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

// mergeMaps recursively merges map B into map A.
// The name is unique to prevent conflicts with other autogenerated files in this package.
func mergeMapsCoredns1360Values(a, b map[string]any) {
	for key, bValue := range b {
		if aValue, ok := a[key]; ok {
			aMap, aIsMap := aValue.(map[string]any)
			bMap, bIsMap := bValue.(map[string]any)
			if aIsMap && bIsMap {
				mergeMapsCoredns1360Values(aMap, bMap)
				continue
			}
		}
		a[key] = bValue
	}
}
