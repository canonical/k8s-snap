// Code generated by running "./CHART_VALUES_STRUCT_GENERATOR -files=coredns-1.36.0_values.yaml,cilium-1.16.3_values.yaml,ck-loadbalancer_values.yaml,metallb-0.14.8_values.yaml,rawfile-csi-0.9.0_values.yaml,metrics-server-3.12.2_values.yaml -pkg=values -out-dir=../../../src/k8s/pkg/k8sd/features/values -advanced-types=true -unsafe-field=true". DO NOT EDIT.
//
// This file was autogenerated by the CHART_VALUES_STRUCT_GENERATOR tool on 2024-12-16.
// Any changes will be overwritten.
//
// These files are generated from the values.yaml files in the k8s/manifests/charts directory.
//
// Package values contains the Go structs representing the values of the Helm chart.
package values

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
)

type Cilium1163Values_Debug struct {
	//  -- Enable debug logging
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- Configure verbosity levels for debug logging
	//  This option is used to enable debug messages for operations related to such
	//  sub-system such as (e.g. kvstore, envoy, datapath or policy), and flow is
	//  for enabling debug messages emitted per request, message and connection.
	//  Multiple values can be set via a space-separated string (e.g. "datapath envoy").
	//
	//  Applicable values:
	//  - flow
	//  - kvstore
	//  - envoy
	//  - datapath
	//  - policy
	//
	// Default value in yaml: ~
	Verbose *string `json:"verbose,omitempty" yaml:"verbose,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Debug) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Rbac struct {
	//  -- Enable creation of Resource-Based Access Control configuration.
	//
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Rbac) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure the client side rate limit for the agent and operator
//
//  If the amount of requests to the Kubernetes API server exceeds the configured
//  rate limit, the agent and operator will start to throttle requests by delaying
//  them until there is budget or the request times out.
type Cilium1163Values_K8SClientRateLimit struct {
	//  @schema
	//  type: [null, integer]
	//  @schema
	//  -- (int) The sustained request rate in requests per second.
	//  @default -- 5 for k8s up to 1.26. 10 for k8s version 1.27+
	Qps *string `json:"qps,omitempty" yaml:"qps,omitempty"`
	//  @schema
	//  type: [null, integer]
	//  @schema
	//  -- (int) The burst request rate in requests per second.
	//  The rate limiter will allow short bursts with a higher rate.
	//  @default -- 10 for k8s up to 1.26. 20 for k8s version 1.27+
	Burst *string `json:"burst,omitempty" yaml:"burst,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_K8SClientRateLimit) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Cluster struct {
	//  -- Name of the cluster. Only required for Cluster Mesh and mutual authentication with SPIRE.
	//  It must respect the following constraints:
	//  * It must contain at most 32 characters;
	//  * It must begin and end with a lower case alphanumeric character;
	//  * It may contain lower case alphanumeric characters and dashes between.
	//  The "default" name cannot be used if the Cluster ID is different from 0.
	//
	// Default value in yaml: default
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
	//  -- (int) Unique ID of the cluster. Must be unique across all connected
	//  clusters and in the range of 1 to 255. Only required for Cluster Mesh,
	//  may be 0 if Cluster Mesh is not used.
	//
	// Default value in yaml: 0
	Id *int64 `json:"id,omitempty" yaml:"id,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Cluster) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_ServiceAccounts_Cilium struct {
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	// Default value in yaml: cilium
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
	// Default value in yaml: true
	Automount   *bool           `json:"automount,omitempty" yaml:"automount,omitempty"`
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_ServiceAccounts_Cilium) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_ServiceAccounts_Nodeinit struct {
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	//  -- Enabled is temporary until https://github.com/cilium/cilium-cli/issues/1396 is implemented.
	//  Cilium CLI doesn't create the SAs for node-init, thus the workaround. Helm is not affected by
	//  this issue. Name and automount can be configured, if enabled is set to true.
	//  Otherwise, they are ignored. Enabled can be removed once the issue is fixed.
	//  Cilium-nodeinit DS must also be fixed.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: cilium-nodeinit
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
	// Default value in yaml: true
	Automount   *bool           `json:"automount,omitempty" yaml:"automount,omitempty"`
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_ServiceAccounts_Nodeinit) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_ServiceAccounts_Envoy struct {
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	// Default value in yaml: cilium-envoy
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
	// Default value in yaml: true
	Automount   *bool           `json:"automount,omitempty" yaml:"automount,omitempty"`
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_ServiceAccounts_Envoy) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_ServiceAccounts_Operator struct {
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	// Default value in yaml: cilium-operator
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
	// Default value in yaml: true
	Automount   *bool           `json:"automount,omitempty" yaml:"automount,omitempty"`
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_ServiceAccounts_Operator) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_ServiceAccounts_Preflight struct {
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	// Default value in yaml: cilium-pre-flight
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
	// Default value in yaml: true
	Automount   *bool           `json:"automount,omitempty" yaml:"automount,omitempty"`
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_ServiceAccounts_Preflight) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_ServiceAccounts_Relay struct {
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	// Default value in yaml: hubble-relay
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
	// Default value in yaml: false
	Automount   *bool           `json:"automount,omitempty" yaml:"automount,omitempty"`
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_ServiceAccounts_Relay) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_ServiceAccounts_Ui struct {
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	// Default value in yaml: hubble-ui
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
	// Default value in yaml: true
	Automount   *bool           `json:"automount,omitempty" yaml:"automount,omitempty"`
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_ServiceAccounts_Ui) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_ServiceAccounts_ClustermeshApiserver struct {
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	// Default value in yaml: clustermesh-apiserver
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
	// Default value in yaml: true
	Automount   *bool           `json:"automount,omitempty" yaml:"automount,omitempty"`
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_ServiceAccounts_ClustermeshApiserver) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Clustermeshcertgen is used if clustermesh.apiserver.tls.auto.method=cronJob
type Cilium1163Values_ServiceAccounts_Clustermeshcertgen struct {
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	// Default value in yaml: clustermesh-apiserver-generate-certs
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
	// Default value in yaml: true
	Automount   *bool           `json:"automount,omitempty" yaml:"automount,omitempty"`
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_ServiceAccounts_Clustermeshcertgen) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Hubblecertgen is used if hubble.tls.auto.method=cronJob
type Cilium1163Values_ServiceAccounts_Hubblecertgen struct {
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	// Default value in yaml: hubble-generate-certs
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
	// Default value in yaml: true
	Automount   *bool           `json:"automount,omitempty" yaml:"automount,omitempty"`
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_ServiceAccounts_Hubblecertgen) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Define serviceAccount names for components.
//  @default -- Component's fully qualified name.
type Cilium1163Values_ServiceAccounts struct {
	Cilium               *Cilium1163Values_ServiceAccounts_Cilium               `json:"cilium,omitempty" yaml:"cilium,omitempty"`
	Nodeinit             *Cilium1163Values_ServiceAccounts_Nodeinit             `json:"nodeinit,omitempty" yaml:"nodeinit,omitempty"`
	Envoy                *Cilium1163Values_ServiceAccounts_Envoy                `json:"envoy,omitempty" yaml:"envoy,omitempty"`
	Operator             *Cilium1163Values_ServiceAccounts_Operator             `json:"operator,omitempty" yaml:"operator,omitempty"`
	Preflight            *Cilium1163Values_ServiceAccounts_Preflight            `json:"preflight,omitempty" yaml:"preflight,omitempty"`
	Relay                *Cilium1163Values_ServiceAccounts_Relay                `json:"relay,omitempty" yaml:"relay,omitempty"`
	Ui                   *Cilium1163Values_ServiceAccounts_Ui                   `json:"ui,omitempty" yaml:"ui,omitempty"`
	ClustermeshApiserver *Cilium1163Values_ServiceAccounts_ClustermeshApiserver `json:"clustermeshApiserver,omitempty" yaml:"clustermeshApiserver,omitempty"`
	//  -- Clustermeshcertgen is used if clustermesh.apiserver.tls.auto.method=cronJob
	Clustermeshcertgen *Cilium1163Values_ServiceAccounts_Clustermeshcertgen `json:"clustermeshcertgen,omitempty" yaml:"clustermeshcertgen,omitempty"`
	//  -- Hubblecertgen is used if hubble.tls.auto.method=cronJob
	Hubblecertgen *Cilium1163Values_ServiceAccounts_Hubblecertgen `json:"hubblecertgen,omitempty" yaml:"hubblecertgen,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_ServiceAccounts) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Agent container image.
type Cilium1163Values_Image struct {
	//  @schema
	//  type: [null, string]
	//  @schema
	//
	// Default value in yaml: ~
	Override *string `json:"override,omitempty" yaml:"override,omitempty"`
	// Default value in yaml: quay.io/cilium/cilium
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	// Default value in yaml: v1.16.3
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	// Default value in yaml: IfNotPresent
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`
	//  cilium-digest
	//
	// Default value in yaml: sha256:62d2a09bbef840a46099ac4c69421c90f84f28d018d479749049011329aa7f28
	Digest *string `json:"digest,omitempty" yaml:"digest,omitempty"`
	// Default value in yaml: true
	UseDigest *bool `json:"useDigest,omitempty" yaml:"useDigest,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector_MatchLabels struct {
	// Default value in yaml: cilium
	K8SApp *string `json:"k8s-app,omitempty" yaml:"k8s-app,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector_MatchLabels) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector struct {
	MatchLabels *Cilium1163Values_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector_MatchLabels `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem struct {
	// Default value in yaml: kubernetes.io/hostname
	TopologyKey   *string                                                                                                     `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty"`
	LabelSelector *Cilium1163Values_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Affinity_PodAntiAffinity struct {
	RequiredDuringSchedulingIgnoredDuringExecution *[]Cilium1163Values_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Affinity_PodAntiAffinity) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Affinity for cilium-agent.
type Cilium1163Values_Affinity struct {
	PodAntiAffinity *Cilium1163Values_Affinity_PodAntiAffinity `json:"podAntiAffinity,omitempty" yaml:"podAntiAffinity,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Affinity) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Node selector for cilium-agent.
type Cilium1163Values_NodeSelector struct {
	// Default value in yaml: linux
	KubernetesIoos *string `json:"kubernetes.io/os,omitempty" yaml:"kubernetes.io/os,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_NodeSelector) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Node tolerations for agent scheduling to nodes with taints
//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
type Cilium1163Values_TolerationsItem struct {
	//  - key: "key"
	//    operator: "Equal|Exists"
	//    value: "value"
	//    effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"
	//
	// Default value in yaml: Exists
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_TolerationsItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- AppArmorProfile options for the `cilium-agent` and init containers
type Cilium1163Values_PodSecurityContext_AppArmorProfile struct {
	// Default value in yaml: Unconfined
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_PodSecurityContext_AppArmorProfile) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Security Context for cilium-agent pods.
type Cilium1163Values_PodSecurityContext struct {
	//  -- AppArmorProfile options for the `cilium-agent` and init containers
	AppArmorProfile *Cilium1163Values_PodSecurityContext_AppArmorProfile `json:"appArmorProfile,omitempty" yaml:"appArmorProfile,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_PodSecurityContext) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- SELinux options for the `cilium-agent` and init containers
type Cilium1163Values_SecurityContext_SeLinuxOptions struct {
	// Default value in yaml: s0
	Level *string `json:"level,omitempty" yaml:"level,omitempty"`
	//  Running with spc_t since we have removed the privileged mode.
	//  Users can change it to a different type as long as they have the
	//  type available on the system.
	//
	// Default value in yaml: spc_t
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_SecurityContext_SeLinuxOptions) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_SecurityContext_Capabilities struct {
	//  -- Capabilities for the `cilium-agent` container
	//
	// Default value in yaml:
	// - CHOWN
	// - KILL
	// - NET_ADMIN
	// - NET_RAW
	// - IPC_LOCK
	// - SYS_MODULE
	// - SYS_ADMIN
	// - SYS_RESOURCE
	// - DAC_OVERRIDE
	// - FOWNER
	// - SETGID
	// - SETUID
	CiliumAgent *[]string `json:"ciliumAgent,omitempty" yaml:"ciliumAgent,omitempty"`
	//  -- Capabilities for the `mount-cgroup` init container
	//
	// Default value in yaml:
	// - SYS_ADMIN
	// - SYS_CHROOT
	// - SYS_PTRACE
	MountCgroup *[]string `json:"mountCgroup,omitempty" yaml:"mountCgroup,omitempty"`
	//  -- capabilities for the `apply-sysctl-overwrites` init container
	//
	// Default value in yaml:
	// - SYS_ADMIN
	// - SYS_CHROOT
	// - SYS_PTRACE
	ApplySysctlOverwrites *[]string `json:"applySysctlOverwrites,omitempty" yaml:"applySysctlOverwrites,omitempty"`
	//  -- Capabilities for the `clean-cilium-state` init container
	//
	// Default value in yaml:
	// - NET_ADMIN
	// - SYS_MODULE
	// - SYS_ADMIN
	// - SYS_RESOURCE
	CleanCiliumState *[]string `json:"cleanCiliumState,omitempty" yaml:"cleanCiliumState,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_SecurityContext_Capabilities) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_SecurityContext struct {
	//  -- User to run the pod with
	//  runAsUser: 0
	//  -- Run the pod with elevated privileges
	//
	// Default value in yaml: false
	Privileged *bool `json:"privileged,omitempty" yaml:"privileged,omitempty"`
	//  -- SELinux options for the `cilium-agent` and init containers
	SeLinuxOptions *Cilium1163Values_SecurityContext_SeLinuxOptions `json:"seLinuxOptions,omitempty" yaml:"seLinuxOptions,omitempty"`
	Capabilities   *Cilium1163Values_SecurityContext_Capabilities   `json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_SecurityContext) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_UpdateStrategy_RollingUpdate struct {
	//  @schema
	//  type: [integer, string]
	//  @schema
	//
	// Default value in yaml: 2
	MaxUnavailable *int64 `json:"maxUnavailable,omitempty" yaml:"maxUnavailable,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_UpdateStrategy_RollingUpdate) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Cilium agent update strategy
type Cilium1163Values_UpdateStrategy struct {
	// Default value in yaml: RollingUpdate
	Type          *string                                        `json:"type,omitempty" yaml:"type,omitempty"`
	RollingUpdate *Cilium1163Values_UpdateStrategy_RollingUpdate `json:"rollingUpdate,omitempty" yaml:"rollingUpdate,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_UpdateStrategy) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Configuration Values for cilium-agent
type Cilium1163Values_Aksbyocni struct {
	//  -- Enable AKS BYOCNI integration.
	//  Note that this is incompatible with AKS clusters not created in BYOCNI mode:
	//  use Azure integration (`azure.enabled`) instead.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Aksbyocni) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Azure struct {
	//  -- Enable Azure integration.
	//  Note that this is incompatible with AKS clusters created in BYOCNI mode: use
	//  AKS BYOCNI integration (`aksbyocni.enabled`) instead.
	//  usePrimaryAddress: false
	//  resourceGroup: group1
	//  subscriptionID: 00000000-0000-0000-0000-000000000000
	//  tenantID: 00000000-0000-0000-0000-000000000000
	//  clientID: 00000000-0000-0000-0000-000000000000
	//  clientSecret: 00000000-0000-0000-0000-000000000000
	//  userAssignedIdentityID: 00000000-0000-0000-0000-000000000000
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Azure) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Alibabacloud struct {
	//  -- Enable AlibabaCloud ENI integration
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Alibabacloud) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Enable bandwidth manager to optimize TCP and UDP workloads and allow
//  for rate-limiting traffic from individual Pods with EDT (Earliest Departure
//  Time) through the "kubernetes.io/egress-bandwidth" Pod annotation.
type Cilium1163Values_BandwidthManager struct {
	//  -- Enable bandwidth manager infrastructure (also prerequirement for BBR)
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Activate BBR TCP congestion control for Pods
	//
	// Default value in yaml: false
	Bbr *bool `json:"bbr,omitempty" yaml:"bbr,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_BandwidthManager) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure standalone NAT46/NAT64 gateway
type Cilium1163Values_Nat46X64Gateway struct {
	//  -- Enable RFC8215-prefixed translation
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Nat46X64Gateway) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- EnableHighScaleIPcache enables the special ipcache mode for high scale
//  clusters. The ipcache content will be reduced to the strict minimum and
//  traffic will be encapsulated to carry security identities.
type Cilium1163Values_HighScaleIpcache struct {
	//  -- Enable the high scale mode for the ipcache.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_HighScaleIpcache) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure L2 announcements
type Cilium1163Values_L2Announcements struct {
	//  -- Enable L2 announcements
	//  -- If a lease is not renewed for X duration, the current leader is considered dead, a new leader is picked
	//  leaseDuration: 15s
	//  -- The interval at which the leader will renew the lease
	//  leaseRenewDeadline: 5s
	//  -- The timeout between retries if renewal fails
	//  leaseRetryPeriod: 2s
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_L2Announcements) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure L2 pod announcements
type Cilium1163Values_L2PodAnnouncements struct {
	//  -- Enable L2 pod announcements
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Interface used for sending Gratuitous ARP pod announcements
	//
	// Default value in yaml: eth0
	Interface *string `json:"interface,omitempty" yaml:"interface,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_L2PodAnnouncements) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Bgp_Announce struct {
	//  -- Enable allocation and announcement of service LoadBalancer IPs
	//
	// Default value in yaml: false
	LoadbalancerIp *bool `json:"loadbalancerIP,omitempty" yaml:"loadbalancerIP,omitempty"`
	//  -- Enable announcement of node pod CIDR
	//
	// Default value in yaml: false
	PodCidr *bool `json:"podCIDR,omitempty" yaml:"podCIDR,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Bgp_Announce) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure BGP
type Cilium1163Values_Bgp struct {
	//  -- Enable BGP support inside Cilium; embeds a new ConfigMap for BGP inside
	//  cilium-agent and cilium-operator
	//
	// Default value in yaml: false
	Enabled  *bool                          `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	Announce *Cilium1163Values_Bgp_Announce `json:"announce,omitempty" yaml:"announce,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Bgp) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- SecretsNamespace is the namespace which BGP support will retrieve secrets from.
type Cilium1163Values_BgpControlPlane_SecretsNamespace struct {
	//  -- Create secrets namespace for BGP secrets.
	//
	// Default value in yaml: false
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	//  -- The name of the secret namespace to which Cilium agents are given read access
	//
	// Default value in yaml: kube-system
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_BgpControlPlane_SecretsNamespace) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- This feature set enables virtual BGP routers to be created via
//  CiliumBGPPeeringPolicy CRDs.
type Cilium1163Values_BgpControlPlane struct {
	//  -- Enables the BGP control plane.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- SecretsNamespace is the namespace which BGP support will retrieve secrets from.
	SecretsNamespace *Cilium1163Values_BgpControlPlane_SecretsNamespace `json:"secretsNamespace,omitempty" yaml:"secretsNamespace,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_BgpControlPlane) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_PmtuDiscovery struct {
	//  -- Enable path MTU discovery to send ICMP fragmentation-needed replies to
	//  the client.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_PmtuDiscovery) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Bpf_AutoMount struct {
	//  -- Enable automatic mount of BPF filesystem
	//  When `autoMount` is enabled, the BPF filesystem is mounted at
	//  `bpf.root` path on the underlying host and inside the cilium agent pod.
	//  If users disable `autoMount`, it's expected that users have mounted
	//  bpffs filesystem at the specified `bpf.root` volume, and then the
	//  volume will be mounted inside the cilium agent pod at the same path.
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Bpf_AutoMount) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Bpf_Events_Drop struct {
	//  -- Enable drop events.
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Bpf_Events_Drop) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Bpf_Events_PolicyVerdict struct {
	//  -- Enable policy verdict events.
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Bpf_Events_PolicyVerdict) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Bpf_Events_Trace struct {
	//  -- Enable trace events.
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Bpf_Events_Trace) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Control events generated by the Cilium datapath exposed to Cilium monitor and Hubble.
type Cilium1163Values_Bpf_Events struct {
	Drop          *Cilium1163Values_Bpf_Events_Drop          `json:"drop,omitempty" yaml:"drop,omitempty"`
	PolicyVerdict *Cilium1163Values_Bpf_Events_PolicyVerdict `json:"policyVerdict,omitempty" yaml:"policyVerdict,omitempty"`
	Trace         *Cilium1163Values_Bpf_Events_Trace         `json:"trace,omitempty" yaml:"trace,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Bpf_Events) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Bpf struct {
	AutoMount *Cilium1163Values_Bpf_AutoMount `json:"autoMount,omitempty" yaml:"autoMount,omitempty"`
	//  -- Configure the mount point for the BPF filesystem
	//
	// Default value in yaml: /sys/fs/bpf
	Root *string `json:"root,omitempty" yaml:"root,omitempty"`
	//  -- Enables pre-allocation of eBPF map values. This increases
	//  memory usage but can reduce latency.
	//
	// Default value in yaml: false
	PreallocateMaps *bool `json:"preallocateMaps,omitempty" yaml:"preallocateMaps,omitempty"`
	//  @schema
	//  type: [null, integer]
	//  @schema
	//  -- (int) Configure the maximum number of entries in auth map.
	//  @default -- `524288`
	//
	// Default value in yaml: ~
	AuthMapMax *string `json:"authMapMax,omitempty" yaml:"authMapMax,omitempty"`
	//  @schema
	//  type: [null, integer]
	//  @schema
	//  -- (int) Configure the maximum number of entries in the TCP connection tracking
	//  table.
	//  @default -- `524288`
	//
	// Default value in yaml: ~
	CtTcpMax *string `json:"ctTcpMax,omitempty" yaml:"ctTcpMax,omitempty"`
	//  @schema
	//  type: [null, integer]
	//  @schema
	//  -- (int) Configure the maximum number of entries for the non-TCP connection
	//  tracking table.
	//  @default -- `262144`
	//
	// Default value in yaml: ~
	CtAnyMax *string `json:"ctAnyMax,omitempty" yaml:"ctAnyMax,omitempty"`
	//  -- Control events generated by the Cilium datapath exposed to Cilium monitor and Hubble.
	Events *Cilium1163Values_Bpf_Events `json:"events,omitempty" yaml:"events,omitempty"`
	//  @schema
	//  type: [null, integer]
	//  @schema
	//  -- Configure the maximum number of service entries in the
	//  load balancer maps.
	//
	// Default value in yaml: 65536
	LbMapMax *int64 `json:"lbMapMax,omitempty" yaml:"lbMapMax,omitempty"`
	//  @schema
	//  type: [null, integer]
	//  @schema
	//  -- (int) Configure the maximum number of entries for the NAT table.
	//  @default -- `524288`
	//
	// Default value in yaml: ~
	NatMax *string `json:"natMax,omitempty" yaml:"natMax,omitempty"`
	//  @schema
	//  type: [null, integer]
	//  @schema
	//  -- (int) Configure the maximum number of entries for the neighbor table.
	//  @default -- `524288`
	//
	// Default value in yaml: ~
	NeighMax *string `json:"neighMax,omitempty" yaml:"neighMax,omitempty"`
	//  @schema
	//  type: [null, integer]
	//  @schema
	//  @default -- `16384`
	//  -- (int) Configures the maximum number of entries for the node table.
	//
	// Default value in yaml: ~
	NodeMapMax *string `json:"nodeMapMax,omitempty" yaml:"nodeMapMax,omitempty"`
	//  -- Configure the maximum number of entries in endpoint policy map (per endpoint).
	//  @schema
	//  type: [null, integer]
	//  @schema
	//
	// Default value in yaml: 16384
	PolicyMapMax *int64 `json:"policyMapMax,omitempty" yaml:"policyMapMax,omitempty"`
	//  @schema
	//  type: [null, number]
	//  @schema
	//  -- (float64) Configure auto-sizing for all BPF maps based on available memory.
	//  ref: https://docs.cilium.io/en/stable/network/ebpf/maps/
	//  @default -- `0.0025`
	//
	// Default value in yaml: ~
	MapDynamicSizeRatio *string `json:"mapDynamicSizeRatio,omitempty" yaml:"mapDynamicSizeRatio,omitempty"`
	//  -- Configure the level of aggregation for monitor notifications.
	//  Valid options are none, low, medium, maximum.
	//
	// Default value in yaml: medium
	MonitorAggregation *string `json:"monitorAggregation,omitempty" yaml:"monitorAggregation,omitempty"`
	//  -- Configure the typical time between monitor notifications for
	//  active connections.
	//
	// Default value in yaml: 5s
	MonitorInterval *string `json:"monitorInterval,omitempty" yaml:"monitorInterval,omitempty"`
	//  -- Configure which TCP flags trigger notifications when seen for the
	//  first time in a connection.
	//
	// Default value in yaml: all
	MonitorFlags *string `json:"monitorFlags,omitempty" yaml:"monitorFlags,omitempty"`
	//  -- Allow cluster external access to ClusterIP services.
	//
	// Default value in yaml: false
	LbExternalClusterIp *bool `json:"lbExternalClusterIP,omitempty" yaml:"lbExternalClusterIP,omitempty"`
	//  @schema
	//  type: [null, boolean]
	//  @schema
	//  -- (bool) Enable native IP masquerade support in eBPF
	//  @default -- `false`
	//
	// Default value in yaml: ~
	Masquerade *string `json:"masquerade,omitempty" yaml:"masquerade,omitempty"`
	//  @schema
	//  type: [null, boolean]
	//  @schema
	//  -- (bool) Configure whether direct routing mode should route traffic via
	//  host stack (true) or directly and more efficiently out of BPF (false) if
	//  the kernel supports it. The latter has the implication that it will also
	//  bypass netfilter in the host namespace.
	//  @default -- `false`
	//
	// Default value in yaml: ~
	HostLegacyRouting *string `json:"hostLegacyRouting,omitempty" yaml:"hostLegacyRouting,omitempty"`
	//  @schema
	//  type: [null, boolean]
	//  @schema
	//  -- (bool) Configure the eBPF-based TPROXY to reduce reliance on iptables rules
	//  for implementing Layer 7 policy.
	//  @default -- `false`
	//
	// Default value in yaml: ~
	Tproxy *string `json:"tproxy,omitempty" yaml:"tproxy,omitempty"`
	//  @schema
	//  type: [null, array]
	//  @schema
	//  -- (list) Configure explicitly allowed VLAN id's for bpf logic bypass.
	//  [0] will allow all VLAN id's without any filtering.
	//  @default -- `[]`
	//
	// Default value in yaml: ~
	VlanBypass *string `json:"vlanBypass,omitempty" yaml:"vlanBypass,omitempty"`
	//  -- (bool) Disable ExternalIP mitigation (CVE-2020-8554)
	//  @default -- `false`
	//
	// Default value in yaml: false
	DisableExternalIpmitigation *bool `json:"disableExternalIPMitigation,omitempty" yaml:"disableExternalIPMitigation,omitempty"`
	//  -- (bool) Attach endpoint programs using tcx instead of legacy tc hooks on
	//  supported kernels.
	//  @default -- `true`
	//
	// Default value in yaml: true
	EnableTcx *bool `json:"enableTCX,omitempty" yaml:"enableTCX,omitempty"`
	//  -- (string) Mode for Pod devices for the core datapath (veth, netkit, netkit-l2, lb-only)
	//  @default -- `veth`
	//
	// Default value in yaml: veth
	DatapathMode *string `json:"datapathMode,omitempty" yaml:"datapathMode,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Bpf) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Cni_Resources_Requests struct {
	// Default value in yaml: 100m
	Cpu *string `json:"cpu,omitempty" yaml:"cpu,omitempty"`
	// Default value in yaml: 10Mi
	Memory *string `json:"memory,omitempty" yaml:"memory,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Cni_Resources_Requests) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Specifies the resources for the cni initContainer
type Cilium1163Values_Cni_Resources struct {
	Requests *Cilium1163Values_Cni_Resources_Requests `json:"requests,omitempty" yaml:"requests,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Cni_Resources) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Cni struct {
	//  -- Install the CNI configuration and binary files into the filesystem.
	//
	// Default value in yaml: true
	Install *bool `json:"install,omitempty" yaml:"install,omitempty"`
	//  -- Remove the CNI configuration and binary files on agent shutdown. Enable this
	//  if you're removing Cilium from the cluster. Disable this to prevent the CNI
	//  configuration file from being removed during agent upgrade, which can cause
	//  nodes to go unmanageable.
	//
	// Default value in yaml: false
	Uninstall *bool `json:"uninstall,omitempty" yaml:"uninstall,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- Configure chaining on top of other CNI plugins. Possible values:
	//   - none
	//   - aws-cni
	//   - flannel
	//   - generic-veth
	//   - portmap
	//
	// Default value in yaml: ~
	ChainingMode *string `json:"chainingMode,omitempty" yaml:"chainingMode,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- A CNI network name in to which the Cilium plugin should be added as a chained plugin.
	//  This will cause the agent to watch for a CNI network with this network name. When it is
	//  found, this will be used as the basis for Cilium's CNI configuration file. If this is
	//  set, it assumes a chaining mode of generic-veth. As a special case, a chaining mode
	//  of aws-cni implies a chainingTarget of aws-cni.
	//
	// Default value in yaml: ~
	ChainingTarget *string `json:"chainingTarget,omitempty" yaml:"chainingTarget,omitempty"`
	//  -- Make Cilium take ownership over the `/etc/cni/net.d` directory on the
	//  node, renaming all non-Cilium CNI configurations to `*.cilium_bak`.
	//  This ensures no Pods can be scheduled using other CNI plugins during Cilium
	//  agent downtime.
	//
	// Default value in yaml: true
	Exclusive *bool `json:"exclusive,omitempty" yaml:"exclusive,omitempty"`
	//  -- Configure the log file for CNI logging with retention policy of 7 days.
	//  Disable CNI file logging by setting this field to empty explicitly.
	//
	// Default value in yaml: /var/run/cilium/cilium-cni.log
	LogFile *string `json:"logFile,omitempty" yaml:"logFile,omitempty"`
	//  -- Skip writing of the CNI configuration. This can be used if
	//  writing of the CNI configuration is performed by external automation.
	//
	// Default value in yaml: false
	CustomConf *bool `json:"customConf,omitempty" yaml:"customConf,omitempty"`
	//  -- Configure the path to the CNI configuration directory on the host.
	//
	// Default value in yaml: /etc/cni/net.d
	ConfPath *string `json:"confPath,omitempty" yaml:"confPath,omitempty"`
	//  -- Configure the path to the CNI binary directory on the host.
	//  -- Specify the path to a CNI config to read from on agent start.
	//  This can be useful if you want to manage your CNI
	//  configuration outside of a Kubernetes environment. This parameter is
	//  mutually exclusive with the 'cni.configMap' parameter. The agent will
	//  write this to 05-cilium.conflist on startup.
	//  readCniConf: /host/etc/cni/net.d/05-sample.conflist.input
	//
	// Default value in yaml: /opt/cni/bin
	BinPath *string `json:"binPath,omitempty" yaml:"binPath,omitempty"`
	//  -- When defined, configMap will mount the provided value as ConfigMap and
	//  interpret the cniConf variable as CNI configuration file and write it
	//  when the agent starts up
	//  configMap: cni-configuration
	//
	//  -- Configure the key in the CNI ConfigMap to read the contents of
	//  the CNI configuration from.
	//
	// Default value in yaml: cni-config
	ConfigMapKey *string `json:"configMapKey,omitempty" yaml:"configMapKey,omitempty"`
	//  -- Configure the path to where to mount the ConfigMap inside the agent pod.
	//
	// Default value in yaml: /tmp/cni-configuration
	ConfFileMountPath *string `json:"confFileMountPath,omitempty" yaml:"confFileMountPath,omitempty"`
	//  -- Configure the path to where the CNI configuration directory is mounted
	//  inside the agent pod.
	//
	// Default value in yaml: /host/etc/cni/net.d
	HostConfDirMountPath *string `json:"hostConfDirMountPath,omitempty" yaml:"hostConfDirMountPath,omitempty"`
	//  -- Specifies the resources for the cni initContainer
	Resources *Cilium1163Values_Cni_Resources `json:"resources,omitempty" yaml:"resources,omitempty"`
	//  -- Enable route MTU for pod netns when CNI chaining is used
	//
	// Default value in yaml: false
	EnableRouteMtuforCnichaining *bool `json:"enableRouteMTUForCNIChaining,omitempty" yaml:"enableRouteMTUForCNIChaining,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Cni) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Tail call hooks for custom eBPF programs.
type Cilium1163Values_CustomCalls struct {
	//  -- Enable tail call hooks for custom eBPF programs.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_CustomCalls) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Specify which network interfaces can run the eBPF datapath. This means
//  that a packet sent from a pod to a destination outside the cluster will be
//  masqueraded (to an output device IPv4 address), if the output device runs the
//  program. When not specified, probing will automatically detect devices that have
//  a non-local route. This should be used only when autodetection is not suitable.
//  devices: ""
type Cilium1163Values_Daemon struct {
	//  -- Configure where Cilium runtime state should be stored.
	//
	// Default value in yaml: /var/run/cilium
	RunPath *string `json:"runPath,omitempty" yaml:"runPath,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- Configure a custom list of possible configuration override sources
	//  The default is "config-map:cilium-config,cilium-node-config". For supported
	//  values, see the help text for the build-config subcommand.
	//  Note that this value should be a comma-separated string.
	//
	// Default value in yaml: ~
	ConfigSources *string `json:"configSources,omitempty" yaml:"configSources,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- allowedConfigOverrides is a list of config-map keys that can be overridden.
	//  That is to say, if this value is set, config sources (excepting the first one) can
	//  only override keys in this list.
	//
	//  This takes precedence over blockedConfigOverrides.
	//
	//  By default, all keys may be overridden. To disable overrides, set this to "none" or
	//  change the configSources variable.
	//
	// Default value in yaml: ~
	AllowedConfigOverrides *string `json:"allowedConfigOverrides,omitempty" yaml:"allowedConfigOverrides,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- blockedConfigOverrides is a list of config-map keys that may not be overridden.
	//  In other words, if any of these keys appear in a configuration source excepting the
	//  first one, they will be ignored
	//
	//  This is ignored if allowedConfigOverrides is set.
	//
	//  By default, all keys may be overridden.
	//
	// Default value in yaml: ~
	BlockedConfigOverrides *string `json:"blockedConfigOverrides,omitempty" yaml:"blockedConfigOverrides,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Daemon) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- List of rate limit options to be used for the CiliumEndpointSlice controller.
//  Each object in the list must have the following fields:
//  nodes: Count of nodes at which to apply the rate limit.
//  limit: The sustained request rate in requests per second. The maximum rate that can be configured is 50.
//  burst: The burst request rate in requests per second. The maximum burst that can be configured is 100.
type Cilium1163Values_CiliumEndpointSlice_RateLimitsItem struct {
	// Default value in yaml: 0
	Nodes *int64 `json:"nodes,omitempty" yaml:"nodes,omitempty"`
	// Default value in yaml: 10
	Limit *int64 `json:"limit,omitempty" yaml:"limit,omitempty"`
	// Default value in yaml: 20
	Burst *int64 `json:"burst,omitempty" yaml:"burst,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_CiliumEndpointSlice_RateLimitsItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_CiliumEndpointSlice struct {
	//  -- Enable Cilium EndpointSlice feature.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- List of rate limit options to be used for the CiliumEndpointSlice controller.
	//  Each object in the list must have the following fields:
	//  nodes: Count of nodes at which to apply the rate limit.
	//  limit: The sustained request rate in requests per second. The maximum rate that can be configured is 50.
	//  burst: The burst request rate in requests per second. The maximum burst that can be configured is 100.
	RateLimits *[]Cilium1163Values_CiliumEndpointSlice_RateLimitsItem `json:"rateLimits,omitempty" yaml:"rateLimits,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_CiliumEndpointSlice) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- SecretsNamespace is the namespace in which envoy SDS will retrieve secrets from.
type Cilium1163Values_EnvoyConfig_SecretsNamespace struct {
	//  -- Create secrets namespace for CiliumEnvoyConfig CRDs.
	//
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	//  -- The name of the secret namespace to which Cilium agents are given read access.
	//
	// Default value in yaml: cilium-secrets
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_EnvoyConfig_SecretsNamespace) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_EnvoyConfig struct {
	//  -- Enable CiliumEnvoyConfig CRD
	//  CiliumEnvoyConfig CRD can also be implicitly enabled by other options.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- SecretsNamespace is the namespace in which envoy SDS will retrieve secrets from.
	SecretsNamespace *Cilium1163Values_EnvoyConfig_SecretsNamespace `json:"secretsNamespace,omitempty" yaml:"secretsNamespace,omitempty"`
	//  -- Interval in which an attempt is made to reconcile failed EnvoyConfigs. If the duration is zero, the retry is deactivated.
	//
	// Default value in yaml: 15s
	RetryInterval *string `json:"retryInterval,omitempty" yaml:"retryInterval,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_EnvoyConfig) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- SecretsNamespace is the namespace in which envoy SDS will retrieve TLS secrets from.
type Cilium1163Values_IngressController_SecretsNamespace struct {
	//  -- Create secrets namespace for Ingress.
	//
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	//  -- Name of Ingress secret namespace.
	//
	// Default value in yaml: cilium-secrets
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
	//  -- Enable secret sync, which will make sure all TLS secrets used by Ingress are synced to secretsNamespace.name.
	//  If disabled, TLS secrets must be maintained externally.
	//
	// Default value in yaml: true
	Sync *bool `json:"sync,omitempty" yaml:"sync,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_IngressController_SecretsNamespace) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Load-balancer service in shared mode.
//  This is a single load-balancer service for all Ingress resources.
type Cilium1163Values_IngressController_Service struct {
	//  -- Service name
	//
	// Default value in yaml: cilium-ingress
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
	//  -- Labels to be added for the shared LB service
	Labels *map[string]any `json:"labels,omitempty" yaml:"labels,omitempty"`
	//  -- Annotations to be added for the shared LB service
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- Service type for the shared LB service
	//
	// Default value in yaml: LoadBalancer
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`
	//  @schema
	//  type: [null, integer]
	//  @schema
	//  -- Configure a specific nodePort for insecure HTTP traffic on the shared LB service
	//
	// Default value in yaml: ~
	InsecureNodePort *string `json:"insecureNodePort,omitempty" yaml:"insecureNodePort,omitempty"`
	//  @schema
	//  type: [null, integer]
	//  @schema
	//  -- Configure a specific nodePort for secure HTTPS traffic on the shared LB service
	//
	// Default value in yaml: ~
	SecureNodePort *string `json:"secureNodePort,omitempty" yaml:"secureNodePort,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- Configure a specific loadBalancerClass on the shared LB service (requires Kubernetes 1.24+)
	//
	// Default value in yaml: ~
	LoadBalancerClass *string `json:"loadBalancerClass,omitempty" yaml:"loadBalancerClass,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- Configure a specific loadBalancerIP on the shared LB service
	//
	// Default value in yaml: ~
	LoadBalancerIp *string `json:"loadBalancerIP,omitempty" yaml:"loadBalancerIP,omitempty"`
	//  @schema
	//  type: [null, boolean]
	//  @schema
	//  -- Configure if node port allocation is required for LB service
	//  ref: https://kubernetes.io/docs/concepts/services-networking/service/#load-balancer-nodeport-allocation
	//
	// Default value in yaml: ~
	AllocateLoadBalancerNodePorts *string `json:"allocateLoadBalancerNodePorts,omitempty" yaml:"allocateLoadBalancerNodePorts,omitempty"`
	//  -- Control how traffic from external sources is routed to the LoadBalancer Kubernetes Service for Cilium Ingress in shared mode.
	//  Valid values are "Cluster" and "Local".
	//  ref: https://kubernetes.io/docs/reference/networking/virtual-ips/#external-traffic-policy
	//
	// Default value in yaml: Cluster
	ExternalTrafficPolicy *string `json:"externalTrafficPolicy,omitempty" yaml:"externalTrafficPolicy,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_IngressController_Service) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Specify the nodes where the Ingress listeners should be exposed
type Cilium1163Values_IngressController_HostNetwork_Nodes struct {
	//  -- Specify the labels of the nodes where the Ingress listeners should be exposed
	//
	//  matchLabels:
	//    kubernetes.io/os: linux
	//    kubernetes.io/hostname: kind-worker
	MatchLabels *map[string]any `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_IngressController_HostNetwork_Nodes) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Host Network related configuration
type Cilium1163Values_IngressController_HostNetwork struct {
	//  -- Configure whether the Envoy listeners should be exposed on the host network.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Configure a specific port on the host network that gets used for the shared listener.
	//
	// Default value in yaml: 8080
	SharedListenerPort *int64 `json:"sharedListenerPort,omitempty" yaml:"sharedListenerPort,omitempty"`
	//  Specify the nodes where the Ingress listeners should be exposed
	Nodes *Cilium1163Values_IngressController_HostNetwork_Nodes `json:"nodes,omitempty" yaml:"nodes,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_IngressController_HostNetwork) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_IngressController struct {
	//  -- Enable cilium ingress controller
	//  This will automatically set enable-envoy-config as well.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Set cilium ingress controller to be the default ingress controller
	//  This will let cilium ingress controller route entries without ingress class set
	//
	// Default value in yaml: false
	Default *bool `json:"default,omitempty" yaml:"default,omitempty"`
	//  -- Default ingress load balancer mode
	//  Supported values: shared, dedicated
	//  For granular control, use the following annotations on the ingress resource:
	//  "ingress.cilium.io/loadbalancer-mode: dedicated" (or "shared").
	//
	// Default value in yaml: dedicated
	LoadbalancerMode *string `json:"loadbalancerMode,omitempty" yaml:"loadbalancerMode,omitempty"`
	//  -- Enforce https for host having matching TLS host in Ingress.
	//  Incoming traffic to http listener will return 308 http error code with respective location in header.
	//
	// Default value in yaml: true
	EnforceHttps *bool `json:"enforceHttps,omitempty" yaml:"enforceHttps,omitempty"`
	//  -- Enable proxy protocol for all Ingress listeners. Note that _only_ Proxy protocol traffic will be accepted once this is enabled.
	//
	// Default value in yaml: false
	EnableProxyProtocol *bool `json:"enableProxyProtocol,omitempty" yaml:"enableProxyProtocol,omitempty"`
	//  -- IngressLBAnnotations are the annotation and label prefixes, which are used to filter annotations and/or labels to propagate from Ingress to the Load Balancer service
	//
	// Default value in yaml:
	// - lbipam.cilium.io
	// - nodeipam.cilium.io
	// - service.beta.kubernetes.io
	// - service.kubernetes.io
	// - cloud.google.com
	IngressLbannotationPrefixes *[]string `json:"ingressLBAnnotationPrefixes,omitempty" yaml:"ingressLBAnnotationPrefixes,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- Default secret namespace for ingresses without .spec.tls[].secretName set.
	DefaultSecretNamespace *string `json:"defaultSecretNamespace,omitempty" yaml:"defaultSecretNamespace,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- Default secret name for ingresses without .spec.tls[].secretName set.
	DefaultSecretName *string `json:"defaultSecretName,omitempty" yaml:"defaultSecretName,omitempty"`
	//  -- SecretsNamespace is the namespace in which envoy SDS will retrieve TLS secrets from.
	SecretsNamespace *Cilium1163Values_IngressController_SecretsNamespace `json:"secretsNamespace,omitempty" yaml:"secretsNamespace,omitempty"`
	//  -- Load-balancer service in shared mode.
	//  This is a single load-balancer service for all Ingress resources.
	Service *Cilium1163Values_IngressController_Service `json:"service,omitempty" yaml:"service,omitempty"`
	//  Host Network related configuration
	HostNetwork *Cilium1163Values_IngressController_HostNetwork `json:"hostNetwork,omitempty" yaml:"hostNetwork,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_IngressController) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_GatewayApi_GatewayClass struct {
	//  -- Enable creation of GatewayClass resource
	//  The default value is 'auto' which decides according to presence of gateway.networking.k8s.io/v1/GatewayClass in the cluster.
	//  Other possible values are 'true' and 'false', which will either always or never create the GatewayClass, respectively.
	//
	// Default value in yaml: auto
	Create *string `json:"create,omitempty" yaml:"create,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_GatewayApi_GatewayClass) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- SecretsNamespace is the namespace in which envoy SDS will retrieve TLS secrets from.
type Cilium1163Values_GatewayApi_SecretsNamespace struct {
	//  -- Create secrets namespace for Gateway API.
	//
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	//  -- Name of Gateway API secret namespace.
	//
	// Default value in yaml: cilium-secrets
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
	//  -- Enable secret sync, which will make sure all TLS secrets used by Ingress are synced to secretsNamespace.name.
	//  If disabled, TLS secrets must be maintained externally.
	//
	// Default value in yaml: true
	Sync *bool `json:"sync,omitempty" yaml:"sync,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_GatewayApi_SecretsNamespace) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Specify the nodes where the Ingress listeners should be exposed
type Cilium1163Values_GatewayApi_HostNetwork_Nodes struct {
	//  -- Specify the labels of the nodes where the Ingress listeners should be exposed
	//
	//  matchLabels:
	//    kubernetes.io/os: linux
	//    kubernetes.io/hostname: kind-worker
	MatchLabels *map[string]any `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_GatewayApi_HostNetwork_Nodes) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Host Network related configuration
type Cilium1163Values_GatewayApi_HostNetwork struct {
	//  -- Configure whether the Envoy listeners should be exposed on the host network.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  Specify the nodes where the Ingress listeners should be exposed
	Nodes *Cilium1163Values_GatewayApi_HostNetwork_Nodes `json:"nodes,omitempty" yaml:"nodes,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_GatewayApi_HostNetwork) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_GatewayApi struct {
	//  -- Enable support for Gateway API in cilium
	//  This will automatically set enable-envoy-config as well.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Enable proxy protocol for all GatewayAPI listeners. Note that _only_ Proxy protocol traffic will be accepted once this is enabled.
	//
	// Default value in yaml: false
	EnableProxyProtocol *bool `json:"enableProxyProtocol,omitempty" yaml:"enableProxyProtocol,omitempty"`
	//  -- Enable Backend Protocol selection support (GEP-1911) for Gateway API via appProtocol.
	//
	// Default value in yaml: false
	EnableAppProtocol *bool `json:"enableAppProtocol,omitempty" yaml:"enableAppProtocol,omitempty"`
	//  -- Enable ALPN for all listeners configured with Gateway API. ALPN will attempt HTTP/2, then HTTP 1.1.
	//  Note that this will also enable `appProtocol` support, and services that wish to use HTTP/2 will need to indicate that via their `appProtocol`.
	//
	// Default value in yaml: false
	EnableAlpn *bool `json:"enableAlpn,omitempty" yaml:"enableAlpn,omitempty"`
	//  -- The number of additional GatewayAPI proxy hops from the right side of the HTTP header to trust when determining the origin client's IP address.
	//
	// Default value in yaml: 0
	XffNumTrustedHops *int64 `json:"xffNumTrustedHops,omitempty" yaml:"xffNumTrustedHops,omitempty"`
	//  -- Control how traffic from external sources is routed to the LoadBalancer Kubernetes Service for all Cilium GatewayAPI Gateway instances. Valid values are "Cluster" and "Local".
	//  Note that this value will be ignored when `hostNetwork.enabled == true`.
	//  ref: https://kubernetes.io/docs/reference/networking/virtual-ips/#external-traffic-policy
	//
	// Default value in yaml: Cluster
	ExternalTrafficPolicy *string                                   `json:"externalTrafficPolicy,omitempty" yaml:"externalTrafficPolicy,omitempty"`
	GatewayClass          *Cilium1163Values_GatewayApi_GatewayClass `json:"gatewayClass,omitempty" yaml:"gatewayClass,omitempty"`
	//  -- SecretsNamespace is the namespace in which envoy SDS will retrieve TLS secrets from.
	SecretsNamespace *Cilium1163Values_GatewayApi_SecretsNamespace `json:"secretsNamespace,omitempty" yaml:"secretsNamespace,omitempty"`
	//  Host Network related configuration
	HostNetwork *Cilium1163Values_GatewayApi_HostNetwork `json:"hostNetwork,omitempty" yaml:"hostNetwork,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_GatewayApi) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure the WireGuard Pod2Pod strict mode.
type Cilium1163Values_Encryption_StrictMode struct {
	//  -- Enable WireGuard Pod2Pod strict mode.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- CIDR for the WireGuard Pod2Pod strict mode.
	Cidr *string `json:"cidr,omitempty" yaml:"cidr,omitempty"`
	//  -- Allow dynamic lookup of remote node identities.
	//  This is required when tunneling is used or direct routing is used and the node CIDR and pod CIDR overlap.
	//
	// Default value in yaml: false
	AllowRemoteNodeIdentities *bool `json:"allowRemoteNodeIdentities,omitempty" yaml:"allowRemoteNodeIdentities,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Encryption_StrictMode) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Encryption_Ipsec struct {
	//  -- Name of the key file inside the Kubernetes secret configured via secretName.
	//
	// Default value in yaml: keys
	KeyFile *string `json:"keyFile,omitempty" yaml:"keyFile,omitempty"`
	//  -- Path to mount the secret inside the Cilium pod.
	//
	// Default value in yaml: /etc/ipsec
	MountPath *string `json:"mountPath,omitempty" yaml:"mountPath,omitempty"`
	//  -- Name of the Kubernetes secret containing the encryption keys.
	//
	// Default value in yaml: cilium-ipsec-keys
	SecretName *string `json:"secretName,omitempty" yaml:"secretName,omitempty"`
	//  -- The interface to use for encrypted traffic.
	Interface *string `json:"interface,omitempty" yaml:"interface,omitempty"`
	//  -- Enable the key watcher. If disabled, a restart of the agent will be
	//  necessary on key rotations.
	//
	// Default value in yaml: true
	KeyWatcher *bool `json:"keyWatcher,omitempty" yaml:"keyWatcher,omitempty"`
	//  -- Maximum duration of the IPsec key rotation. The previous key will be
	//  removed after that delay.
	//
	// Default value in yaml: 5m
	KeyRotationDuration *string `json:"keyRotationDuration,omitempty" yaml:"keyRotationDuration,omitempty"`
	//  -- Enable IPsec encrypted overlay
	//
	// Default value in yaml: false
	EncryptedOverlay *bool `json:"encryptedOverlay,omitempty" yaml:"encryptedOverlay,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Encryption_Ipsec) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Encryption_Wireguard struct {
	//  -- Enables the fallback to the user-space implementation (deprecated).
	//
	// Default value in yaml: false
	UserspaceFallback *bool `json:"userspaceFallback,omitempty" yaml:"userspaceFallback,omitempty"`
	//  -- Controls WireGuard PersistentKeepalive option. Set 0s to disable.
	//
	// Default value in yaml: 0s
	PersistentKeepalive *string `json:"persistentKeepalive,omitempty" yaml:"persistentKeepalive,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Encryption_Wireguard) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Encryption struct {
	//  -- Enable transparent network encryption.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Encryption method. Can be either ipsec or wireguard.
	//
	// Default value in yaml: ipsec
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`
	//  -- Enable encryption for pure node to node traffic.
	//  This option is only effective when encryption.type is set to "wireguard".
	//
	// Default value in yaml: false
	NodeEncryption *bool `json:"nodeEncryption,omitempty" yaml:"nodeEncryption,omitempty"`
	//  -- Configure the WireGuard Pod2Pod strict mode.
	StrictMode *Cilium1163Values_Encryption_StrictMode `json:"strictMode,omitempty" yaml:"strictMode,omitempty"`
	Ipsec      *Cilium1163Values_Encryption_Ipsec      `json:"ipsec,omitempty" yaml:"ipsec,omitempty"`
	Wireguard  *Cilium1163Values_Encryption_Wireguard  `json:"wireguard,omitempty" yaml:"wireguard,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Encryption) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_EndpointHealthChecking struct {
	//  -- Enable connectivity health checking between virtual endpoints.
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_EndpointHealthChecking) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_EndpointRoutes struct {
	//  @schema
	//  type: [boolean, string]
	//  @schema
	//  -- Enable use of per endpoint routes instead of routing via
	//  the cilium_host interface.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_EndpointRoutes) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_K8SNetworkPolicy struct {
	//  -- Enable support for K8s NetworkPolicy
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_K8SNetworkPolicy) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Eni struct {
	//  -- Enable Elastic Network Interface (ENI) integration.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Update ENI Adapter limits from the EC2 API
	//
	// Default value in yaml: true
	UpdateEc2AdapterLimitViaApi *bool `json:"updateEC2AdapterLimitViaAPI,omitempty" yaml:"updateEC2AdapterLimitViaAPI,omitempty"`
	//  -- Release IPs not used from the ENI
	//
	// Default value in yaml: false
	AwsReleaseExcessIps *bool `json:"awsReleaseExcessIPs,omitempty" yaml:"awsReleaseExcessIPs,omitempty"`
	//  -- Enable ENI prefix delegation
	//
	// Default value in yaml: false
	AwsEnablePrefixDelegation *bool `json:"awsEnablePrefixDelegation,omitempty" yaml:"awsEnablePrefixDelegation,omitempty"`
	//  -- EC2 API endpoint to use
	Ec2Apiendpoint *string `json:"ec2APIEndpoint,omitempty" yaml:"ec2APIEndpoint,omitempty"`
	//  -- Tags to apply to the newly created ENIs
	EniTags *map[string]any `json:"eniTags,omitempty" yaml:"eniTags,omitempty"`
	//  -- Interval for garbage collection of unattached ENIs. Set to "0s" to disable.
	//  @default -- `"5m"`
	GcInterval *string `json:"gcInterval,omitempty" yaml:"gcInterval,omitempty"`
	//  -- Additional tags attached to ENIs created by Cilium.
	//  Dangling ENIs with this tag will be garbage collected
	//  @default -- `{"io.cilium/cilium-managed":"true,"io.cilium/cluster-name":"<auto-detected>"}`
	GcTags *map[string]any `json:"gcTags,omitempty" yaml:"gcTags,omitempty"`
	//  -- If using IAM role for Service Accounts will not try to
	//  inject identity values from cilium-aws kubernetes secret.
	//  Adds annotation to service account if managed by Helm.
	//  See https://github.com/aws/amazon-eks-pod-identity-webhook
	IamRole *string `json:"iamRole,omitempty" yaml:"iamRole,omitempty"`
	//  -- Filter via subnet IDs which will dictate which subnets are going to be used to create new ENIs
	//  Important note: This requires that each instance has an ENI with a matching subnet attached
	//  when Cilium is deployed. If you only want to control subnets for ENIs attached by Cilium,
	//  use the CNI configuration file settings (cni.customConf) instead.
	SubnetIdsFilter *[]any `json:"subnetIDsFilter,omitempty" yaml:"subnetIDsFilter,omitempty"`
	//  -- Filter via tags (k=v) which will dictate which subnets are going to be used to create new ENIs
	//  Important note: This requires that each instance has an ENI with a matching subnet attached
	//  when Cilium is deployed. If you only want to control subnets for ENIs attached by Cilium,
	//  use the CNI configuration file settings (cni.customConf) instead.
	SubnetTagsFilter *[]any `json:"subnetTagsFilter,omitempty" yaml:"subnetTagsFilter,omitempty"`
	//  -- Filter via AWS EC2 Instance tags (k=v) which will dictate which AWS EC2 Instances
	//  are going to be used to create new ENIs
	InstanceTagsFilter *[]any `json:"instanceTagsFilter,omitempty" yaml:"instanceTagsFilter,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Eni) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_ExternalIps struct {
	//  -- Enable ExternalIPs service support.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_ExternalIps) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  fragmentTracking enables IPv4 fragment tracking support in the datapath.
//  fragmentTracking: true
type Cilium1163Values_Gke struct {
	//  -- Enable Google Kubernetes Engine integration
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Gke) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure the host firewall.
type Cilium1163Values_HostFirewall struct {
	//  -- Enables the enforcement of host policies in the eBPF datapath.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_HostFirewall) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_HostPort struct {
	//  -- Enable hostPort service support.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_HostPort) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure socket LB
type Cilium1163Values_SocketLb struct {
	//  -- Enable socket LB
	//  -- Disable socket lb for non-root ns. This is used to enable Istio routing rules.
	//  hostNamespaceOnly: false
	//  -- Enable terminating pod connections to deleted service backends.
	//  terminatePodConnections: true
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_SocketLb) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Certgen_Image struct {
	//  @schema
	//  type: [null, string]
	//  @schema
	//
	// Default value in yaml: ~
	Override *string `json:"override,omitempty" yaml:"override,omitempty"`
	// Default value in yaml: quay.io/cilium/certgen
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	// Default value in yaml: v0.2.0
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	// Default value in yaml: sha256:169d93fd8f2f9009db3b9d5ccd37c2b753d0989e1e7cd8fe79f9160c459eef4f
	Digest *string `json:"digest,omitempty" yaml:"digest,omitempty"`
	// Default value in yaml: true
	UseDigest *bool `json:"useDigest,omitempty" yaml:"useDigest,omitempty"`
	// Default value in yaml: IfNotPresent
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Certgen_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Annotations to be added to the hubble-certgen initial Job and CronJob
type Cilium1163Values_Certgen_Annotations struct {
	Job     *map[string]any `json:"job,omitempty" yaml:"job,omitempty"`
	CronJob *map[string]any `json:"cronJob,omitempty" yaml:"cronJob,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Certgen_Annotations) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure certificate generation for Hubble integration.
//  If hubble.tls.auto.method=cronJob, these values are used
//  for the Kubernetes CronJob which will be scheduled regularly to
//  (re)generate any certificates not provided manually.
type Cilium1163Values_Certgen struct {
	Image *Cilium1163Values_Certgen_Image `json:"image,omitempty" yaml:"image,omitempty"`
	//  -- Seconds after which the completed job pod will be deleted
	//
	// Default value in yaml: 1800
	TtlSecondsAfterFinished *int64 `json:"ttlSecondsAfterFinished,omitempty" yaml:"ttlSecondsAfterFinished,omitempty"`
	//  -- Labels to be added to hubble-certgen pods
	PodLabels *map[string]any `json:"podLabels,omitempty" yaml:"podLabels,omitempty"`
	//  -- Annotations to be added to the hubble-certgen initial Job and CronJob
	Annotations *Cilium1163Values_Certgen_Annotations `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- Node tolerations for pod assignment on nodes with taints
	//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
	Tolerations *[]any `json:"tolerations,omitempty" yaml:"tolerations,omitempty"`
	//  -- Additional certgen volumes.
	ExtraVolumes *[]any `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty"`
	//  -- Additional certgen volumeMounts.
	ExtraVolumeMounts *[]any `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty"`
	//  -- Affinity for certgen
	Affinity *map[string]any `json:"affinity,omitempty" yaml:"affinity,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Certgen) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure mTLS for the Hubble metrics server.
type Cilium1163Values_Hubble_Metrics_Tls_Server_Mtls struct {
	//  When set to true enforces mutual TLS between Hubble Metrics server and its clients.
	//  False allow non-mutual TLS connections.
	//  This option has no effect when TLS is disabled.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: false
	UseSecret *bool `json:"useSecret,omitempty" yaml:"useSecret,omitempty"`
	//  -- Name of the ConfigMap containing the CA to validate client certificates against.
	//  If mTLS is enabled and this is unspecified, it will default to the
	//  same CA used for Hubble metrics server certificates.
	//
	// Default value in yaml: ~
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
	//  -- Entry of the ConfigMap containing the CA.
	//
	// Default value in yaml: ca.crt
	Key *string `json:"key,omitempty" yaml:"key,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Metrics_Tls_Server_Mtls) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Configure hubble metrics server TLS.
type Cilium1163Values_Hubble_Metrics_Tls_Server struct {
	//  -- Name of the Secret containing the certificate and key for the Hubble metrics server.
	//  If specified, cert and key are ignored.
	ExistingSecret *string `json:"existingSecret,omitempty" yaml:"existingSecret,omitempty"`
	//  -- base64 encoded PEM values for the Hubble metrics server certificate (deprecated).
	//  Use existingSecret instead.
	Cert *string `json:"cert,omitempty" yaml:"cert,omitempty"`
	//  -- base64 encoded PEM values for the Hubble metrics server key (deprecated).
	//  Use existingSecret instead.
	Key *string `json:"key,omitempty" yaml:"key,omitempty"`
	//  -- Extra DNS names added to certificate when it's auto generated
	ExtraDnsNames *[]any `json:"extraDnsNames,omitempty" yaml:"extraDnsNames,omitempty"`
	//  -- Extra IP addresses added to certificate when it's auto generated
	ExtraIpAddresses *[]any `json:"extraIpAddresses,omitempty" yaml:"extraIpAddresses,omitempty"`
	//  -- Configure mTLS for the Hubble metrics server.
	Mtls *Cilium1163Values_Hubble_Metrics_Tls_Server_Mtls `json:"mtls,omitempty" yaml:"mtls,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Metrics_Tls_Server) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Metrics_Tls struct {
	//  Enable hubble metrics server TLS.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  Configure hubble metrics server TLS.
	Server *Cilium1163Values_Hubble_Metrics_Tls_Server `json:"server,omitempty" yaml:"server,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Metrics_Tls) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Relabeling configs for the ServiceMonitor hubble
type Cilium1163Values_Hubble_Metrics_ServiceMonitor_RelabelingsItem struct {
	// Default value in yaml:
	// - __meta_kubernetes_pod_node_name
	SourceLabels *[]string `json:"sourceLabels,omitempty" yaml:"sourceLabels,omitempty"`
	// Default value in yaml: node
	TargetLabel *string `json:"targetLabel,omitempty" yaml:"targetLabel,omitempty"`
	// Default value in yaml: ${1}
	Replacement *string `json:"replacement,omitempty" yaml:"replacement,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Metrics_ServiceMonitor_RelabelingsItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Metrics_ServiceMonitor struct {
	//  -- Create ServiceMonitor resources for Prometheus Operator.
	//  This requires the prometheus CRDs to be available.
	//  ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/example/prometheus-operator-crd/monitoring.coreos.com_servicemonitors.yaml)
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Labels to add to ServiceMonitor hubble
	Labels *map[string]any `json:"labels,omitempty" yaml:"labels,omitempty"`
	//  -- Annotations to add to ServiceMonitor hubble
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- jobLabel to add for ServiceMonitor hubble
	JobLabel *string `json:"jobLabel,omitempty" yaml:"jobLabel,omitempty"`
	//  -- Interval for scrape metrics.
	//
	// Default value in yaml: 10s
	Interval *string `json:"interval,omitempty" yaml:"interval,omitempty"`
	//  -- Relabeling configs for the ServiceMonitor hubble
	Relabelings *[]Cilium1163Values_Hubble_Metrics_ServiceMonitor_RelabelingsItem `json:"relabelings,omitempty" yaml:"relabelings,omitempty"`
	//  @schema
	//  type: [null, array]
	//  @schema
	//  -- Metrics relabeling configs for the ServiceMonitor hubble
	//
	// Default value in yaml: ~
	MetricRelabelings *string `json:"metricRelabelings,omitempty" yaml:"metricRelabelings,omitempty"`
	//  Configure TLS for the ServiceMonitor.
	//  Note, when using TLS you will either need to specify
	//  tlsConfig.insecureSkipVerify or specify a CA to use.
	TlsConfig *map[string]any `json:"tlsConfig,omitempty" yaml:"tlsConfig,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Metrics_ServiceMonitor) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Grafana dashboards for hubble
//  grafana can import dashboards based on the label and value
//  ref: https://github.com/grafana/helm-charts/tree/main/charts/grafana#sidecar-for-dashboards
type Cilium1163Values_Hubble_Metrics_Dashboards struct {
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: grafana_dashboard
	Label *string `json:"label,omitempty" yaml:"label,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//
	// Default value in yaml: ~
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty"`
	// Default value in yaml: 1
	LabelValue  *string         `json:"labelValue,omitempty" yaml:"labelValue,omitempty"`
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Metrics_Dashboards) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Number of recent flows for Hubble to cache. Defaults to 4095.
//  Possible values are:
//    1, 3, 7, 15, 31, 63, 127, 255, 511, 1023,
//    2047, 4095, 8191, 16383, 32767, 65535
//  eventBufferCapacity: "4095"
//
//  -- Hubble metrics configuration.
//  See https://docs.cilium.io/en/stable/observability/metrics/#hubble-metrics
//  for more comprehensive documentation about Hubble metrics.
type Cilium1163Values_Hubble_Metrics struct {
	//  @schema
	//  type: [null, array]
	//  @schema
	//  -- Configures the list of metrics to collect. If empty or null, metrics
	//  are disabled.
	//  Example:
	//
	//    enabled:
	//    - dns:query;ignoreAAAA
	//    - drop
	//    - tcp
	//    - flow
	//    - icmp
	//    - http
	//
	//  You can specify the list of metrics from the helm CLI:
	//
	//    --set hubble.metrics.enabled="{dns:query;ignoreAAAA,drop,tcp,flow,icmp,http}"
	//
	//
	// Default value in yaml: ~
	Enabled *string `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Enables exporting hubble metrics in OpenMetrics format.
	//
	// Default value in yaml: false
	EnableOpenMetrics *bool `json:"enableOpenMetrics,omitempty" yaml:"enableOpenMetrics,omitempty"`
	//  -- Configure the port the hubble metric server listens on.
	//
	// Default value in yaml: 9965
	Port *int64                               `json:"port,omitempty" yaml:"port,omitempty"`
	Tls  *Cilium1163Values_Hubble_Metrics_Tls `json:"tls,omitempty" yaml:"tls,omitempty"`
	//  -- Annotations to be added to hubble-metrics service.
	ServiceAnnotations *map[string]any                                 `json:"serviceAnnotations,omitempty" yaml:"serviceAnnotations,omitempty"`
	ServiceMonitor     *Cilium1163Values_Hubble_Metrics_ServiceMonitor `json:"serviceMonitor,omitempty" yaml:"serviceMonitor,omitempty"`
	//  -- Grafana dashboards for hubble
	//  grafana can import dashboards based on the label and value
	//  ref: https://github.com/grafana/helm-charts/tree/main/charts/grafana#sidecar-for-dashboards
	Dashboards *Cilium1163Values_Hubble_Metrics_Dashboards `json:"dashboards,omitempty" yaml:"dashboards,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Metrics) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Redact_Http_Headers struct {
	//  -- List of HTTP headers to allow: headers not matching will be redacted. Note: `allow` and `deny` lists cannot be used both at the same time, only one can be present.
	//  Example:
	//    redact:
	//      enabled: true
	//      http:
	//        headers:
	//          allow:
	//            - traceparent
	//            - tracestate
	//            - Cache-Control
	//
	//  You can specify the options from the helm CLI:
	//    --set hubble.redact.enabled="true"
	//    --set hubble.redact.http.headers.allow="traceparent,tracestate,Cache-Control"
	Allow *[]any `json:"allow,omitempty" yaml:"allow,omitempty"`
	//  -- List of HTTP headers to deny: matching headers will be redacted. Note: `allow` and `deny` lists cannot be used both at the same time, only one can be present.
	//  Example:
	//    redact:
	//      enabled: true
	//      http:
	//        headers:
	//          deny:
	//            - Authorization
	//            - Proxy-Authorization
	//
	//  You can specify the options from the helm CLI:
	//    --set hubble.redact.enabled="true"
	//    --set hubble.redact.http.headers.deny="Authorization,Proxy-Authorization"
	Deny *[]any `json:"deny,omitempty" yaml:"deny,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Redact_Http_Headers) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Redact_Http struct {
	//  -- Enables redacting URL query (GET) parameters.
	//  Example:
	//
	//    redact:
	//      enabled: true
	//      http:
	//        urlQuery: true
	//
	//  You can specify the options from the helm CLI:
	//
	//    --set hubble.redact.enabled="true"
	//    --set hubble.redact.http.urlQuery="true"
	//
	// Default value in yaml: false
	UrlQuery *bool `json:"urlQuery,omitempty" yaml:"urlQuery,omitempty"`
	//  -- Enables redacting user info, e.g., password when basic auth is used.
	//  Example:
	//
	//    redact:
	//      enabled: true
	//      http:
	//        userInfo: true
	//
	//  You can specify the options from the helm CLI:
	//
	//    --set hubble.redact.enabled="true"
	//    --set hubble.redact.http.userInfo="true"
	//
	// Default value in yaml: true
	UserInfo *bool                                        `json:"userInfo,omitempty" yaml:"userInfo,omitempty"`
	Headers  *Cilium1163Values_Hubble_Redact_Http_Headers `json:"headers,omitempty" yaml:"headers,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Redact_Http) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Redact_Kafka struct {
	//  -- Enables redacting Kafka's API key.
	//  Example:
	//
	//    redact:
	//      enabled: true
	//      kafka:
	//        apiKey: true
	//
	//  You can specify the options from the helm CLI:
	//
	//    --set hubble.redact.enabled="true"
	//    --set hubble.redact.kafka.apiKey="true"
	//
	// Default value in yaml: false
	ApiKey *bool `json:"apiKey,omitempty" yaml:"apiKey,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Redact_Kafka) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Enables redacting sensitive information present in Layer 7 flows.
type Cilium1163Values_Hubble_Redact struct {
	// Default value in yaml: false
	Enabled *bool                                 `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	Http    *Cilium1163Values_Hubble_Redact_Http  `json:"http,omitempty" yaml:"http,omitempty"`
	Kafka   *Cilium1163Values_Hubble_Redact_Kafka `json:"kafka,omitempty" yaml:"kafka,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Redact) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_PeerService struct {
	//  -- Service Port for the Peer service.
	//  If not set, it is dynamically assigned to port 443 if TLS is enabled and to
	//  port 80 if not.
	//  servicePort: 80
	//  -- Target Port for the Peer service, must match the hubble.listenAddress'
	//  port.
	//
	// Default value in yaml: 4244
	TargetPort *int64 `json:"targetPort,omitempty" yaml:"targetPort,omitempty"`
	//  -- The cluster domain to use to query the Hubble Peer service. It should
	//  be the local cluster.
	//
	// Default value in yaml: cluster.local
	ClusterDomain *string `json:"clusterDomain,omitempty" yaml:"clusterDomain,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_PeerService) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure automatic TLS certificates generation.
type Cilium1163Values_Hubble_Tls_Auto struct {
	//  -- Auto-generate certificates.
	//  When set to true, automatically generate a CA and certificates to
	//  enable mTLS between Hubble server and Hubble Relay instances. If set to
	//  false, the certs for Hubble server need to be provided by setting
	//  appropriate values below.
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Set the method to auto-generate certificates. Supported values:
	//  - helm:         This method uses Helm to generate all certificates.
	//  - cronJob:      This method uses a Kubernetes CronJob the generate any
	//                  certificates not provided by the user at installation
	//                  time.
	//  - certmanager:  This method use cert-manager to generate & rotate certificates.
	//
	// Default value in yaml: helm
	Method *string `json:"method,omitempty" yaml:"method,omitempty"`
	//  -- Generated certificates validity duration in days.
	//
	// Default value in yaml: 1095
	CertValidityDuration *int64 `json:"certValidityDuration,omitempty" yaml:"certValidityDuration,omitempty"`
	//  -- Schedule for certificates regeneration (regardless of their expiration date).
	//  Only used if method is "cronJob". If nil, then no recurring job will be created.
	//  Instead, only the one-shot job is deployed to generate the certificates at
	//  installation time.
	//
	//  Defaults to midnight of the first day of every fourth month. For syntax, see
	//  https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#schedule-syntax
	//
	// Default value in yaml: 0 0 1 */4 *
	Schedule *string `json:"schedule,omitempty" yaml:"schedule,omitempty"`
	//  [Example]
	//  certManagerIssuerRef:
	//    group: cert-manager.io
	//    kind: ClusterIssuer
	//    name: ca-issuer
	//  -- certmanager issuer used when hubble.tls.auto.method=certmanager.
	CertManagerIssuerRef *map[string]any `json:"certManagerIssuerRef,omitempty" yaml:"certManagerIssuerRef,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Tls_Auto) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- The Hubble server certificate and private key
type Cilium1163Values_Hubble_Tls_Server struct {
	//  -- Name of the Secret containing the certificate and key for the Hubble server.
	//  If specified, cert and key are ignored.
	ExistingSecret *string `json:"existingSecret,omitempty" yaml:"existingSecret,omitempty"`
	//  -- base64 encoded PEM values for the Hubble server certificate (deprecated).
	//  Use existingSecret instead.
	Cert *string `json:"cert,omitempty" yaml:"cert,omitempty"`
	//  -- base64 encoded PEM values for the Hubble server key (deprecated).
	//  Use existingSecret instead.
	Key *string `json:"key,omitempty" yaml:"key,omitempty"`
	//  -- Extra DNS names added to certificate when it's auto generated
	ExtraDnsNames *[]any `json:"extraDnsNames,omitempty" yaml:"extraDnsNames,omitempty"`
	//  -- Extra IP addresses added to certificate when it's auto generated
	ExtraIpAddresses *[]any `json:"extraIpAddresses,omitempty" yaml:"extraIpAddresses,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Tls_Server) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- TLS configuration for Hubble
type Cilium1163Values_Hubble_Tls struct {
	//  -- Enable mutual TLS for listenAddress. Setting this value to false is
	//  highly discouraged as the Hubble API provides access to potentially
	//  sensitive network flow metadata and is exposed on the host network.
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Configure automatic TLS certificates generation.
	Auto *Cilium1163Values_Hubble_Tls_Auto `json:"auto,omitempty" yaml:"auto,omitempty"`
	//  -- The Hubble server certificate and private key
	Server *Cilium1163Values_Hubble_Tls_Server `json:"server,omitempty" yaml:"server,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Tls) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Hubble-relay container image.
type Cilium1163Values_Hubble_Relay_Image struct {
	//  @schema
	//  type: [null, string]
	//  @schema
	//
	// Default value in yaml: ~
	Override *string `json:"override,omitempty" yaml:"override,omitempty"`
	// Default value in yaml: quay.io/cilium/hubble-relay
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	// Default value in yaml: v1.16.3
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	//  hubble-relay-digest
	//
	// Default value in yaml: sha256:feb60efd767e0e7863a94689f4a8db56a0acc7c1d2b307dee66422e3dc25a089
	Digest *string `json:"digest,omitempty" yaml:"digest,omitempty"`
	// Default value in yaml: true
	UseDigest *bool `json:"useDigest,omitempty" yaml:"useDigest,omitempty"`
	// Default value in yaml: IfNotPresent
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Relay_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector_MatchLabels struct {
	// Default value in yaml: cilium
	K8SApp *string `json:"k8s-app,omitempty" yaml:"k8s-app,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector_MatchLabels) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Relay_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector struct {
	MatchLabels *Cilium1163Values_Hubble_Relay_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector_MatchLabels `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Relay_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem struct {
	// Default value in yaml: kubernetes.io/hostname
	TopologyKey   *string                                                                                                              `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty"`
	LabelSelector *Cilium1163Values_Hubble_Relay_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Relay_Affinity_PodAffinity struct {
	RequiredDuringSchedulingIgnoredDuringExecution *[]Cilium1163Values_Hubble_Relay_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_Affinity_PodAffinity) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Affinity for hubble-replay
type Cilium1163Values_Hubble_Relay_Affinity struct {
	PodAffinity *Cilium1163Values_Hubble_Relay_Affinity_PodAffinity `json:"podAffinity,omitempty" yaml:"podAffinity,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_Affinity) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Node labels for pod assignment
//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
type Cilium1163Values_Hubble_Relay_NodeSelector struct {
	// Default value in yaml: linux
	KubernetesIoos *string `json:"kubernetes.io/os,omitempty" yaml:"kubernetes.io/os,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_NodeSelector) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  PodDisruptionBudget settings
type Cilium1163Values_Hubble_Relay_PodDisruptionBudget struct {
	//  -- enable PodDisruptionBudget
	//  ref: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  @schema
	//  type: [null, integer, string]
	//  @schema
	//  -- Minimum number/percentage of pods that should remain scheduled.
	//  When it's set, maxUnavailable must be disabled by `maxUnavailable: null`
	//
	// Default value in yaml: null
	MinAvailable *string `json:"minAvailable,omitempty" yaml:"minAvailable,omitempty"`
	//  @schema
	//  type: [null, integer, string]
	//  @schema
	//  -- Maximum number/percentage of pods that may be made unavailable
	//
	// Default value in yaml: 1
	MaxUnavailable *int64 `json:"maxUnavailable,omitempty" yaml:"maxUnavailable,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_PodDisruptionBudget) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Relay_UpdateStrategy_RollingUpdate struct {
	//  @schema
	//  type: [integer, string]
	//  @schema
	//
	// Default value in yaml: 1
	MaxUnavailable *int64 `json:"maxUnavailable,omitempty" yaml:"maxUnavailable,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_UpdateStrategy_RollingUpdate) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- hubble-relay update strategy
type Cilium1163Values_Hubble_Relay_UpdateStrategy struct {
	// Default value in yaml: RollingUpdate
	Type          *string                                                     `json:"type,omitempty" yaml:"type,omitempty"`
	RollingUpdate *Cilium1163Values_Hubble_Relay_UpdateStrategy_RollingUpdate `json:"rollingUpdate,omitempty" yaml:"rollingUpdate,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_UpdateStrategy) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- hubble-relay pod security context
type Cilium1163Values_Hubble_Relay_PodSecurityContext struct {
	// Default value in yaml: 65532
	FsGroup *int64 `json:"fsGroup,omitempty" yaml:"fsGroup,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_PodSecurityContext) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Relay_SecurityContext_Capabilities struct {
	// Default value in yaml:
	// - ALL
	Drop *[]string `json:"drop,omitempty" yaml:"drop,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_SecurityContext_Capabilities) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- hubble-relay container security context
type Cilium1163Values_Hubble_Relay_SecurityContext struct {
	//  readOnlyRootFilesystem: true
	//
	// Default value in yaml: true
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty"`
	// Default value in yaml: 65532
	RunAsUser *int64 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty"`
	// Default value in yaml: 65532
	RunAsGroup   *int64                                                      `json:"runAsGroup,omitempty" yaml:"runAsGroup,omitempty"`
	Capabilities *Cilium1163Values_Hubble_Relay_SecurityContext_Capabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_SecurityContext) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- hubble-relay service configuration.
type Cilium1163Values_Hubble_Relay_Service struct {
	//  --- The type of service used for Hubble Relay access, either ClusterIP or NodePort.
	//
	// Default value in yaml: ClusterIP
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`
	//  --- The port to use when the service type is set to NodePort.
	//
	// Default value in yaml: 31234
	NodePort *int64 `json:"nodePort,omitempty" yaml:"nodePort,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_Service) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- The hubble-relay client certificate and private key.
//  This keypair is presented to Hubble server instances for mTLS
//  authentication and is required when hubble.tls.enabled is true.
//  These values need to be set manually if hubble.tls.auto.enabled is false.
type Cilium1163Values_Hubble_Relay_Tls_Client struct {
	//  -- Name of the Secret containing the certificate and key for the Hubble metrics server.
	//  If specified, cert and key are ignored.
	ExistingSecret *string `json:"existingSecret,omitempty" yaml:"existingSecret,omitempty"`
	//  -- base64 encoded PEM values for the Hubble relay client certificate (deprecated).
	//  Use existingSecret instead.
	Cert *string `json:"cert,omitempty" yaml:"cert,omitempty"`
	//  -- base64 encoded PEM values for the Hubble relay client key (deprecated).
	//  Use existingSecret instead.
	Key *string `json:"key,omitempty" yaml:"key,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_Tls_Client) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- The hubble-relay server certificate and private key
type Cilium1163Values_Hubble_Relay_Tls_Server struct {
	//  When set to true, enable TLS on for Hubble Relay server
	//  (ie: for clients connecting to the Hubble Relay API).
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  When set to true enforces mutual TLS between Hubble Relay server and its clients.
	//  False allow non-mutual TLS connections.
	//  This option has no effect when TLS is disabled.
	//
	// Default value in yaml: false
	Mtls *bool `json:"mtls,omitempty" yaml:"mtls,omitempty"`
	//  -- Name of the Secret containing the certificate and key for the Hubble relay server.
	//  If specified, cert and key are ignored.
	ExistingSecret *string `json:"existingSecret,omitempty" yaml:"existingSecret,omitempty"`
	//  -- base64 encoded PEM values for the Hubble relay server certificate (deprecated).
	//  Use existingSecret instead.
	Cert *string `json:"cert,omitempty" yaml:"cert,omitempty"`
	//  -- base64 encoded PEM values for the Hubble relay server key (deprecated).
	//  Use existingSecret instead.
	Key *string `json:"key,omitempty" yaml:"key,omitempty"`
	//  -- extra DNS names added to certificate when its auto gen
	ExtraDnsNames *[]any `json:"extraDnsNames,omitempty" yaml:"extraDnsNames,omitempty"`
	//  -- extra IP addresses added to certificate when its auto gen
	ExtraIpAddresses *[]any `json:"extraIpAddresses,omitempty" yaml:"extraIpAddresses,omitempty"`
	//  DNS name used by the backend to connect to the relay
	//  This is a simple workaround as the relay certificates are currently hardcoded to
	//  *.hubble-relay.cilium.io
	//  See https://github.com/cilium/cilium/pull/28709#discussion_r1371792546
	//  For GKE Dataplane V2 this should be set to relay.kube-system.svc.cluster.local
	//
	// Default value in yaml: ui.hubble-relay.cilium.io
	RelayName *string `json:"relayName,omitempty" yaml:"relayName,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_Tls_Server) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- TLS configuration for Hubble Relay
type Cilium1163Values_Hubble_Relay_Tls struct {
	//  -- The hubble-relay client certificate and private key.
	//  This keypair is presented to Hubble server instances for mTLS
	//  authentication and is required when hubble.tls.enabled is true.
	//  These values need to be set manually if hubble.tls.auto.enabled is false.
	Client *Cilium1163Values_Hubble_Relay_Tls_Client `json:"client,omitempty" yaml:"client,omitempty"`
	//  -- The hubble-relay server certificate and private key
	Server *Cilium1163Values_Hubble_Relay_Tls_Server `json:"server,omitempty" yaml:"server,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_Tls) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Relay_Prometheus_ServiceMonitor struct {
	//  -- Enable service monitors.
	//  This requires the prometheus CRDs to be available (see https://github.com/prometheus-operator/prometheus-operator/blob/main/example/prometheus-operator-crd/monitoring.coreos.com_servicemonitors.yaml)
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Labels to add to ServiceMonitor hubble-relay
	Labels *map[string]any `json:"labels,omitempty" yaml:"labels,omitempty"`
	//  -- Annotations to add to ServiceMonitor hubble-relay
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- Interval for scrape metrics.
	//
	// Default value in yaml: 10s
	Interval *string `json:"interval,omitempty" yaml:"interval,omitempty"`
	//  -- Specify the Kubernetes namespace where Prometheus expects to find
	//  service monitors configured.
	//  namespace: ""
	//  @schema
	//  type: [null, array]
	//  @schema
	//  -- Relabeling configs for the ServiceMonitor hubble-relay
	//
	// Default value in yaml: ~
	Relabelings *string `json:"relabelings,omitempty" yaml:"relabelings,omitempty"`
	//  @schema
	//  type: [null, array]
	//  @schema
	//  -- Metrics relabeling configs for the ServiceMonitor hubble-relay
	//
	// Default value in yaml: ~
	MetricRelabelings *string `json:"metricRelabelings,omitempty" yaml:"metricRelabelings,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_Prometheus_ServiceMonitor) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Enable prometheus metrics for hubble-relay on the configured port at
//  /metrics
type Cilium1163Values_Hubble_Relay_Prometheus struct {
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: 9966
	Port           *int64                                                   `json:"port,omitempty" yaml:"port,omitempty"`
	ServiceMonitor *Cilium1163Values_Hubble_Relay_Prometheus_ServiceMonitor `json:"serviceMonitor,omitempty" yaml:"serviceMonitor,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_Prometheus) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Relay_Gops struct {
	//  -- Enable gops for hubble-relay
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Configure gops listen port for hubble-relay
	//
	// Default value in yaml: 9893
	Port *int64 `json:"port,omitempty" yaml:"port,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_Gops) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Relay_Pprof struct {
	//  -- Enable pprof for hubble-relay
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Configure pprof listen address for hubble-relay
	//
	// Default value in yaml: localhost
	Address *string `json:"address,omitempty" yaml:"address,omitempty"`
	//  -- Configure pprof listen port for hubble-relay
	//
	// Default value in yaml: 6062
	Port *int64 `json:"port,omitempty" yaml:"port,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay_Pprof) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Relay struct {
	//  -- Enable Hubble Relay (requires hubble.enabled=true)
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Roll out Hubble Relay pods automatically when configmap is updated.
	//
	// Default value in yaml: false
	RollOutPods *bool `json:"rollOutPods,omitempty" yaml:"rollOutPods,omitempty"`
	//  -- Hubble-relay container image.
	Image *Cilium1163Values_Hubble_Relay_Image `json:"image,omitempty" yaml:"image,omitempty"`
	//  -- Specifies the resources for the hubble-relay pods
	Resources *map[string]any `json:"resources,omitempty" yaml:"resources,omitempty"`
	//  -- Number of replicas run for the hubble-relay deployment.
	//
	// Default value in yaml: 1
	Replicas *int64 `json:"replicas,omitempty" yaml:"replicas,omitempty"`
	//  -- Affinity for hubble-replay
	Affinity *Cilium1163Values_Hubble_Relay_Affinity `json:"affinity,omitempty" yaml:"affinity,omitempty"`
	//  -- Pod topology spread constraints for hubble-relay
	//    - maxSkew: 1
	//      topologyKey: topology.kubernetes.io/zone
	//      whenUnsatisfiable: DoNotSchedule
	TopologySpreadConstraints *[]any `json:"topologySpreadConstraints,omitempty" yaml:"topologySpreadConstraints,omitempty"`
	//  -- Node labels for pod assignment
	//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
	NodeSelector *Cilium1163Values_Hubble_Relay_NodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty"`
	//  -- Node tolerations for pod assignment on nodes with taints
	//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
	Tolerations *[]any `json:"tolerations,omitempty" yaml:"tolerations,omitempty"`
	//  -- Additional hubble-relay environment variables.
	ExtraEnv *[]any `json:"extraEnv,omitempty" yaml:"extraEnv,omitempty"`
	//  -- Annotations to be added to all top-level hubble-relay objects (resources under templates/hubble-relay)
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- Annotations to be added to hubble-relay pods
	PodAnnotations *map[string]any `json:"podAnnotations,omitempty" yaml:"podAnnotations,omitempty"`
	//  -- Labels to be added to hubble-relay pods
	PodLabels *map[string]any `json:"podLabels,omitempty" yaml:"podLabels,omitempty"`
	//  PodDisruptionBudget settings
	PodDisruptionBudget *Cilium1163Values_Hubble_Relay_PodDisruptionBudget `json:"podDisruptionBudget,omitempty" yaml:"podDisruptionBudget,omitempty"`
	//  -- The priority class to use for hubble-relay
	PriorityClassName *string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty"`
	//  -- Configure termination grace period for hubble relay Deployment.
	//
	// Default value in yaml: 1
	TerminationGracePeriodSeconds *int64 `json:"terminationGracePeriodSeconds,omitempty" yaml:"terminationGracePeriodSeconds,omitempty"`
	//  -- hubble-relay update strategy
	UpdateStrategy *Cilium1163Values_Hubble_Relay_UpdateStrategy `json:"updateStrategy,omitempty" yaml:"updateStrategy,omitempty"`
	//  -- Additional hubble-relay volumes.
	ExtraVolumes *[]any `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty"`
	//  -- Additional hubble-relay volumeMounts.
	ExtraVolumeMounts *[]any `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty"`
	//  -- hubble-relay pod security context
	PodSecurityContext *Cilium1163Values_Hubble_Relay_PodSecurityContext `json:"podSecurityContext,omitempty" yaml:"podSecurityContext,omitempty"`
	//  -- hubble-relay container security context
	SecurityContext *Cilium1163Values_Hubble_Relay_SecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`
	//  -- hubble-relay service configuration.
	Service *Cilium1163Values_Hubble_Relay_Service `json:"service,omitempty" yaml:"service,omitempty"`
	//  -- Host to listen to. Specify an empty string to bind to all the interfaces.
	ListenHost *string `json:"listenHost,omitempty" yaml:"listenHost,omitempty"`
	//  -- Port to listen to.
	//
	// Default value in yaml: 4245
	ListenPort *string `json:"listenPort,omitempty" yaml:"listenPort,omitempty"`
	//  -- TLS configuration for Hubble Relay
	Tls *Cilium1163Values_Hubble_Relay_Tls `json:"tls,omitempty" yaml:"tls,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- Dial timeout to connect to the local hubble instance to receive peer information (e.g. "30s").
	//
	// Default value in yaml: ~
	DialTimeout *string `json:"dialTimeout,omitempty" yaml:"dialTimeout,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- Backoff duration to retry connecting to the local hubble instance in case of failure (e.g. "30s").
	//
	// Default value in yaml: ~
	RetryTimeout *string `json:"retryTimeout,omitempty" yaml:"retryTimeout,omitempty"`
	//  @schema
	//  type: [null, integer]
	//  @schema
	//  -- (int) Max number of flows that can be buffered for sorting before being sent to the
	//  client (per request) (e.g. 100).
	//
	// Default value in yaml: ~
	SortBufferLenMax *string `json:"sortBufferLenMax,omitempty" yaml:"sortBufferLenMax,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- When the per-request flows sort buffer is not full, a flow is drained every
	//  time this timeout is reached (only affects requests in follow-mode) (e.g. "1s").
	//  -- Port to use for the k8s service backed by hubble-relay pods.
	//  If not set, it is dynamically assigned to port 443 if TLS is enabled and to
	//  port 80 if not.
	//  servicePort: 80
	//
	// Default value in yaml: ~
	SortBufferDrainTimeout *string `json:"sortBufferDrainTimeout,omitempty" yaml:"sortBufferDrainTimeout,omitempty"`
	//  -- Enable prometheus metrics for hubble-relay on the configured port at
	//  /metrics
	Prometheus *Cilium1163Values_Hubble_Relay_Prometheus `json:"prometheus,omitempty" yaml:"prometheus,omitempty"`
	Gops       *Cilium1163Values_Hubble_Relay_Gops       `json:"gops,omitempty" yaml:"gops,omitempty"`
	Pprof      *Cilium1163Values_Hubble_Relay_Pprof      `json:"pprof,omitempty" yaml:"pprof,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Relay) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Ui_Standalone_Tls struct {
	//  -- When deploying Hubble UI in standalone, with tls enabled for Hubble relay, it is required
	//  to provide a volume for mounting the client certificates.
	//    projected:
	//      defaultMode: 0400
	//      sources:
	//      - secret:
	//          name: hubble-ui-client-certs
	//          items:
	//          - key: tls.crt
	//            path: client.crt
	//          - key: tls.key
	//            path: client.key
	//          - key: ca.crt
	//            path: hubble-relay-ca.crt
	CertsVolume *map[string]any `json:"certsVolume,omitempty" yaml:"certsVolume,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui_Standalone_Tls) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Ui_Standalone struct {
	//  -- When true, it will allow installing the Hubble UI only, without checking dependencies.
	//  It is useful if a cluster already has cilium and Hubble relay installed and you just
	//  want Hubble UI to be deployed.
	//  When installed via helm, installing UI should be done via `helm upgrade` and when installed via the cilium cli, then `cilium hubble enable --ui`
	//
	// Default value in yaml: false
	Enabled *bool                                      `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	Tls     *Cilium1163Values_Hubble_Ui_Standalone_Tls `json:"tls,omitempty" yaml:"tls,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui_Standalone) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Ui_Tls_Client struct {
	//  -- Name of the Secret containing the client certificate and key for Hubble UI
	//  If specified, cert and key are ignored.
	ExistingSecret *string `json:"existingSecret,omitempty" yaml:"existingSecret,omitempty"`
	//  -- base64 encoded PEM values for the Hubble UI client certificate (deprecated).
	//  Use existingSecret instead.
	Cert *string `json:"cert,omitempty" yaml:"cert,omitempty"`
	//  -- base64 encoded PEM values for the Hubble UI client key (deprecated).
	//  Use existingSecret instead.
	Key *string `json:"key,omitempty" yaml:"key,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui_Tls_Client) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Ui_Tls struct {
	Client *Cilium1163Values_Hubble_Ui_Tls_Client `json:"client,omitempty" yaml:"client,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui_Tls) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Hubble-ui backend image.
type Cilium1163Values_Hubble_Ui_Backend_Image struct {
	//  @schema
	//  type: [null, string]
	//  @schema
	//
	// Default value in yaml: ~
	Override *string `json:"override,omitempty" yaml:"override,omitempty"`
	// Default value in yaml: quay.io/cilium/hubble-ui-backend
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	// Default value in yaml: v0.13.1
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	// Default value in yaml: sha256:0e0eed917653441fded4e7cdb096b7be6a3bddded5a2dd10812a27b1fc6ed95b
	Digest *string `json:"digest,omitempty" yaml:"digest,omitempty"`
	// Default value in yaml: true
	UseDigest *bool `json:"useDigest,omitempty" yaml:"useDigest,omitempty"`
	// Default value in yaml: IfNotPresent
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui_Backend_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Ui_Backend_LivenessProbe struct {
	//  -- Enable liveness probe for Hubble-ui backend (requires Hubble-ui 0.12+)
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui_Backend_LivenessProbe) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Ui_Backend_ReadinessProbe struct {
	//  -- Enable readiness probe for Hubble-ui backend (requires Hubble-ui 0.12+)
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui_Backend_ReadinessProbe) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Ui_Backend struct {
	//  -- Hubble-ui backend image.
	Image *Cilium1163Values_Hubble_Ui_Backend_Image `json:"image,omitempty" yaml:"image,omitempty"`
	//  -- Hubble-ui backend security context.
	SecurityContext *map[string]any `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`
	//  -- Additional hubble-ui backend environment variables.
	ExtraEnv *[]any `json:"extraEnv,omitempty" yaml:"extraEnv,omitempty"`
	//  -- Additional hubble-ui backend volumes.
	ExtraVolumes *[]any `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty"`
	//  -- Additional hubble-ui backend volumeMounts.
	ExtraVolumeMounts *[]any                                             `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty"`
	LivenessProbe     *Cilium1163Values_Hubble_Ui_Backend_LivenessProbe  `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty"`
	ReadinessProbe    *Cilium1163Values_Hubble_Ui_Backend_ReadinessProbe `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty"`
	//  -- Resource requests and limits for the 'backend' container of the 'hubble-ui' deployment.
	//    limits:
	//      cpu: 1000m
	//      memory: 1024M
	//    requests:
	//      cpu: 100m
	//      memory: 64Mi
	Resources *map[string]any `json:"resources,omitempty" yaml:"resources,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui_Backend) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Hubble-ui frontend image.
type Cilium1163Values_Hubble_Ui_Frontend_Image struct {
	//  @schema
	//  type: [null, string]
	//  @schema
	//
	// Default value in yaml: ~
	Override *string `json:"override,omitempty" yaml:"override,omitempty"`
	// Default value in yaml: quay.io/cilium/hubble-ui
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	// Default value in yaml: v0.13.1
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	// Default value in yaml: sha256:e2e9313eb7caf64b0061d9da0efbdad59c6c461f6ca1752768942bfeda0796c6
	Digest *string `json:"digest,omitempty" yaml:"digest,omitempty"`
	// Default value in yaml: true
	UseDigest *bool `json:"useDigest,omitempty" yaml:"useDigest,omitempty"`
	// Default value in yaml: IfNotPresent
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui_Frontend_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Controls server listener for ipv6
type Cilium1163Values_Hubble_Ui_Frontend_Server_Ipv6 struct {
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui_Frontend_Server_Ipv6) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//    limits:
//      cpu: 1000m
//      memory: 1024M
//    requests:
//      cpu: 100m
//      memory: 64Mi
type Cilium1163Values_Hubble_Ui_Frontend_Server struct {
	//  -- Controls server listener for ipv6
	Ipv6 *Cilium1163Values_Hubble_Ui_Frontend_Server_Ipv6 `json:"ipv6,omitempty" yaml:"ipv6,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui_Frontend_Server) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Ui_Frontend struct {
	//  -- Hubble-ui frontend image.
	Image *Cilium1163Values_Hubble_Ui_Frontend_Image `json:"image,omitempty" yaml:"image,omitempty"`
	//  -- Hubble-ui frontend security context.
	SecurityContext *map[string]any `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`
	//  -- Additional hubble-ui frontend environment variables.
	ExtraEnv *[]any `json:"extraEnv,omitempty" yaml:"extraEnv,omitempty"`
	//  -- Additional hubble-ui frontend volumes.
	ExtraVolumes *[]any `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty"`
	//  -- Additional hubble-ui frontend volumeMounts.
	ExtraVolumeMounts *[]any `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty"`
	//  -- Resource requests and limits for the 'frontend' container of the 'hubble-ui' deployment.
	Resources *map[string]any `json:"resources,omitempty" yaml:"resources,omitempty"`
	//    limits:
	//      cpu: 1000m
	//      memory: 1024M
	//    requests:
	//      cpu: 100m
	//      memory: 64Mi
	Server *Cilium1163Values_Hubble_Ui_Frontend_Server `json:"server,omitempty" yaml:"server,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui_Frontend) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  PodDisruptionBudget settings
type Cilium1163Values_Hubble_Ui_PodDisruptionBudget struct {
	//  -- enable PodDisruptionBudget
	//  ref: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  @schema
	//  type: [null, integer, string]
	//  @schema
	//  -- Minimum number/percentage of pods that should remain scheduled.
	//  When it's set, maxUnavailable must be disabled by `maxUnavailable: null`
	//
	// Default value in yaml: null
	MinAvailable *string `json:"minAvailable,omitempty" yaml:"minAvailable,omitempty"`
	//  @schema
	//  type: [null, integer, string]
	//  @schema
	//  -- Maximum number/percentage of pods that may be made unavailable
	//
	// Default value in yaml: 1
	MaxUnavailable *int64 `json:"maxUnavailable,omitempty" yaml:"maxUnavailable,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui_PodDisruptionBudget) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Node labels for pod assignment
//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
type Cilium1163Values_Hubble_Ui_NodeSelector struct {
	// Default value in yaml: linux
	KubernetesIoos *string `json:"kubernetes.io/os,omitempty" yaml:"kubernetes.io/os,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui_NodeSelector) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Ui_UpdateStrategy_RollingUpdate struct {
	//  @schema
	//  type: [integer, string]
	//  @schema
	//
	// Default value in yaml: 1
	MaxUnavailable *int64 `json:"maxUnavailable,omitempty" yaml:"maxUnavailable,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui_UpdateStrategy_RollingUpdate) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- hubble-ui update strategy.
type Cilium1163Values_Hubble_Ui_UpdateStrategy struct {
	// Default value in yaml: RollingUpdate
	Type          *string                                                  `json:"type,omitempty" yaml:"type,omitempty"`
	RollingUpdate *Cilium1163Values_Hubble_Ui_UpdateStrategy_RollingUpdate `json:"rollingUpdate,omitempty" yaml:"rollingUpdate,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui_UpdateStrategy) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Security context to be added to Hubble UI pods
type Cilium1163Values_Hubble_Ui_SecurityContext struct {
	// Default value in yaml: 1001
	RunAsUser *int64 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty"`
	// Default value in yaml: 1001
	RunAsGroup *int64 `json:"runAsGroup,omitempty" yaml:"runAsGroup,omitempty"`
	// Default value in yaml: 1001
	FsGroup *int64 `json:"fsGroup,omitempty" yaml:"fsGroup,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui_SecurityContext) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- hubble-ui service configuration.
type Cilium1163Values_Hubble_Ui_Service struct {
	//  -- Annotations to be added for the Hubble UI service
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  --- The type of service used for Hubble UI access, either ClusterIP or NodePort.
	//
	// Default value in yaml: ClusterIP
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`
	//  --- The port to use when the service type is set to NodePort.
	//
	// Default value in yaml: 31235
	NodePort *int64 `json:"nodePort,omitempty" yaml:"nodePort,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui_Service) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- hubble-ui ingress configuration.
type Cilium1163Values_Hubble_Ui_Ingress struct {
	// Default value in yaml: false
	Enabled     *bool           `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  kubernetes.io/ingress.class: nginx
	//  kubernetes.io/tls-acme: "true"
	ClassName *string `json:"className,omitempty" yaml:"className,omitempty"`
	// Default value in yaml:
	// - chart-example.local
	Hosts  *[]string       `json:"hosts,omitempty" yaml:"hosts,omitempty"`
	Labels *map[string]any `json:"labels,omitempty" yaml:"labels,omitempty"`
	//   - secretName: chart-example-tls
	//     hosts:
	//       - chart-example.local
	Tls *[]any `json:"tls,omitempty" yaml:"tls,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui_Ingress) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Ui struct {
	//  -- Whether to enable the Hubble UI.
	//
	// Default value in yaml: false
	Enabled    *bool                                  `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	Standalone *Cilium1163Values_Hubble_Ui_Standalone `json:"standalone,omitempty" yaml:"standalone,omitempty"`
	//  -- Roll out Hubble-ui pods automatically when configmap is updated.
	//
	// Default value in yaml: false
	RollOutPods *bool                                `json:"rollOutPods,omitempty" yaml:"rollOutPods,omitempty"`
	Tls         *Cilium1163Values_Hubble_Ui_Tls      `json:"tls,omitempty" yaml:"tls,omitempty"`
	Backend     *Cilium1163Values_Hubble_Ui_Backend  `json:"backend,omitempty" yaml:"backend,omitempty"`
	Frontend    *Cilium1163Values_Hubble_Ui_Frontend `json:"frontend,omitempty" yaml:"frontend,omitempty"`
	//  -- The number of replicas of Hubble UI to deploy.
	//
	// Default value in yaml: 1
	Replicas *int64 `json:"replicas,omitempty" yaml:"replicas,omitempty"`
	//  -- Annotations to be added to all top-level hubble-ui objects (resources under templates/hubble-ui)
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- Annotations to be added to hubble-ui pods
	PodAnnotations *map[string]any `json:"podAnnotations,omitempty" yaml:"podAnnotations,omitempty"`
	//  -- Labels to be added to hubble-ui pods
	PodLabels *map[string]any `json:"podLabels,omitempty" yaml:"podLabels,omitempty"`
	//  PodDisruptionBudget settings
	PodDisruptionBudget *Cilium1163Values_Hubble_Ui_PodDisruptionBudget `json:"podDisruptionBudget,omitempty" yaml:"podDisruptionBudget,omitempty"`
	//  -- Affinity for hubble-ui
	Affinity *map[string]any `json:"affinity,omitempty" yaml:"affinity,omitempty"`
	//  -- Pod topology spread constraints for hubble-ui
	//    - maxSkew: 1
	//      topologyKey: topology.kubernetes.io/zone
	//      whenUnsatisfiable: DoNotSchedule
	TopologySpreadConstraints *[]any `json:"topologySpreadConstraints,omitempty" yaml:"topologySpreadConstraints,omitempty"`
	//  -- Node labels for pod assignment
	//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
	NodeSelector *Cilium1163Values_Hubble_Ui_NodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty"`
	//  -- Node tolerations for pod assignment on nodes with taints
	//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
	Tolerations *[]any `json:"tolerations,omitempty" yaml:"tolerations,omitempty"`
	//  -- The priority class to use for hubble-ui
	PriorityClassName *string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty"`
	//  -- hubble-ui update strategy.
	UpdateStrategy *Cilium1163Values_Hubble_Ui_UpdateStrategy `json:"updateStrategy,omitempty" yaml:"updateStrategy,omitempty"`
	//  -- Security context to be added to Hubble UI pods
	SecurityContext *Cilium1163Values_Hubble_Ui_SecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`
	//  -- hubble-ui service configuration.
	Service *Cilium1163Values_Hubble_Ui_Service `json:"service,omitempty" yaml:"service,omitempty"`
	//  -- Defines base url prefix for all hubble-ui http requests.
	//  It needs to be changed in case if ingress for hubble-ui is configured under some sub-path.
	//  Trailing `/` is required for custom path, ex. `/service-map/`
	//
	// Default value in yaml: /
	BaseUrl *string `json:"baseUrl,omitempty" yaml:"baseUrl,omitempty"`
	//  -- hubble-ui ingress configuration.
	Ingress *Cilium1163Values_Hubble_Ui_Ingress `json:"ingress,omitempty" yaml:"ingress,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Ui) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  --- Static exporter configuration.
//  Static exporter is bound to agent lifecycle.
type Cilium1163Values_Hubble_Export_Static struct {
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: /var/run/cilium/hubble/events.log
	FilePath  *string `json:"filePath,omitempty" yaml:"filePath,omitempty"`
	FieldMask *[]any  `json:"fieldMask,omitempty" yaml:"fieldMask,omitempty"`
	//  - time
	//  - source
	//  - destination
	//  - verdict
	AllowList *[]any `json:"allowList,omitempty" yaml:"allowList,omitempty"`
	//  - '{"verdict":["DROPPED","ERROR"]}'
	//  - '{"source_pod":["kube-system/"]}'
	//  - '{"destination_pod":["kube-system/"]}'
	DenyList *[]any `json:"denyList,omitempty" yaml:"denyList,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Export_Static) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  ---- Exporters configuration in YAML format.
type Cilium1163Values_Hubble_Export_Dynamic_Config_ContentItem struct {
	// Default value in yaml: all
	Name           *string `json:"name,omitempty" yaml:"name,omitempty"`
	FieldMask      *[]any  `json:"fieldMask,omitempty" yaml:"fieldMask,omitempty"`
	IncludeFilters *[]any  `json:"includeFilters,omitempty" yaml:"includeFilters,omitempty"`
	ExcludeFilters *[]any  `json:"excludeFilters,omitempty" yaml:"excludeFilters,omitempty"`
	//    - name: "test002"
	//      filePath: "/var/log/network/flow-log/pa/test002.log"
	//      fieldMask: ["source.namespace", "source.pod_name", "destination.namespace", "destination.pod_name", "verdict"]
	//      includeFilters:
	//      - source_pod: ["default/"]
	//        event_type:
	//        - type: 1
	//      - destination_pod: ["frontend/nginx-975996d4c-7hhgt"]
	//      excludeFilters: []
	//      end: "2023-10-09T23:59:59-07:00"
	//
	// Default value in yaml: /var/run/cilium/hubble/events.log
	FilePath *string `json:"filePath,omitempty" yaml:"filePath,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Export_Dynamic_Config_ContentItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble_Export_Dynamic_Config struct {
	//  ---- Name of configmap with configuration that may be altered to reconfigure exporters within a running agents.
	//
	// Default value in yaml: cilium-flowlog-config
	ConfigMapName *string `json:"configMapName,omitempty" yaml:"configMapName,omitempty"`
	//  ---- True if helm installer should create config map.
	//  Switch to false if you want to self maintain the file content.
	//
	// Default value in yaml: true
	CreateConfigMap *bool `json:"createConfigMap,omitempty" yaml:"createConfigMap,omitempty"`
	//  ---- Exporters configuration in YAML format.
	Content *[]Cilium1163Values_Hubble_Export_Dynamic_Config_ContentItem `json:"content,omitempty" yaml:"content,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Export_Dynamic_Config) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  --- Dynamic exporters configuration.
//  Dynamic exporters may be reconfigured without a need of agent restarts.
type Cilium1163Values_Hubble_Export_Dynamic struct {
	// Default value in yaml: false
	Enabled *bool                                          `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	Config  *Cilium1163Values_Hubble_Export_Dynamic_Config `json:"config,omitempty" yaml:"config,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Export_Dynamic) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Hubble flows export.
type Cilium1163Values_Hubble_Export struct {
	//  --- Defines max file size of output file before it gets rotated.
	//
	// Default value in yaml: 10
	FileMaxSizeMb *int64 `json:"fileMaxSizeMb,omitempty" yaml:"fileMaxSizeMb,omitempty"`
	//  --- Defines max number of backup/rotated files.
	//
	// Default value in yaml: 5
	FileMaxBackups *int64 `json:"fileMaxBackups,omitempty" yaml:"fileMaxBackups,omitempty"`
	//  --- Static exporter configuration.
	//  Static exporter is bound to agent lifecycle.
	Static *Cilium1163Values_Hubble_Export_Static `json:"static,omitempty" yaml:"static,omitempty"`
	//  --- Dynamic exporters configuration.
	//  Dynamic exporters may be reconfigured without a need of agent restarts.
	Dynamic *Cilium1163Values_Hubble_Export_Dynamic `json:"dynamic,omitempty" yaml:"dynamic,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_Export) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Emit v1.Events related to pods on detection of packet drops.
//     This feature is alpha, please provide feedback at https://github.com/cilium/cilium/issues/33975.
type Cilium1163Values_Hubble_DropEventEmitter struct {
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  --- Minimum time between emitting same events.
	//
	// Default value in yaml: 2m
	Interval *string `json:"interval,omitempty" yaml:"interval,omitempty"`
	//  --- Drop reasons to emit events for.
	//  ref: https://docs.cilium.io/en/stable/_api/v1/flow/README/#dropreason
	//
	// Default value in yaml:
	// - auth_required
	// - policy_denied
	Reasons *[]string `json:"reasons,omitempty" yaml:"reasons,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble_DropEventEmitter) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Hubble struct {
	//  -- Enable Hubble (true by default).
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Annotations to be added to all top-level hubble objects (resources under templates/hubble)
	//  -- Buffer size of the channel Hubble uses to receive monitor events. If this
	//  value is not set, the queue size is set to the default monitor queue size.
	//  eventQueueSize: ""
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- Number of recent flows for Hubble to cache. Defaults to 4095.
	//  Possible values are:
	//    1, 3, 7, 15, 31, 63, 127, 255, 511, 1023,
	//    2047, 4095, 8191, 16383, 32767, 65535
	//  eventBufferCapacity: "4095"
	//
	//  -- Hubble metrics configuration.
	//  See https://docs.cilium.io/en/stable/observability/metrics/#hubble-metrics
	//  for more comprehensive documentation about Hubble metrics.
	Metrics *Cilium1163Values_Hubble_Metrics `json:"metrics,omitempty" yaml:"metrics,omitempty"`
	//  -- Unix domain socket path to listen to when Hubble is enabled.
	//
	// Default value in yaml: /var/run/cilium/hubble.sock
	SocketPath *string `json:"socketPath,omitempty" yaml:"socketPath,omitempty"`
	//  -- Enables redacting sensitive information present in Layer 7 flows.
	Redact *Cilium1163Values_Hubble_Redact `json:"redact,omitempty" yaml:"redact,omitempty"`
	//  -- An additional address for Hubble to listen to.
	//  Set this field ":4244" if you are enabling Hubble Relay, as it assumes that
	//  Hubble is listening on port 4244.
	//
	// Default value in yaml: :4244
	ListenAddress *string `json:"listenAddress,omitempty" yaml:"listenAddress,omitempty"`
	//  -- Whether Hubble should prefer to announce IPv6 or IPv4 addresses if both are available.
	//
	// Default value in yaml: false
	PreferIpv6 *bool `json:"preferIpv6,omitempty" yaml:"preferIpv6,omitempty"`
	//  @schema
	//  type: [null, boolean]
	//  @schema
	//  -- (bool) Skip Hubble events with unknown cgroup ids
	//  @default -- `true`
	//
	// Default value in yaml: ~
	SkipUnknownCgroupIds *string                              `json:"skipUnknownCGroupIDs,omitempty" yaml:"skipUnknownCGroupIDs,omitempty"`
	PeerService          *Cilium1163Values_Hubble_PeerService `json:"peerService,omitempty" yaml:"peerService,omitempty"`
	//  -- TLS configuration for Hubble
	Tls   *Cilium1163Values_Hubble_Tls   `json:"tls,omitempty" yaml:"tls,omitempty"`
	Relay *Cilium1163Values_Hubble_Relay `json:"relay,omitempty" yaml:"relay,omitempty"`
	Ui    *Cilium1163Values_Hubble_Ui    `json:"ui,omitempty" yaml:"ui,omitempty"`
	//  -- Hubble flows export.
	Export *Cilium1163Values_Hubble_Export `json:"export,omitempty" yaml:"export,omitempty"`
	//  -- Emit v1.Events related to pods on detection of packet drops.
	//     This feature is alpha, please provide feedback at https://github.com/cilium/cilium/issues/33975.
	DropEventEmitter *Cilium1163Values_Hubble_DropEventEmitter `json:"dropEventEmitter,omitempty" yaml:"dropEventEmitter,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Hubble) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Ipam_Operator struct {
	//  @schema
	//  type: [array, string]
	//  @schema
	//  -- IPv4 CIDR list range to delegate to individual nodes for IPAM.
	//
	// Default value in yaml:
	// - 10.0.0.0/8
	ClusterPoolIpv4PodCidrlist *[]string `json:"clusterPoolIPv4PodCIDRList,omitempty" yaml:"clusterPoolIPv4PodCIDRList,omitempty"`
	//  -- IPv4 CIDR mask size to delegate to individual nodes for IPAM.
	//
	// Default value in yaml: 24
	ClusterPoolIpv4MaskSize *int64 `json:"clusterPoolIPv4MaskSize,omitempty" yaml:"clusterPoolIPv4MaskSize,omitempty"`
	//  @schema
	//  type: [array, string]
	//  @schema
	//  -- IPv6 CIDR list range to delegate to individual nodes for IPAM.
	//
	// Default value in yaml:
	// - fd00::/104
	ClusterPoolIpv6PodCidrlist *[]string `json:"clusterPoolIPv6PodCIDRList,omitempty" yaml:"clusterPoolIPv6PodCIDRList,omitempty"`
	//  -- IPv6 CIDR mask size to delegate to individual nodes for IPAM.
	//
	// Default value in yaml: 120
	ClusterPoolIpv6MaskSize *int64 `json:"clusterPoolIPv6MaskSize,omitempty" yaml:"clusterPoolIPv6MaskSize,omitempty"`
	//  -- IP pools to auto-create in multi-pool IPAM mode.
	AutoCreateCiliumPodIppools *map[string]any `json:"autoCreateCiliumPodIPPools,omitempty" yaml:"autoCreateCiliumPodIPPools,omitempty"`
	//    default:
	//      ipv4:
	//        cidrs:
	//          - 10.10.0.0/8
	//        maskSize: 24
	//    other:
	//      ipv6:
	//        cidrs:
	//          - fd00:100::/80
	//        maskSize: 96
	//  @schema
	//  type: [null, integer]
	//  @schema
	//  -- (int) The maximum burst size when rate limiting access to external APIs.
	//  Also known as the token bucket capacity.
	//  @default -- `20`
	//
	// Default value in yaml: ~
	ExternalApilimitBurstSize *string `json:"externalAPILimitBurstSize,omitempty" yaml:"externalAPILimitBurstSize,omitempty"`
	//  @schema
	//  type: [null, number]
	//  @schema
	//  -- (float) The maximum queries per second when rate limiting access to
	//  external APIs. Also known as the bucket refill rate, which is used to
	//  refill the bucket up to the burst size capacity.
	//  @default -- `4.0`
	//
	// Default value in yaml: ~
	ExternalApilimitQps *string `json:"externalAPILimitQPS,omitempty" yaml:"externalAPILimitQPS,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Ipam_Operator) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Ipam struct {
	//  -- Configure IP Address Management mode.
	//  ref: https://docs.cilium.io/en/stable/network/concepts/ipam/
	//
	// Default value in yaml: cluster-pool
	Mode *string `json:"mode,omitempty" yaml:"mode,omitempty"`
	//  -- Maximum rate at which the CiliumNode custom resource is updated.
	//
	// Default value in yaml: 15s
	CiliumNodeUpdateRate *string                         `json:"ciliumNodeUpdateRate,omitempty" yaml:"ciliumNodeUpdateRate,omitempty"`
	Operator             *Cilium1163Values_Ipam_Operator `json:"operator,omitempty" yaml:"operator,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Ipam) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_NodeIpam struct {
	//  -- Configure Node IPAM
	//  ref: https://docs.cilium.io/en/stable/network/node-ipam/
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_NodeIpam) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure the eBPF-based ip-masq-agent
//  the config of nonMasqueradeCIDRs
//  config:
//    nonMasqueradeCIDRs: []
//    masqLinkLocal: false
//    masqLinkLocalIPv6: false
type Cilium1163Values_IpMasqAgent struct {
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_IpMasqAgent) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  iptablesLockTimeout defines the iptables "--wait" option when invoked from Cilium.
//  iptablesLockTimeout: "5s"
type Cilium1163Values_Ipv4 struct {
	//  -- Enable IPv4 support.
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Ipv4) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Ipv6 struct {
	//  -- Enable IPv6 support.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Ipv6) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure Kubernetes specific configuration
type Cilium1163Values_K8S struct {
	//  -- requireIPv4PodCIDR enables waiting for Kubernetes to provide the PodCIDR
	//  range via the Kubernetes node resource
	//
	// Default value in yaml: false
	RequireIpv4PodCidr *bool `json:"requireIPv4PodCIDR,omitempty" yaml:"requireIPv4PodCIDR,omitempty"`
	//  -- requireIPv6PodCIDR enables waiting for Kubernetes to provide the PodCIDR
	//  range via the Kubernetes node resource
	//
	// Default value in yaml: false
	RequireIpv6PodCidr *bool `json:"requireIPv6PodCIDR,omitempty" yaml:"requireIPv6PodCIDR,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_K8S) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_StartupProbe struct {
	//  -- failure threshold of startup probe.
	//  105 x 2s translates to the old behaviour of the readiness probe (120s delay + 30 x 3s)
	//
	// Default value in yaml: 105
	FailureThreshold *int64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty"`
	//  -- interval between checks of the startup probe
	//
	// Default value in yaml: 2
	PeriodSeconds *int64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_StartupProbe) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_LivenessProbe struct {
	//  -- failure threshold of liveness probe
	//
	// Default value in yaml: 10
	FailureThreshold *int64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty"`
	//  -- interval between checks of the liveness probe
	//
	// Default value in yaml: 30
	PeriodSeconds *int64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_LivenessProbe) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure the kube-proxy replacement in Cilium BPF datapath
//  Valid options are "true" or "false".
//  ref: https://docs.cilium.io/en/stable/network/kubernetes/kubeproxy-free/
// kubeProxyReplacement: "false"
type Cilium1163Values_ReadinessProbe struct {
	//  -- failure threshold of readiness probe
	//
	// Default value in yaml: 3
	FailureThreshold *int64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty"`
	//  -- interval between checks of the readiness probe
	//
	// Default value in yaml: 30
	PeriodSeconds *int64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_ReadinessProbe) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_L2NeighDiscovery struct {
	//  -- Enable L2 neighbor discovery in the agent
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Override the agent's default neighbor resolution refresh period.
	//
	// Default value in yaml: 30s
	RefreshPeriod *string `json:"refreshPeriod,omitempty" yaml:"refreshPeriod,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_L2NeighDiscovery) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Nat struct {
	//  -- Number of the top-k SNAT map connections to track in Cilium statedb.
	//
	// Default value in yaml: 32
	MapStatsEntries *int64 `json:"mapStatsEntries,omitempty" yaml:"mapStatsEntries,omitempty"`
	//  -- Interval between how often SNAT map is counted for stats.
	//
	// Default value in yaml: 30s
	MapStatsInterval *string `json:"mapStatsInterval,omitempty" yaml:"mapStatsInterval,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Nat) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_EgressGateway struct {
	//  -- Enables egress gateway to redirect and SNAT the traffic that leaves the
	//  cluster.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Time between triggers of egress gateway state reconciliations
	//  -- Maximum number of entries in egress gateway policy map
	//  maxPolicyEntries: 16384
	//
	// Default value in yaml: 1s
	ReconciliationTriggerInterval *string `json:"reconciliationTriggerInterval,omitempty" yaml:"reconciliationTriggerInterval,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_EgressGateway) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Vtep struct {
	//  -- Enables VXLAN Tunnel Endpoint (VTEP) Integration (beta) to allow
	//  Cilium-managed pods to talk to third party VTEP devices over Cilium tunnel.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- A space separated list of VTEP device endpoint IPs, for example "1.1.1.1  1.1.2.1"
	Endpoint *string `json:"endpoint,omitempty" yaml:"endpoint,omitempty"`
	//  -- A space separated list of VTEP device CIDRs, for example "1.1.1.0/24 1.1.2.0/24"
	Cidr *string `json:"cidr,omitempty" yaml:"cidr,omitempty"`
	//  -- VTEP CIDRs Mask that applies to all VTEP CIDRs, for example "255.255.255.0"
	Mask *string `json:"mask,omitempty" yaml:"mask,omitempty"`
	//  -- A space separated list of VTEP device MAC addresses (VTEP MAC), for example "x:x:x:x:x:x  y:y:y:y:y:y:y"
	Mac *string `json:"mac,omitempty" yaml:"mac,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Vtep) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- cilium-monitor sidecar.
type Cilium1163Values_Monitor struct {
	//  -- Enable the cilium-monitor sidecar.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Monitor) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- serviceTopology enables K8s Topology Aware Hints -based service
//  endpoints filtering
//  serviceTopology: false
//
//  -- L7 LoadBalancer
type Cilium1163Values_LoadBalancer_L7 struct {
	//  -- Enable L7 service load balancing via envoy proxy.
	//  The request to a k8s service, which has specific annotation e.g. service.cilium.io/lb-l7,
	//  will be forwarded to the local backend proxy to be load balanced to the service endpoints.
	//  Please refer to docs for supported annotations for more configuration.
	//
	//  Applicable values:
	//    - envoy: Enable L7 load balancing via envoy proxy. This will automatically set enable-envoy-config as well.
	//    - disabled: Disable L7 load balancing by way of service annotation.
	//
	// Default value in yaml: disabled
	Backend *string `json:"backend,omitempty" yaml:"backend,omitempty"`
	//  -- List of ports from service to be automatically redirected to above backend.
	//  Any service exposing one of these ports will be automatically redirected.
	//  Fine-grained control can be achieved by using the service annotation.
	Ports *[]any `json:"ports,omitempty" yaml:"ports,omitempty"`
	//  -- Default LB algorithm
	//  The default LB algorithm to be used for services, which can be overridden by the
	//  service annotation (e.g. service.cilium.io/lb-l7-algorithm)
	//  Applicable values: round_robin, least_request, random
	//
	// Default value in yaml: round_robin
	Algorithm *string `json:"algorithm,omitempty" yaml:"algorithm,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_LoadBalancer_L7) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure service load balancing
type Cilium1163Values_LoadBalancer struct {
	//  -- standalone enables the standalone L4LB which does not connect to
	//  kube-apiserver.
	//  standalone: false
	//
	//  -- algorithm is the name of the load balancing algorithm for backend
	//  selection e.g. random or maglev
	//  algorithm: random
	//
	//  -- mode is the operation mode of load balancing for remote backends
	//  e.g. snat, dsr, hybrid
	//  mode: snat
	//
	//  -- acceleration is the option to accelerate service handling via XDP
	//  Applicable values can be: disabled (do not use XDP), native (XDP BPF
	//  program is run directly out of the networking driver's early receive
	//  path), or best-effort (use native mode XDP acceleration on devices
	//  that support it).
	//  -- dsrDispatch configures whether IP option or IPIP encapsulation is
	//  used to pass a service IP and port to remote backend
	//  dsrDispatch: opt
	//
	// Default value in yaml: disabled
	Acceleration *string `json:"acceleration,omitempty" yaml:"acceleration,omitempty"`
	//  -- serviceTopology enables K8s Topology Aware Hints -based service
	//  endpoints filtering
	//  serviceTopology: false
	//
	//  -- L7 LoadBalancer
	L7 *Cilium1163Values_LoadBalancer_L7 `json:"l7,omitempty" yaml:"l7,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_LoadBalancer) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure N-S k8s service loadbalancing
//  policyAuditMode: false
type Cilium1163Values_NodePort struct {
	//  -- Enable the Cilium NodePort service implementation.
	//  -- Port range to use for NodePort services.
	//  range: "30000,32767"
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  @schema
	//  type: [null, string, array]
	//  @schema
	//  -- List of CIDRs for choosing which IP addresses assigned to native devices are used for NodePort load-balancing.
	//  By default this is empty and the first suitable, preferably private, IPv4 and IPv6 address assigned to each device is used.
	//
	//  Example:
	//
	//    addresses: ["192.168.1.0/24", "2001::/64"]
	//
	//
	// Default value in yaml: ~
	Addresses *string `json:"addresses,omitempty" yaml:"addresses,omitempty"`
	//  -- Set to true to prevent applications binding to service ports.
	//
	// Default value in yaml: true
	BindProtection *bool `json:"bindProtection,omitempty" yaml:"bindProtection,omitempty"`
	//  -- Append NodePort range to ip_local_reserved_ports if clash with ephemeral
	//  ports is detected.
	//
	// Default value in yaml: true
	AutoProtectPortRange *bool `json:"autoProtectPortRange,omitempty" yaml:"autoProtectPortRange,omitempty"`
	//  -- Enable healthcheck nodePort server for NodePort services
	//
	// Default value in yaml: true
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty" yaml:"enableHealthCheck,omitempty"`
	//  -- Enable access of the healthcheck nodePort on the LoadBalancerIP. Needs
	//  EnableHealthCheck to be enabled
	//
	// Default value in yaml: false
	EnableHealthCheckLoadBalancerIp *bool `json:"enableHealthCheckLoadBalancerIP,omitempty" yaml:"enableHealthCheckLoadBalancerIP,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_NodePort) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Pprof struct {
	//  -- Enable pprof for cilium-agent
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Configure pprof listen address for cilium-agent
	//
	// Default value in yaml: localhost
	Address *string `json:"address,omitempty" yaml:"address,omitempty"`
	//  -- Configure pprof listen port for cilium-agent
	//
	// Default value in yaml: 6060
	Port *int64 `json:"port,omitempty" yaml:"port,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Pprof) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Specify the Kubernetes namespace where Prometheus expects to find
//  service monitors configured.
//  namespace: ""
//  -- Relabeling configs for the ServiceMonitor cilium-agent
type Cilium1163Values_Prometheus_ServiceMonitor_RelabelingsItem struct {
	// Default value in yaml:
	// - __meta_kubernetes_pod_node_name
	SourceLabels *[]string `json:"sourceLabels,omitempty" yaml:"sourceLabels,omitempty"`
	// Default value in yaml: node
	TargetLabel *string `json:"targetLabel,omitempty" yaml:"targetLabel,omitempty"`
	// Default value in yaml: ${1}
	Replacement *string `json:"replacement,omitempty" yaml:"replacement,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Prometheus_ServiceMonitor_RelabelingsItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Prometheus_ServiceMonitor struct {
	//  -- Enable service monitors.
	//  This requires the prometheus CRDs to be available (see https://github.com/prometheus-operator/prometheus-operator/blob/main/example/prometheus-operator-crd/monitoring.coreos.com_servicemonitors.yaml)
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Labels to add to ServiceMonitor cilium-agent
	Labels *map[string]any `json:"labels,omitempty" yaml:"labels,omitempty"`
	//  -- Annotations to add to ServiceMonitor cilium-agent
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- jobLabel to add for ServiceMonitor cilium-agent
	JobLabel *string `json:"jobLabel,omitempty" yaml:"jobLabel,omitempty"`
	//  -- Interval for scrape metrics.
	//
	// Default value in yaml: 10s
	Interval *string `json:"interval,omitempty" yaml:"interval,omitempty"`
	//  -- Specify the Kubernetes namespace where Prometheus expects to find
	//  service monitors configured.
	//  namespace: ""
	//  -- Relabeling configs for the ServiceMonitor cilium-agent
	Relabelings *[]Cilium1163Values_Prometheus_ServiceMonitor_RelabelingsItem `json:"relabelings,omitempty" yaml:"relabelings,omitempty"`
	//  @schema
	//  type: [null, array]
	//  @schema
	//  -- Metrics relabeling configs for the ServiceMonitor cilium-agent
	//
	// Default value in yaml: ~
	MetricRelabelings *string `json:"metricRelabelings,omitempty" yaml:"metricRelabelings,omitempty"`
	//  -- Set to `true` and helm will not check for monitoring.coreos.com/v1 CRDs before deploying
	//
	// Default value in yaml: false
	TrustCrdsExist *bool `json:"trustCRDsExist,omitempty" yaml:"trustCRDsExist,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Prometheus_ServiceMonitor) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure prometheus metrics on the configured port at /metrics
type Cilium1163Values_Prometheus struct {
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: 9962
	Port           *int64                                      `json:"port,omitempty" yaml:"port,omitempty"`
	ServiceMonitor *Cilium1163Values_Prometheus_ServiceMonitor `json:"serviceMonitor,omitempty" yaml:"serviceMonitor,omitempty"`
	//  @schema
	//  type: [null, array]
	//  @schema
	//  -- Metrics that should be enabled or disabled from the default metric list.
	//  The list is expected to be separated by a space. (+metric_foo to enable
	//  metric_foo , -metric_bar to disable metric_bar).
	//  ref: https://docs.cilium.io/en/stable/observability/metrics/
	//
	// Default value in yaml: ~
	Metrics *string `json:"metrics,omitempty" yaml:"metrics,omitempty"`
	//  --- Enable controller group metrics for monitoring specific Cilium
	//  subsystems. The list is a list of controller group names. The special
	//  values of "all" and "none" are supported. The set of controller
	//  group names is not guaranteed to be stable between Cilium versions.
	//
	// Default value in yaml:
	// - write-cni-file
	// - sync-host-ips
	// - sync-lb-maps-with-k8s-services
	ControllerGroupMetrics *[]string `json:"controllerGroupMetrics,omitempty" yaml:"controllerGroupMetrics,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Prometheus) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Grafana dashboards for cilium-agent
//  grafana can import dashboards based on the label and value
//  ref: https://github.com/grafana/helm-charts/tree/main/charts/grafana#sidecar-for-dashboards
type Cilium1163Values_Dashboards struct {
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: grafana_dashboard
	Label *string `json:"label,omitempty" yaml:"label,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//
	// Default value in yaml: ~
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty"`
	// Default value in yaml: 1
	LabelValue  *string         `json:"labelValue,omitempty" yaml:"labelValue,omitempty"`
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Dashboards) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_Log struct {
	//  -- The format string to use for laying out the log message metadata of Envoy.
	//
	// Default value in yaml: [%Y-%m-%d %T.%e][%t][%l][%n] [%g:%#] %v
	Format *string `json:"format,omitempty" yaml:"format,omitempty"`
	//  -- Path to a separate Envoy log file, if any. Defaults to /dev/stdout.
	Path *string `json:"path,omitempty" yaml:"path,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Log) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Envoy container image.
type Cilium1163Values_Envoy_Image struct {
	//  @schema
	//  type: [null, string]
	//  @schema
	//
	// Default value in yaml: ~
	Override *string `json:"override,omitempty" yaml:"override,omitempty"`
	// Default value in yaml: quay.io/cilium/cilium-envoy
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	// Default value in yaml: v1.29.9-1728346947-0d05e48bfbb8c4737ec40d5781d970a550ed2bbd
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	// Default value in yaml: IfNotPresent
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`
	// Default value in yaml: sha256:42614a44e508f70d03a04470df5f61e3cffd22462471a0be0544cf116f2c50ba
	Digest *string `json:"digest,omitempty" yaml:"digest,omitempty"`
	// Default value in yaml: true
	UseDigest *bool `json:"useDigest,omitempty" yaml:"useDigest,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_UpdateStrategy_RollingUpdate struct {
	//  @schema
	//  type: [integer, string]
	//  @schema
	//
	// Default value in yaml: 2
	MaxUnavailable *int64 `json:"maxUnavailable,omitempty" yaml:"maxUnavailable,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_UpdateStrategy_RollingUpdate) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- cilium-envoy update strategy
//  ref: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/#updating-a-daemonset
type Cilium1163Values_Envoy_UpdateStrategy struct {
	// Default value in yaml: RollingUpdate
	Type          *string                                              `json:"type,omitempty" yaml:"type,omitempty"`
	RollingUpdate *Cilium1163Values_Envoy_UpdateStrategy_RollingUpdate `json:"rollingUpdate,omitempty" yaml:"rollingUpdate,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_UpdateStrategy) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- AppArmorProfile options for the `cilium-agent` and init containers
type Cilium1163Values_Envoy_PodSecurityContext_AppArmorProfile struct {
	// Default value in yaml: Unconfined
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_PodSecurityContext_AppArmorProfile) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Security Context for cilium-envoy pods.
type Cilium1163Values_Envoy_PodSecurityContext struct {
	//  -- AppArmorProfile options for the `cilium-agent` and init containers
	AppArmorProfile *Cilium1163Values_Envoy_PodSecurityContext_AppArmorProfile `json:"appArmorProfile,omitempty" yaml:"appArmorProfile,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_PodSecurityContext) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_StartupProbe struct {
	//  -- failure threshold of startup probe.
	//  105 x 2s translates to the old behaviour of the readiness probe (120s delay + 30 x 3s)
	//
	// Default value in yaml: 105
	FailureThreshold *int64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty"`
	//  -- interval between checks of the startup probe
	//
	// Default value in yaml: 2
	PeriodSeconds *int64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_StartupProbe) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_LivenessProbe struct {
	//  -- failure threshold of liveness probe
	//
	// Default value in yaml: 10
	FailureThreshold *int64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty"`
	//  -- interval between checks of the liveness probe
	//
	// Default value in yaml: 30
	PeriodSeconds *int64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_LivenessProbe) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_ReadinessProbe struct {
	//  -- failure threshold of readiness probe
	//
	// Default value in yaml: 3
	FailureThreshold *int64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty"`
	//  -- interval between checks of the readiness probe
	//
	// Default value in yaml: 30
	PeriodSeconds *int64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_ReadinessProbe) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- SELinux options for the `cilium-envoy` container
type Cilium1163Values_Envoy_SecurityContext_SeLinuxOptions struct {
	// Default value in yaml: s0
	Level *string `json:"level,omitempty" yaml:"level,omitempty"`
	//  Running with spc_t since we have removed the privileged mode.
	//  Users can change it to a different type as long as they have the
	//  type available on the system.
	//
	// Default value in yaml: spc_t
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_SecurityContext_SeLinuxOptions) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_SecurityContext_Capabilities struct {
	//  -- Capabilities for the `cilium-envoy` container.
	//  Even though granted to the container, the cilium-envoy-starter wrapper drops
	//  all capabilities after forking the actual Envoy process.
	//  `NET_BIND_SERVICE` is the only capability that can be passed to the Envoy process by
	//  setting `envoy.securityContext.capabilities.keepNetBindService=true` (in addition to granting the
	//  capability to the container).
	//  Note: In case of embedded envoy, the capability must  be granted to the cilium-agent container.
	//
	// Default value in yaml:
	// - NET_ADMIN
	// - SYS_ADMIN
	Envoy *[]string `json:"envoy,omitempty" yaml:"envoy,omitempty"`
	//  -- Keep capability `NET_BIND_SERVICE` for Envoy process.
	//
	// Default value in yaml: false
	KeepCapNetBindService *bool `json:"keepCapNetBindService,omitempty" yaml:"keepCapNetBindService,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_SecurityContext_Capabilities) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_SecurityContext struct {
	//  -- User to run the pod with
	//  runAsUser: 0
	//  -- Run the pod with elevated privileges
	//
	// Default value in yaml: false
	Privileged *bool `json:"privileged,omitempty" yaml:"privileged,omitempty"`
	//  -- SELinux options for the `cilium-envoy` container
	SeLinuxOptions *Cilium1163Values_Envoy_SecurityContext_SeLinuxOptions `json:"seLinuxOptions,omitempty" yaml:"seLinuxOptions,omitempty"`
	Capabilities   *Cilium1163Values_Envoy_SecurityContext_Capabilities   `json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_SecurityContext) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector_MatchLabels struct {
	// Default value in yaml: cilium-envoy
	K8SApp *string `json:"k8s-app,omitempty" yaml:"k8s-app,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector_MatchLabels) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector struct {
	MatchLabels *Cilium1163Values_Envoy_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector_MatchLabels `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem struct {
	// Default value in yaml: kubernetes.io/hostname
	TopologyKey   *string                                                                                                           `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty"`
	LabelSelector *Cilium1163Values_Envoy_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_Affinity_PodAntiAffinity struct {
	RequiredDuringSchedulingIgnoredDuringExecution *[]Cilium1163Values_Envoy_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Affinity_PodAntiAffinity) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector_MatchLabels struct {
	// Default value in yaml: cilium
	K8SApp *string `json:"k8s-app,omitempty" yaml:"k8s-app,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector_MatchLabels) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector struct {
	MatchLabels *Cilium1163Values_Envoy_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector_MatchLabels `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem struct {
	// Default value in yaml: kubernetes.io/hostname
	TopologyKey   *string                                                                                                       `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty"`
	LabelSelector *Cilium1163Values_Envoy_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_Affinity_PodAffinity struct {
	RequiredDuringSchedulingIgnoredDuringExecution *[]Cilium1163Values_Envoy_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Affinity_PodAffinity) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_Affinity_NodeAffinity_RequiredDuringSchedulingIgnoredDuringExecution_NodeSelectorTermsItem_MatchExpressionsItem struct {
	// Default value in yaml: cilium.io/no-schedule
	Key *string `json:"key,omitempty" yaml:"key,omitempty"`
	// Default value in yaml: NotIn
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty"`
	// Default value in yaml:
	// - true
	Values *[]string `json:"values,omitempty" yaml:"values,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Affinity_NodeAffinity_RequiredDuringSchedulingIgnoredDuringExecution_NodeSelectorTermsItem_MatchExpressionsItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_Affinity_NodeAffinity_RequiredDuringSchedulingIgnoredDuringExecution_NodeSelectorTermsItem struct {
	MatchExpressions *[]Cilium1163Values_Envoy_Affinity_NodeAffinity_RequiredDuringSchedulingIgnoredDuringExecution_NodeSelectorTermsItem_MatchExpressionsItem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Affinity_NodeAffinity_RequiredDuringSchedulingIgnoredDuringExecution_NodeSelectorTermsItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_Affinity_NodeAffinity_RequiredDuringSchedulingIgnoredDuringExecution struct {
	NodeSelectorTerms *[]Cilium1163Values_Envoy_Affinity_NodeAffinity_RequiredDuringSchedulingIgnoredDuringExecution_NodeSelectorTermsItem `json:"nodeSelectorTerms,omitempty" yaml:"nodeSelectorTerms,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Affinity_NodeAffinity_RequiredDuringSchedulingIgnoredDuringExecution) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_Affinity_NodeAffinity struct {
	RequiredDuringSchedulingIgnoredDuringExecution *Cilium1163Values_Envoy_Affinity_NodeAffinity_RequiredDuringSchedulingIgnoredDuringExecution `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Affinity_NodeAffinity) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Affinity for cilium-envoy.
type Cilium1163Values_Envoy_Affinity struct {
	PodAntiAffinity *Cilium1163Values_Envoy_Affinity_PodAntiAffinity `json:"podAntiAffinity,omitempty" yaml:"podAntiAffinity,omitempty"`
	PodAffinity     *Cilium1163Values_Envoy_Affinity_PodAffinity     `json:"podAffinity,omitempty" yaml:"podAffinity,omitempty"`
	NodeAffinity    *Cilium1163Values_Envoy_Affinity_NodeAffinity    `json:"nodeAffinity,omitempty" yaml:"nodeAffinity,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Affinity) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Node selector for cilium-envoy.
type Cilium1163Values_Envoy_NodeSelector struct {
	// Default value in yaml: linux
	KubernetesIoos *string `json:"kubernetes.io/os,omitempty" yaml:"kubernetes.io/os,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_NodeSelector) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Node tolerations for envoy scheduling to nodes with taints
//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
type Cilium1163Values_Envoy_TolerationsItem struct {
	//  - key: "key"
	//    operator: "Equal|Exists"
	//    value: "value"
	//    effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"
	//
	// Default value in yaml: Exists
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_TolerationsItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_Debug_Admin struct {
	//  -- Enable admin interface for cilium-envoy.
	//  This is useful for debugging and should not be enabled in production.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Port number (bound to loopback interface).
	//  kubectl port-forward can be used to access the admin interface.
	//
	// Default value in yaml: 9901
	Port *int64 `json:"port,omitempty" yaml:"port,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Debug_Admin) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_Debug struct {
	Admin *Cilium1163Values_Envoy_Debug_Admin `json:"admin,omitempty" yaml:"admin,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Debug) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Specify the Kubernetes namespace where Prometheus expects to find
//  service monitors configured.
//  namespace: ""
//  -- Relabeling configs for the ServiceMonitor cilium-envoy
//  or for cilium-agent with Envoy configured.
type Cilium1163Values_Envoy_Prometheus_ServiceMonitor_RelabelingsItem struct {
	// Default value in yaml:
	// - __meta_kubernetes_pod_node_name
	SourceLabels *[]string `json:"sourceLabels,omitempty" yaml:"sourceLabels,omitempty"`
	// Default value in yaml: node
	TargetLabel *string `json:"targetLabel,omitempty" yaml:"targetLabel,omitempty"`
	// Default value in yaml: ${1}
	Replacement *string `json:"replacement,omitempty" yaml:"replacement,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Prometheus_ServiceMonitor_RelabelingsItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Envoy_Prometheus_ServiceMonitor struct {
	//  -- Enable service monitors.
	//  This requires the prometheus CRDs to be available (see https://github.com/prometheus-operator/prometheus-operator/blob/main/example/prometheus-operator-crd/monitoring.coreos.com_servicemonitors.yaml)
	//  Note that this setting applies to both cilium-envoy _and_ cilium-agent
	//  with Envoy enabled.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Labels to add to ServiceMonitor cilium-envoy
	Labels *map[string]any `json:"labels,omitempty" yaml:"labels,omitempty"`
	//  -- Annotations to add to ServiceMonitor cilium-envoy
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- Interval for scrape metrics.
	//
	// Default value in yaml: 10s
	Interval *string `json:"interval,omitempty" yaml:"interval,omitempty"`
	//  -- Specify the Kubernetes namespace where Prometheus expects to find
	//  service monitors configured.
	//  namespace: ""
	//  -- Relabeling configs for the ServiceMonitor cilium-envoy
	//  or for cilium-agent with Envoy configured.
	Relabelings *[]Cilium1163Values_Envoy_Prometheus_ServiceMonitor_RelabelingsItem `json:"relabelings,omitempty" yaml:"relabelings,omitempty"`
	//  @schema
	//  type: [null, array]
	//  @schema
	//  -- Metrics relabeling configs for the ServiceMonitor cilium-envoy
	//  or for cilium-agent with Envoy configured.
	//
	// Default value in yaml: ~
	MetricRelabelings *string `json:"metricRelabelings,omitempty" yaml:"metricRelabelings,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Prometheus_ServiceMonitor) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure Cilium Envoy Prometheus options.
//  Note that some of these apply to either cilium-agent or cilium-envoy.
type Cilium1163Values_Envoy_Prometheus struct {
	//  -- Enable prometheus metrics for cilium-envoy
	//
	// Default value in yaml: true
	Enabled        *bool                                             `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	ServiceMonitor *Cilium1163Values_Envoy_Prometheus_ServiceMonitor `json:"serviceMonitor,omitempty" yaml:"serviceMonitor,omitempty"`
	//  -- Serve prometheus metrics for cilium-envoy on the configured port
	//
	// Default value in yaml: 9964
	Port *string `json:"port,omitempty" yaml:"port,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy_Prometheus) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Configure Cilium Envoy options.
type Cilium1163Values_Envoy struct {
	//  @schema
	//  type: [null, boolean]
	//  @schema
	//  -- Enable Envoy Proxy in standalone DaemonSet.
	//  This field is enabled by default for new installation.
	//  @default -- `true` for new installation
	//
	// Default value in yaml: ~
	Enabled *string `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- (int)
	//  Set Envoy'--base-id' to use when allocating shared memory regions.
	//  Only needs to be changed if multiple Envoy instances will run on the same node and may have conflicts. Supported values: 0 - 4294967295. Defaults to '0'
	//
	// Default value in yaml: 0
	BaseId *int64                      `json:"baseID,omitempty" yaml:"baseID,omitempty"`
	Log    *Cilium1163Values_Envoy_Log `json:"log,omitempty" yaml:"log,omitempty"`
	//  -- Time in seconds after which a TCP connection attempt times out
	//
	// Default value in yaml: 2
	ConnectTimeoutSeconds *int64 `json:"connectTimeoutSeconds,omitempty" yaml:"connectTimeoutSeconds,omitempty"`
	//  -- ProxyMaxRequestsPerConnection specifies the max_requests_per_connection setting for Envoy
	//
	// Default value in yaml: 0
	MaxRequestsPerConnection *int64 `json:"maxRequestsPerConnection,omitempty" yaml:"maxRequestsPerConnection,omitempty"`
	//  -- Set Envoy HTTP option max_connection_duration seconds. Default 0 (disable)
	//
	// Default value in yaml: 0
	MaxConnectionDurationSeconds *int64 `json:"maxConnectionDurationSeconds,omitempty" yaml:"maxConnectionDurationSeconds,omitempty"`
	//  -- Set Envoy upstream HTTP idle connection timeout seconds.
	//  Does not apply to connections with pending requests. Default 60s
	//
	// Default value in yaml: 60
	IdleTimeoutDurationSeconds *int64 `json:"idleTimeoutDurationSeconds,omitempty" yaml:"idleTimeoutDurationSeconds,omitempty"`
	//  -- Number of trusted hops regarding the x-forwarded-for and related HTTP headers for the ingress L7 policy enforcement Envoy listeners.
	//
	// Default value in yaml: 0
	XffNumTrustedHopsL7PolicyIngress *int64 `json:"xffNumTrustedHopsL7PolicyIngress,omitempty" yaml:"xffNumTrustedHopsL7PolicyIngress,omitempty"`
	//  -- Number of trusted hops regarding the x-forwarded-for and related HTTP headers for the egress L7 policy enforcement Envoy listeners.
	//
	// Default value in yaml: 0
	XffNumTrustedHopsL7PolicyEgress *int64 `json:"xffNumTrustedHopsL7PolicyEgress,omitempty" yaml:"xffNumTrustedHopsL7PolicyEgress,omitempty"`
	//  -- Envoy container image.
	Image *Cilium1163Values_Envoy_Image `json:"image,omitempty" yaml:"image,omitempty"`
	//  -- Additional containers added to the cilium Envoy DaemonSet.
	ExtraContainers *[]any `json:"extraContainers,omitempty" yaml:"extraContainers,omitempty"`
	//  -- Additional envoy container arguments.
	ExtraArgs *[]any `json:"extraArgs,omitempty" yaml:"extraArgs,omitempty"`
	//  -- Additional envoy container environment variables.
	ExtraEnv *[]any `json:"extraEnv,omitempty" yaml:"extraEnv,omitempty"`
	//  -- Additional envoy hostPath mounts.
	//  - name: host-mnt-data
	//    mountPath: /host/mnt/data
	//    hostPath: /mnt/data
	//    hostPathType: Directory
	//    readOnly: true
	//    mountPropagation: HostToContainer
	ExtraHostPathMounts *[]any `json:"extraHostPathMounts,omitempty" yaml:"extraHostPathMounts,omitempty"`
	//  -- Additional envoy volumes.
	ExtraVolumes *[]any `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty"`
	//  -- Additional envoy volumeMounts.
	ExtraVolumeMounts *[]any `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty"`
	//  -- Configure termination grace period for cilium-envoy DaemonSet.
	//
	// Default value in yaml: 1
	TerminationGracePeriodSeconds *int64 `json:"terminationGracePeriodSeconds,omitempty" yaml:"terminationGracePeriodSeconds,omitempty"`
	//  -- TCP port for the health API.
	//
	// Default value in yaml: 9878
	HealthPort *int64 `json:"healthPort,omitempty" yaml:"healthPort,omitempty"`
	//  -- cilium-envoy update strategy
	//  ref: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/#updating-a-daemonset
	UpdateStrategy *Cilium1163Values_Envoy_UpdateStrategy `json:"updateStrategy,omitempty" yaml:"updateStrategy,omitempty"`
	//  -- Roll out cilium envoy pods automatically when configmap is updated.
	//
	// Default value in yaml: false
	RollOutPods *bool `json:"rollOutPods,omitempty" yaml:"rollOutPods,omitempty"`
	//  -- Annotations to be added to all top-level cilium-envoy objects (resources under templates/cilium-envoy)
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- Security Context for cilium-envoy pods.
	PodSecurityContext *Cilium1163Values_Envoy_PodSecurityContext `json:"podSecurityContext,omitempty" yaml:"podSecurityContext,omitempty"`
	//  -- Annotations to be added to envoy pods
	PodAnnotations *map[string]any `json:"podAnnotations,omitempty" yaml:"podAnnotations,omitempty"`
	//  -- Labels to be added to envoy pods
	PodLabels *map[string]any `json:"podLabels,omitempty" yaml:"podLabels,omitempty"`
	//  -- Envoy resource limits & requests
	//  ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	//    limits:
	//      cpu: 4000m
	//      memory: 4Gi
	//    requests:
	//      cpu: 100m
	//      memory: 512Mi
	Resources       *map[string]any                         `json:"resources,omitempty" yaml:"resources,omitempty"`
	StartupProbe    *Cilium1163Values_Envoy_StartupProbe    `json:"startupProbe,omitempty" yaml:"startupProbe,omitempty"`
	LivenessProbe   *Cilium1163Values_Envoy_LivenessProbe   `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty"`
	ReadinessProbe  *Cilium1163Values_Envoy_ReadinessProbe  `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty"`
	SecurityContext *Cilium1163Values_Envoy_SecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`
	//  -- Affinity for cilium-envoy.
	Affinity *Cilium1163Values_Envoy_Affinity `json:"affinity,omitempty" yaml:"affinity,omitempty"`
	//  -- Node selector for cilium-envoy.
	NodeSelector *Cilium1163Values_Envoy_NodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty"`
	//  -- Node tolerations for envoy scheduling to nodes with taints
	//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
	Tolerations *[]Cilium1163Values_Envoy_TolerationsItem `json:"tolerations,omitempty" yaml:"tolerations,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- The priority class to use for cilium-envoy.
	//
	// Default value in yaml: ~
	PriorityClassName *string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- DNS policy for Cilium envoy pods.
	//  Ref: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
	//
	// Default value in yaml: ~
	DnsPolicy *string                       `json:"dnsPolicy,omitempty" yaml:"dnsPolicy,omitempty"`
	Debug     *Cilium1163Values_Envoy_Debug `json:"debug,omitempty" yaml:"debug,omitempty"`
	//  -- Configure Cilium Envoy Prometheus options.
	//  Note that some of these apply to either cilium-agent or cilium-envoy.
	Prometheus *Cilium1163Values_Envoy_Prometheus `json:"prometheus,omitempty" yaml:"prometheus,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Envoy) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_ResourceQuotas_Cilium_Hard struct {
	//  5k nodes * 2 DaemonSets (Cilium and cilium node init)
	//
	// Default value in yaml: 10k
	Pods *string `json:"pods,omitempty" yaml:"pods,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_ResourceQuotas_Cilium_Hard) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_ResourceQuotas_Cilium struct {
	Hard *Cilium1163Values_ResourceQuotas_Cilium_Hard `json:"hard,omitempty" yaml:"hard,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_ResourceQuotas_Cilium) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_ResourceQuotas_Operator_Hard struct {
	//  15 "clusterwide" Cilium Operator pods for HA
	//
	// Default value in yaml: 15
	Pods *string `json:"pods,omitempty" yaml:"pods,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_ResourceQuotas_Operator_Hard) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_ResourceQuotas_Operator struct {
	Hard *Cilium1163Values_ResourceQuotas_Operator_Hard `json:"hard,omitempty" yaml:"hard,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_ResourceQuotas_Operator) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Enable resource quotas for priority classes used in the cluster.
//  Need to document default
//
// sessionAffinity: false
type Cilium1163Values_ResourceQuotas struct {
	// Default value in yaml: false
	Enabled  *bool                                     `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	Cilium   *Cilium1163Values_ResourceQuotas_Cilium   `json:"cilium,omitempty" yaml:"cilium,omitempty"`
	Operator *Cilium1163Values_ResourceQuotas_Operator `json:"operator,omitempty" yaml:"operator,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_ResourceQuotas) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Base64 encoded PEM values for the CA certificate and private key.
//  This can be used as common CA to generate certificates used by hubble and clustermesh components.
//  It is neither required nor used when cert-manager is used to generate the certificates.
type Cilium1163Values_Tls_Ca struct {
	//  -- Optional CA cert. If it is provided, it will be used by cilium to
	//  generate all other certificates. Otherwise, an ephemeral CA is generated.
	Cert *string `json:"cert,omitempty" yaml:"cert,omitempty"`
	//  -- Optional CA private key. If it is provided, it will be used by cilium to
	//  generate all other certificates. Otherwise, an ephemeral CA is generated.
	Key *string `json:"key,omitempty" yaml:"key,omitempty"`
	//  -- Generated certificates validity duration in days. This will be used for auto generated CA.
	//
	// Default value in yaml: 1095
	CertValidityDuration *int64 `json:"certValidityDuration,omitempty" yaml:"certValidityDuration,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Tls_Ca) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure the CA trust bundle used for the validation of the certificates
//  leveraged by hubble and clustermesh. When enabled, it overrides the content of the
//  'ca.crt' field of the respective certificates, allowing for CA rotation with no down-time.
type Cilium1163Values_Tls_CaBundle struct {
	//  -- Enable the use of the CA trust bundle.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Name of the ConfigMap containing the CA trust bundle.
	//
	// Default value in yaml: cilium-root-ca.crt
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
	//  -- Entry of the ConfigMap containing the CA trust bundle.
	//
	// Default value in yaml: ca.crt
	Key *string `json:"key,omitempty" yaml:"key,omitempty"`
	//  -- Use a Secret instead of a ConfigMap.
	//  If uncommented, creates the ConfigMap and fills it with the specified content.
	//  Otherwise, the ConfigMap is assumed to be already present in .Release.Namespace.
	//
	//  content: |
	//    -----BEGIN CERTIFICATE-----
	//    ...
	//    -----END CERTIFICATE-----
	//    -----BEGIN CERTIFICATE-----
	//    ...
	//    -----END CERTIFICATE-----
	//
	// Default value in yaml: false
	UseSecret *bool `json:"useSecret,omitempty" yaml:"useSecret,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Tls_CaBundle) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure TLS configuration in the agent.
type Cilium1163Values_Tls struct {
	//  -- This configures how the Cilium agent loads the secrets used TLS-aware CiliumNetworkPolicies
	//  (namely the secrets referenced by terminatingTLS and originatingTLS).
	//  Possible values:
	//    - local
	//    - k8s
	//
	// Default value in yaml: local
	SecretsBackend *string `json:"secretsBackend,omitempty" yaml:"secretsBackend,omitempty"`
	//  -- Base64 encoded PEM values for the CA certificate and private key.
	//  This can be used as common CA to generate certificates used by hubble and clustermesh components.
	//  It is neither required nor used when cert-manager is used to generate the certificates.
	Ca *Cilium1163Values_Tls_Ca `json:"ca,omitempty" yaml:"ca,omitempty"`
	//  -- Configure the CA trust bundle used for the validation of the certificates
	//  leveraged by hubble and clustermesh. When enabled, it overrides the content of the
	//  'ca.crt' field of the respective certificates, allowing for CA rotation with no down-time.
	CaBundle *Cilium1163Values_Tls_CaBundle `json:"caBundle,omitempty" yaml:"caBundle,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Tls) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_WellKnownIdentities struct {
	//  -- Enable the use of well-known identities.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_WellKnownIdentities) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Etcd struct {
	//  -- Enable etcd mode for the agent.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- List of etcd endpoints
	//
	// Default value in yaml:
	// - https://CHANGE-ME:2379
	Endpoints *[]string `json:"endpoints,omitempty" yaml:"endpoints,omitempty"`
	//  -- Enable use of TLS/SSL for connectivity to etcd.
	//
	// Default value in yaml: false
	Ssl *bool `json:"ssl,omitempty" yaml:"ssl,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Etcd) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- cilium-operator image.
type Cilium1163Values_Operator_Image struct {
	//  @schema
	//  type: [null, string]
	//  @schema
	//
	// Default value in yaml: ~
	Override *string `json:"override,omitempty" yaml:"override,omitempty"`
	// Default value in yaml: quay.io/cilium/operator
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	// Default value in yaml: v1.16.3
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	//  operator-generic-digest
	//
	// Default value in yaml: sha256:6e2925ef47a1c76e183c48f95d4ce0d34a1e5e848252f910476c3e11ce1ec94b
	GenericDigest *string `json:"genericDigest,omitempty" yaml:"genericDigest,omitempty"`
	//  operator-azure-digest
	//
	// Default value in yaml: sha256:2882aaf03c32525a99181b7c065b2bb19c03eba6626fc736aebe368d90791542
	AzureDigest *string `json:"azureDigest,omitempty" yaml:"azureDigest,omitempty"`
	//  operator-aws-digest
	//
	// Default value in yaml: sha256:47f5abc5fa528472d3509c3199d7aab1e120833fb68df455e3b4476916385916
	AwsDigest *string `json:"awsDigest,omitempty" yaml:"awsDigest,omitempty"`
	//  operator-alibabacloud-digest
	//
	// Default value in yaml: sha256:d80a785c0e807fc708264a3fcb19be404114f619fd756dd5214f4cad5a281898
	AlibabacloudDigest *string `json:"alibabacloudDigest,omitempty" yaml:"alibabacloudDigest,omitempty"`
	// Default value in yaml: true
	UseDigest *bool `json:"useDigest,omitempty" yaml:"useDigest,omitempty"`
	// Default value in yaml: IfNotPresent
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`
	Suffix     *string `json:"suffix,omitempty" yaml:"suffix,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Operator_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Operator_UpdateStrategy_RollingUpdate struct {
	//  @schema
	//  type: [integer, string]
	//  @schema
	//
	// Default value in yaml: 25%
	MaxSurge *string `json:"maxSurge,omitempty" yaml:"maxSurge,omitempty"`
	//  @schema
	//  type: [integer, string]
	//  @schema
	//
	// Default value in yaml: 50%
	MaxUnavailable *string `json:"maxUnavailable,omitempty" yaml:"maxUnavailable,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Operator_UpdateStrategy_RollingUpdate) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- cilium-operator update strategy
type Cilium1163Values_Operator_UpdateStrategy struct {
	// Default value in yaml: RollingUpdate
	Type          *string                                                 `json:"type,omitempty" yaml:"type,omitempty"`
	RollingUpdate *Cilium1163Values_Operator_UpdateStrategy_RollingUpdate `json:"rollingUpdate,omitempty" yaml:"rollingUpdate,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Operator_UpdateStrategy) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Operator_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector_MatchLabels struct {
	// Default value in yaml: operator
	IoCiliumapp *string `json:"io.cilium/app,omitempty" yaml:"io.cilium/app,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Operator_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector_MatchLabels) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Operator_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector struct {
	MatchLabels *Cilium1163Values_Operator_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector_MatchLabels `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Operator_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Operator_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem struct {
	// Default value in yaml: kubernetes.io/hostname
	TopologyKey   *string                                                                                                              `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty"`
	LabelSelector *Cilium1163Values_Operator_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Operator_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Operator_Affinity_PodAntiAffinity struct {
	RequiredDuringSchedulingIgnoredDuringExecution *[]Cilium1163Values_Operator_Affinity_PodAntiAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Operator_Affinity_PodAntiAffinity) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Affinity for cilium-operator
type Cilium1163Values_Operator_Affinity struct {
	PodAntiAffinity *Cilium1163Values_Operator_Affinity_PodAntiAffinity `json:"podAntiAffinity,omitempty" yaml:"podAntiAffinity,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Operator_Affinity) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Node labels for cilium-operator pod assignment
//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
type Cilium1163Values_Operator_NodeSelector struct {
	// Default value in yaml: linux
	KubernetesIoos *string `json:"kubernetes.io/os,omitempty" yaml:"kubernetes.io/os,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Operator_NodeSelector) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Node tolerations for cilium-operator scheduling to nodes with taints
//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
type Cilium1163Values_Operator_TolerationsItem struct {
	//  - key: "key"
	//    operator: "Equal|Exists"
	//    value: "value"
	//    effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"
	//
	// Default value in yaml: Exists
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Operator_TolerationsItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  PodDisruptionBudget settings
type Cilium1163Values_Operator_PodDisruptionBudget struct {
	//  -- enable PodDisruptionBudget
	//  ref: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  @schema
	//  type: [null, integer, string]
	//  @schema
	//  -- Minimum number/percentage of pods that should remain scheduled.
	//  When it's set, maxUnavailable must be disabled by `maxUnavailable: null`
	//
	// Default value in yaml: null
	MinAvailable *string `json:"minAvailable,omitempty" yaml:"minAvailable,omitempty"`
	//  @schema
	//  type: [null, integer, string]
	//  @schema
	//  -- Maximum number/percentage of pods that may be made unavailable
	//
	// Default value in yaml: 1
	MaxUnavailable *int64 `json:"maxUnavailable,omitempty" yaml:"maxUnavailable,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Operator_PodDisruptionBudget) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Operator_Pprof struct {
	//  -- Enable pprof for cilium-operator
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Configure pprof listen address for cilium-operator
	//
	// Default value in yaml: localhost
	Address *string `json:"address,omitempty" yaml:"address,omitempty"`
	//  -- Configure pprof listen port for cilium-operator
	//
	// Default value in yaml: 6061
	Port *int64 `json:"port,omitempty" yaml:"port,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Operator_Pprof) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Operator_Prometheus_ServiceMonitor struct {
	//  -- Enable service monitors.
	//  This requires the prometheus CRDs to be available (see https://github.com/prometheus-operator/prometheus-operator/blob/main/example/prometheus-operator-crd/monitoring.coreos.com_servicemonitors.yaml)
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Labels to add to ServiceMonitor cilium-operator
	Labels *map[string]any `json:"labels,omitempty" yaml:"labels,omitempty"`
	//  -- Annotations to add to ServiceMonitor cilium-operator
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- jobLabel to add for ServiceMonitor cilium-operator
	JobLabel *string `json:"jobLabel,omitempty" yaml:"jobLabel,omitempty"`
	//  -- Interval for scrape metrics.
	//
	// Default value in yaml: 10s
	Interval *string `json:"interval,omitempty" yaml:"interval,omitempty"`
	//  @schema
	//  type: [null, array]
	//  @schema
	//  -- Relabeling configs for the ServiceMonitor cilium-operator
	//
	// Default value in yaml: ~
	Relabelings *string `json:"relabelings,omitempty" yaml:"relabelings,omitempty"`
	//  @schema
	//  type: [null, array]
	//  @schema
	//  -- Metrics relabeling configs for the ServiceMonitor cilium-operator
	//
	// Default value in yaml: ~
	MetricRelabelings *string `json:"metricRelabelings,omitempty" yaml:"metricRelabelings,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Operator_Prometheus_ServiceMonitor) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Enable prometheus metrics for cilium-operator on the configured port at
//  /metrics
type Cilium1163Values_Operator_Prometheus struct {
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: 9963
	Port           *int64                                               `json:"port,omitempty" yaml:"port,omitempty"`
	ServiceMonitor *Cilium1163Values_Operator_Prometheus_ServiceMonitor `json:"serviceMonitor,omitempty" yaml:"serviceMonitor,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Operator_Prometheus) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Grafana dashboards for cilium-operator
//  grafana can import dashboards based on the label and value
//  ref: https://github.com/grafana/helm-charts/tree/main/charts/grafana#sidecar-for-dashboards
type Cilium1163Values_Operator_Dashboards struct {
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Default value in yaml: grafana_dashboard
	Label *string `json:"label,omitempty" yaml:"label,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//
	// Default value in yaml: ~
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty"`
	// Default value in yaml: 1
	LabelValue  *string         `json:"labelValue,omitempty" yaml:"labelValue,omitempty"`
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Operator_Dashboards) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Operator_UnmanagedPodWatcher struct {
	//  -- Restart any pod that are not managed by Cilium.
	//
	// Default value in yaml: true
	Restart *bool `json:"restart,omitempty" yaml:"restart,omitempty"`
	//  -- Interval, in seconds, to check if there are any pods that are not
	//  managed by Cilium.
	//
	// Default value in yaml: 15
	IntervalSeconds *int64 `json:"intervalSeconds,omitempty" yaml:"intervalSeconds,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Operator_UnmanagedPodWatcher) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Operator struct {
	//  -- Enable the cilium-operator component (required).
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Roll out cilium-operator pods automatically when configmap is updated.
	//
	// Default value in yaml: false
	RollOutPods *bool `json:"rollOutPods,omitempty" yaml:"rollOutPods,omitempty"`
	//  -- cilium-operator image.
	Image *Cilium1163Values_Operator_Image `json:"image,omitempty" yaml:"image,omitempty"`
	//  -- Number of replicas to run for the cilium-operator deployment
	//
	// Default value in yaml: 2
	Replicas *int64 `json:"replicas,omitempty" yaml:"replicas,omitempty"`
	//  -- The priority class to use for cilium-operator
	PriorityClassName *string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty"`
	//  -- DNS policy for Cilium operator pods.
	//  Ref: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
	DnsPolicy *string `json:"dnsPolicy,omitempty" yaml:"dnsPolicy,omitempty"`
	//  -- cilium-operator update strategy
	UpdateStrategy *Cilium1163Values_Operator_UpdateStrategy `json:"updateStrategy,omitempty" yaml:"updateStrategy,omitempty"`
	//  -- Affinity for cilium-operator
	Affinity *Cilium1163Values_Operator_Affinity `json:"affinity,omitempty" yaml:"affinity,omitempty"`
	//  -- Pod topology spread constraints for cilium-operator
	//    - maxSkew: 1
	//      topologyKey: topology.kubernetes.io/zone
	//      whenUnsatisfiable: DoNotSchedule
	TopologySpreadConstraints *[]any `json:"topologySpreadConstraints,omitempty" yaml:"topologySpreadConstraints,omitempty"`
	//  -- Node labels for cilium-operator pod assignment
	//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
	NodeSelector *Cilium1163Values_Operator_NodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty"`
	//  -- Node tolerations for cilium-operator scheduling to nodes with taints
	//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
	Tolerations *[]Cilium1163Values_Operator_TolerationsItem `json:"tolerations,omitempty" yaml:"tolerations,omitempty"`
	//  -- Additional cilium-operator container arguments.
	ExtraArgs *[]any `json:"extraArgs,omitempty" yaml:"extraArgs,omitempty"`
	//  -- Additional cilium-operator environment variables.
	ExtraEnv *[]any `json:"extraEnv,omitempty" yaml:"extraEnv,omitempty"`
	//  -- Additional cilium-operator hostPath mounts.
	//  - name: host-mnt-data
	//    mountPath: /host/mnt/data
	//    hostPath: /mnt/data
	//    hostPathType: Directory
	//    readOnly: true
	//    mountPropagation: HostToContainer
	ExtraHostPathMounts *[]any `json:"extraHostPathMounts,omitempty" yaml:"extraHostPathMounts,omitempty"`
	//  -- Additional cilium-operator volumes.
	ExtraVolumes *[]any `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty"`
	//  -- Additional cilium-operator volumeMounts.
	ExtraVolumeMounts *[]any `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty"`
	//  -- Annotations to be added to all top-level cilium-operator objects (resources under templates/cilium-operator)
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- HostNetwork setting
	//
	// Default value in yaml: true
	HostNetwork *bool `json:"hostNetwork,omitempty" yaml:"hostNetwork,omitempty"`
	//  -- Security context to be added to cilium-operator pods
	PodSecurityContext *map[string]any `json:"podSecurityContext,omitempty" yaml:"podSecurityContext,omitempty"`
	//  -- Annotations to be added to cilium-operator pods
	PodAnnotations *map[string]any `json:"podAnnotations,omitempty" yaml:"podAnnotations,omitempty"`
	//  -- Labels to be added to cilium-operator pods
	PodLabels *map[string]any `json:"podLabels,omitempty" yaml:"podLabels,omitempty"`
	//  PodDisruptionBudget settings
	PodDisruptionBudget *Cilium1163Values_Operator_PodDisruptionBudget `json:"podDisruptionBudget,omitempty" yaml:"podDisruptionBudget,omitempty"`
	//  -- cilium-operator resource limits & requests
	//  ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	//    limits:
	//      cpu: 1000m
	//      memory: 1Gi
	//    requests:
	//      cpu: 100m
	//      memory: 128Mi
	Resources *map[string]any `json:"resources,omitempty" yaml:"resources,omitempty"`
	//  -- Security context to be added to cilium-operator pods
	//  runAsUser: 0
	SecurityContext *map[string]any `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`
	//  -- Interval for endpoint garbage collection.
	//
	// Default value in yaml: 5m0s
	EndpointGcinterval *string `json:"endpointGCInterval,omitempty" yaml:"endpointGCInterval,omitempty"`
	//  -- Interval for cilium node garbage collection.
	//
	// Default value in yaml: 5m0s
	NodeGcinterval *string `json:"nodeGCInterval,omitempty" yaml:"nodeGCInterval,omitempty"`
	//  -- Interval for identity garbage collection.
	//
	// Default value in yaml: 15m0s
	IdentityGcinterval *string `json:"identityGCInterval,omitempty" yaml:"identityGCInterval,omitempty"`
	//  -- Timeout for identity heartbeats.
	//
	// Default value in yaml: 30m0s
	IdentityHeartbeatTimeout *string                          `json:"identityHeartbeatTimeout,omitempty" yaml:"identityHeartbeatTimeout,omitempty"`
	Pprof                    *Cilium1163Values_Operator_Pprof `json:"pprof,omitempty" yaml:"pprof,omitempty"`
	//  -- Enable prometheus metrics for cilium-operator on the configured port at
	//  /metrics
	Prometheus *Cilium1163Values_Operator_Prometheus `json:"prometheus,omitempty" yaml:"prometheus,omitempty"`
	//  -- Grafana dashboards for cilium-operator
	//  grafana can import dashboards based on the label and value
	//  ref: https://github.com/grafana/helm-charts/tree/main/charts/grafana#sidecar-for-dashboards
	Dashboards *Cilium1163Values_Operator_Dashboards `json:"dashboards,omitempty" yaml:"dashboards,omitempty"`
	//  -- Skip CRDs creation for cilium-operator
	//
	// Default value in yaml: false
	SkipCrdcreation *bool `json:"skipCRDCreation,omitempty" yaml:"skipCRDCreation,omitempty"`
	//  -- Remove Cilium node taint from Kubernetes nodes that have a healthy Cilium
	//  pod running.
	//
	// Default value in yaml: true
	RemoveNodeTaints *bool `json:"removeNodeTaints,omitempty" yaml:"removeNodeTaints,omitempty"`
	//  @schema
	//  type: [null, boolean]
	//  @schema
	//  -- Taint nodes where Cilium is scheduled but not running. This prevents pods
	//  from being scheduled to nodes where Cilium is not the default CNI provider.
	//  @default -- same as removeNodeTaints
	//
	// Default value in yaml: ~
	SetNodeTaints *string `json:"setNodeTaints,omitempty" yaml:"setNodeTaints,omitempty"`
	//  -- Set Node condition NetworkUnavailable to 'false' with the reason
	//  'CiliumIsUp' for nodes that have a healthy Cilium pod.
	//
	// Default value in yaml: true
	SetNodeNetworkStatus *bool                                          `json:"setNodeNetworkStatus,omitempty" yaml:"setNodeNetworkStatus,omitempty"`
	UnmanagedPodWatcher  *Cilium1163Values_Operator_UnmanagedPodWatcher `json:"unmanagedPodWatcher,omitempty" yaml:"unmanagedPodWatcher,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Operator) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- node-init image.
type Cilium1163Values_Nodeinit_Image struct {
	//  @schema
	//  type: [null, string]
	//  @schema
	//
	// Default value in yaml: ~
	Override *string `json:"override,omitempty" yaml:"override,omitempty"`
	// Default value in yaml: quay.io/cilium/startup-script
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	// Default value in yaml: c54c7edeab7fde4da68e59acd319ab24af242c3f
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	// Default value in yaml: sha256:8d7b41c4ca45860254b3c19e20210462ef89479bb6331d6760c4e609d651b29c
	Digest *string `json:"digest,omitempty" yaml:"digest,omitempty"`
	// Default value in yaml: true
	UseDigest *bool `json:"useDigest,omitempty" yaml:"useDigest,omitempty"`
	// Default value in yaml: IfNotPresent
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Nodeinit_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- node-init update strategy
type Cilium1163Values_Nodeinit_UpdateStrategy struct {
	// Default value in yaml: RollingUpdate
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Nodeinit_UpdateStrategy) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Node labels for nodeinit pod assignment
//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
type Cilium1163Values_Nodeinit_NodeSelector struct {
	// Default value in yaml: linux
	KubernetesIoos *string `json:"kubernetes.io/os,omitempty" yaml:"kubernetes.io/os,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Nodeinit_NodeSelector) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Node tolerations for nodeinit scheduling to nodes with taints
//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
type Cilium1163Values_Nodeinit_TolerationsItem struct {
	//  - key: "key"
	//    operator: "Equal|Exists"
	//    value: "value"
	//    effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"
	//
	// Default value in yaml: Exists
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Nodeinit_TolerationsItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- AppArmorProfile options for the `cilium-node-init` and init containers
type Cilium1163Values_Nodeinit_PodSecurityContext_AppArmorProfile struct {
	// Default value in yaml: Unconfined
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Nodeinit_PodSecurityContext_AppArmorProfile) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Security Context for cilium-node-init pods.
type Cilium1163Values_Nodeinit_PodSecurityContext struct {
	//  -- AppArmorProfile options for the `cilium-node-init` and init containers
	AppArmorProfile *Cilium1163Values_Nodeinit_PodSecurityContext_AppArmorProfile `json:"appArmorProfile,omitempty" yaml:"appArmorProfile,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Nodeinit_PodSecurityContext) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Nodeinit_Resources_Requests struct {
	// Default value in yaml: 100m
	Cpu *string `json:"cpu,omitempty" yaml:"cpu,omitempty"`
	// Default value in yaml: 100Mi
	Memory *string `json:"memory,omitempty" yaml:"memory,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Nodeinit_Resources_Requests) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- nodeinit resource limits & requests
//  ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
type Cilium1163Values_Nodeinit_Resources struct {
	Requests *Cilium1163Values_Nodeinit_Resources_Requests `json:"requests,omitempty" yaml:"requests,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Nodeinit_Resources) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Nodeinit_SecurityContext_SeLinuxOptions struct {
	// Default value in yaml: s0
	Level *string `json:"level,omitempty" yaml:"level,omitempty"`
	//  Running with spc_t since we have removed the privileged mode.
	//  Users can change it to a different type as long as they have the
	//  type available on the system.
	//
	// Default value in yaml: spc_t
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Nodeinit_SecurityContext_SeLinuxOptions) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Nodeinit_SecurityContext_Capabilities struct {
	// Default value in yaml:
	// - SYS_MODULE
	// - NET_ADMIN
	// - SYS_ADMIN
	// - SYS_CHROOT
	// - SYS_PTRACE
	Add *[]string `json:"add,omitempty" yaml:"add,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Nodeinit_SecurityContext_Capabilities) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Security context to be added to nodeinit pods.
type Cilium1163Values_Nodeinit_SecurityContext struct {
	// Default value in yaml: false
	Privileged     *bool                                                     `json:"privileged,omitempty" yaml:"privileged,omitempty"`
	SeLinuxOptions *Cilium1163Values_Nodeinit_SecurityContext_SeLinuxOptions `json:"seLinuxOptions,omitempty" yaml:"seLinuxOptions,omitempty"`
	Capabilities   *Cilium1163Values_Nodeinit_SecurityContext_Capabilities   `json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Nodeinit_SecurityContext) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- startup offers way to customize startup nodeinit script (pre and post position)
type Cilium1163Values_Nodeinit_Startup struct {
	PreScript  *string `json:"preScript,omitempty" yaml:"preScript,omitempty"`
	PostScript *string `json:"postScript,omitempty" yaml:"postScript,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Nodeinit_Startup) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- prestop offers way to customize prestop nodeinit script (pre and post position)
type Cilium1163Values_Nodeinit_Prestop struct {
	PreScript  *string `json:"preScript,omitempty" yaml:"preScript,omitempty"`
	PostScript *string `json:"postScript,omitempty" yaml:"postScript,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Nodeinit_Prestop) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Nodeinit struct {
	//  -- Enable the node initialization DaemonSet
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- node-init image.
	Image *Cilium1163Values_Nodeinit_Image `json:"image,omitempty" yaml:"image,omitempty"`
	//  -- The priority class to use for the nodeinit pod.
	PriorityClassName *string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty"`
	//  -- node-init update strategy
	UpdateStrategy *Cilium1163Values_Nodeinit_UpdateStrategy `json:"updateStrategy,omitempty" yaml:"updateStrategy,omitempty"`
	//  -- Additional nodeinit environment variables.
	ExtraEnv *[]any `json:"extraEnv,omitempty" yaml:"extraEnv,omitempty"`
	//  -- Additional nodeinit volumes.
	ExtraVolumes *[]any `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty"`
	//  -- Additional nodeinit volumeMounts.
	ExtraVolumeMounts *[]any `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty"`
	//  -- Affinity for cilium-nodeinit
	Affinity *map[string]any `json:"affinity,omitempty" yaml:"affinity,omitempty"`
	//  -- Node labels for nodeinit pod assignment
	//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
	NodeSelector *Cilium1163Values_Nodeinit_NodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty"`
	//  -- Node tolerations for nodeinit scheduling to nodes with taints
	//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
	Tolerations *[]Cilium1163Values_Nodeinit_TolerationsItem `json:"tolerations,omitempty" yaml:"tolerations,omitempty"`
	//  -- Annotations to be added to all top-level nodeinit objects (resources under templates/cilium-nodeinit)
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- Annotations to be added to node-init pods.
	PodAnnotations *map[string]any `json:"podAnnotations,omitempty" yaml:"podAnnotations,omitempty"`
	//  -- Labels to be added to node-init pods.
	PodLabels *map[string]any `json:"podLabels,omitempty" yaml:"podLabels,omitempty"`
	//  -- Security Context for cilium-node-init pods.
	PodSecurityContext *Cilium1163Values_Nodeinit_PodSecurityContext `json:"podSecurityContext,omitempty" yaml:"podSecurityContext,omitempty"`
	//  -- nodeinit resource limits & requests
	//  ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Resources *Cilium1163Values_Nodeinit_Resources `json:"resources,omitempty" yaml:"resources,omitempty"`
	//  -- Security context to be added to nodeinit pods.
	SecurityContext *Cilium1163Values_Nodeinit_SecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`
	//  -- bootstrapFile is the location of the file where the bootstrap timestamp is
	//  written by the node-init DaemonSet
	//
	// Default value in yaml: /tmp/cilium-bootstrap.d/cilium-bootstrap-time
	BootstrapFile *string `json:"bootstrapFile,omitempty" yaml:"bootstrapFile,omitempty"`
	//  -- startup offers way to customize startup nodeinit script (pre and post position)
	Startup *Cilium1163Values_Nodeinit_Startup `json:"startup,omitempty" yaml:"startup,omitempty"`
	//  -- prestop offers way to customize prestop nodeinit script (pre and post position)
	Prestop *Cilium1163Values_Nodeinit_Prestop `json:"prestop,omitempty" yaml:"prestop,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Nodeinit) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Cilium pre-flight image.
type Cilium1163Values_Preflight_Image struct {
	//  @schema
	//  type: [null, string]
	//  @schema
	//
	// Default value in yaml: ~
	Override *string `json:"override,omitempty" yaml:"override,omitempty"`
	// Default value in yaml: quay.io/cilium/cilium
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	// Default value in yaml: v1.16.3
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	//  cilium-digest
	//
	// Default value in yaml: sha256:62d2a09bbef840a46099ac4c69421c90f84f28d018d479749049011329aa7f28
	Digest *string `json:"digest,omitempty" yaml:"digest,omitempty"`
	// Default value in yaml: true
	UseDigest *bool `json:"useDigest,omitempty" yaml:"useDigest,omitempty"`
	// Default value in yaml: IfNotPresent
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Preflight_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- preflight update strategy
type Cilium1163Values_Preflight_UpdateStrategy struct {
	// Default value in yaml: RollingUpdate
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Preflight_UpdateStrategy) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Preflight_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector_MatchLabels struct {
	// Default value in yaml: cilium
	K8SApp *string `json:"k8s-app,omitempty" yaml:"k8s-app,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Preflight_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector_MatchLabels) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Preflight_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector struct {
	MatchLabels *Cilium1163Values_Preflight_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector_MatchLabels `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Preflight_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Preflight_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem struct {
	// Default value in yaml: kubernetes.io/hostname
	TopologyKey   *string                                                                                                           `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty"`
	LabelSelector *Cilium1163Values_Preflight_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem_LabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Preflight_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Preflight_Affinity_PodAffinity struct {
	RequiredDuringSchedulingIgnoredDuringExecution *[]Cilium1163Values_Preflight_Affinity_PodAffinity_RequiredDuringSchedulingIgnoredDuringExecutionItem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Preflight_Affinity_PodAffinity) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Affinity for cilium-preflight
type Cilium1163Values_Preflight_Affinity struct {
	PodAffinity *Cilium1163Values_Preflight_Affinity_PodAffinity `json:"podAffinity,omitempty" yaml:"podAffinity,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Preflight_Affinity) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Node labels for preflight pod assignment
//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
type Cilium1163Values_Preflight_NodeSelector struct {
	// Default value in yaml: linux
	KubernetesIoos *string `json:"kubernetes.io/os,omitempty" yaml:"kubernetes.io/os,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Preflight_NodeSelector) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Node tolerations for preflight scheduling to nodes with taints
//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
type Cilium1163Values_Preflight_TolerationsItem struct {
	//  - key: "key"
	//    operator: "Equal|Exists"
	//    value: "value"
	//    effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"
	//
	// Default value in yaml: Exists
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Preflight_TolerationsItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  PodDisruptionBudget settings
type Cilium1163Values_Preflight_PodDisruptionBudget struct {
	//  -- enable PodDisruptionBudget
	//  ref: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  @schema
	//  type: [null, integer, string]
	//  @schema
	//  -- Minimum number/percentage of pods that should remain scheduled.
	//  When it's set, maxUnavailable must be disabled by `maxUnavailable: null`
	//
	// Default value in yaml: null
	MinAvailable *string `json:"minAvailable,omitempty" yaml:"minAvailable,omitempty"`
	//  @schema
	//  type: [null, integer, string]
	//  @schema
	//  -- Maximum number/percentage of pods that may be made unavailable
	//
	// Default value in yaml: 1
	MaxUnavailable *int64 `json:"maxUnavailable,omitempty" yaml:"maxUnavailable,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Preflight_PodDisruptionBudget) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Preflight_ReadinessProbe struct {
	//  -- For how long kubelet should wait before performing the first probe
	//
	// Default value in yaml: 5
	InitialDelaySeconds *int64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty"`
	//  -- interval between checks of the readiness probe
	//
	// Default value in yaml: 5
	PeriodSeconds *int64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Preflight_ReadinessProbe) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Preflight struct {
	//  -- Enable Cilium pre-flight resources (required for upgrade)
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Cilium pre-flight image.
	Image *Cilium1163Values_Preflight_Image `json:"image,omitempty" yaml:"image,omitempty"`
	//  -- The priority class to use for the preflight pod.
	PriorityClassName *string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty"`
	//  -- preflight update strategy
	UpdateStrategy *Cilium1163Values_Preflight_UpdateStrategy `json:"updateStrategy,omitempty" yaml:"updateStrategy,omitempty"`
	//  -- Additional preflight environment variables.
	ExtraEnv *[]any `json:"extraEnv,omitempty" yaml:"extraEnv,omitempty"`
	//  -- Additional preflight volumes.
	ExtraVolumes *[]any `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty"`
	//  -- Additional preflight volumeMounts.
	ExtraVolumeMounts *[]any `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty"`
	//  -- Affinity for cilium-preflight
	Affinity *Cilium1163Values_Preflight_Affinity `json:"affinity,omitempty" yaml:"affinity,omitempty"`
	//  -- Node labels for preflight pod assignment
	//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
	NodeSelector *Cilium1163Values_Preflight_NodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty"`
	//  -- Node tolerations for preflight scheduling to nodes with taints
	//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
	Tolerations *[]Cilium1163Values_Preflight_TolerationsItem `json:"tolerations,omitempty" yaml:"tolerations,omitempty"`
	//  -- Annotations to be added to all top-level preflight objects (resources under templates/cilium-preflight)
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- Security context to be added to preflight pods.
	PodSecurityContext *map[string]any `json:"podSecurityContext,omitempty" yaml:"podSecurityContext,omitempty"`
	//  -- Annotations to be added to preflight pods
	PodAnnotations *map[string]any `json:"podAnnotations,omitempty" yaml:"podAnnotations,omitempty"`
	//  -- Labels to be added to the preflight pod.
	PodLabels *map[string]any `json:"podLabels,omitempty" yaml:"podLabels,omitempty"`
	//  PodDisruptionBudget settings
	PodDisruptionBudget *Cilium1163Values_Preflight_PodDisruptionBudget `json:"podDisruptionBudget,omitempty" yaml:"podDisruptionBudget,omitempty"`
	//  -- preflight resource limits & requests
	//  ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	//    limits:
	//      cpu: 4000m
	//      memory: 4Gi
	//    requests:
	//      cpu: 100m
	//      memory: 512Mi
	Resources      *map[string]any                            `json:"resources,omitempty" yaml:"resources,omitempty"`
	ReadinessProbe *Cilium1163Values_Preflight_ReadinessProbe `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty"`
	//  -- Security context to be added to preflight pods
	//    runAsUser: 0
	SecurityContext *map[string]any `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`
	//  -- Path to write the `--tofqdns-pre-cache` file to.
	TofqdnsPreCache *string `json:"tofqdnsPreCache,omitempty" yaml:"tofqdnsPreCache,omitempty"`
	//  -- Configure termination grace period for preflight Deployment and DaemonSet.
	//
	// Default value in yaml: 1
	TerminationGracePeriodSeconds *int64 `json:"terminationGracePeriodSeconds,omitempty" yaml:"terminationGracePeriodSeconds,omitempty"`
	//  -- By default we should always validate the installed CNPs before upgrading
	//  Cilium. This will make sure the user will have the policies deployed in the
	//  cluster with the right schema.
	//
	// Default value in yaml: true
	ValidateCnps *bool `json:"validateCNPs,omitempty" yaml:"validateCNPs,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Preflight) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Clustermesh explicit configuration.
type Cilium1163Values_Clustermesh_Config struct {
	//  -- Enable the Clustermesh explicit configuration.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Default dns domain for the Clustermesh API servers
	//  This is used in the case cluster addresses are not provided
	//  and IPs are used.
	//
	// Default value in yaml: mesh.cilium.io
	Domain *string `json:"domain,omitempty" yaml:"domain,omitempty"`
	//  -- List of clusters to be peered in the mesh.
	//  clusters:
	//  # -- Name of the cluster
	//  - name: cluster1
	//  # -- Address of the cluster, use this if you created DNS records for
	//  # the cluster Clustermesh API server.
	//    address: cluster1.mesh.cilium.io
	//  # -- Port of the cluster Clustermesh API server.
	//    port: 2379
	//  # -- IPs of the cluster Clustermesh API server, use multiple ones when
	//  # you have multiple IPs to access the Clustermesh API server.
	//    ips:
	//    - 172.18.255.201
	//  # -- base64 encoded PEM values for the cluster client certificate, private key and certificate authority.
	//  # These fields can (and should) be omitted in case the CA is shared across clusters. In that case, the
	//  # "remote" private key and certificate available in the local cluster are automatically used instead.
	//    tls:
	//      cert: ""
	//      key: ""
	//      caCert: ""
	Clusters *[]any `json:"clusters,omitempty" yaml:"clusters,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Config) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Clustermesh API server image.
type Cilium1163Values_Clustermesh_Apiserver_Image struct {
	//  @schema
	//  type: [null, string]
	//  @schema
	//
	// Default value in yaml: ~
	Override *string `json:"override,omitempty" yaml:"override,omitempty"`
	// Default value in yaml: quay.io/cilium/clustermesh-apiserver
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	// Default value in yaml: v1.16.3
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	//  clustermesh-apiserver-digest
	//
	// Default value in yaml: sha256:598cb4fd30b47bf2bc229cd6a011e451cf14753e56a80bb9ef01a09a519f52fb
	Digest *string `json:"digest,omitempty" yaml:"digest,omitempty"`
	// Default value in yaml: true
	UseDigest *bool `json:"useDigest,omitempty" yaml:"useDigest,omitempty"`
	// Default value in yaml: IfNotPresent
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver_Etcd_SecurityContext_Capabilities struct {
	// Default value in yaml:
	// - ALL
	Drop *[]string `json:"drop,omitempty" yaml:"drop,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Etcd_SecurityContext_Capabilities) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Security context to be added to clustermesh-apiserver etcd containers
type Cilium1163Values_Clustermesh_Apiserver_Etcd_SecurityContext struct {
	// Default value in yaml: false
	AllowPrivilegeEscalation *bool                                                                     `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty"`
	Capabilities             *Cilium1163Values_Clustermesh_Apiserver_Etcd_SecurityContext_Capabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Etcd_SecurityContext) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver_Etcd_Init struct {
	//  -- Specifies the resources for etcd init container in the apiserver
	//    requests:
	//      cpu: 100m
	//      memory: 100Mi
	//    limits:
	//      cpu: 100m
	//      memory: 100Mi
	Resources *map[string]any `json:"resources,omitempty" yaml:"resources,omitempty"`
	//  -- Additional arguments to `clustermesh-apiserver etcdinit`.
	ExtraArgs *[]any `json:"extraArgs,omitempty" yaml:"extraArgs,omitempty"`
	//  -- Additional environment variables to `clustermesh-apiserver etcdinit`.
	ExtraEnv *[]any `json:"extraEnv,omitempty" yaml:"extraEnv,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Etcd_Init) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver_Etcd struct {
	//  The etcd binary is included in the clustermesh API server image, so the same image from above is reused.
	//  Independent override isn't supported, because clustermesh-apiserver is tested against the etcd version it is
	//  built with.
	//
	//  -- Specifies the resources for etcd container in the apiserver
	//    requests:
	//      cpu: 200m
	//      memory: 256Mi
	//    limits:
	//      cpu: 1000m
	//      memory: 256Mi
	Resources *map[string]any `json:"resources,omitempty" yaml:"resources,omitempty"`
	//  -- Security context to be added to clustermesh-apiserver etcd containers
	SecurityContext *Cilium1163Values_Clustermesh_Apiserver_Etcd_SecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`
	//  -- lifecycle setting for the etcd container
	Lifecycle *map[string]any                                   `json:"lifecycle,omitempty" yaml:"lifecycle,omitempty"`
	Init      *Cilium1163Values_Clustermesh_Apiserver_Etcd_Init `json:"init,omitempty" yaml:"init,omitempty"`
	//  @schema
	//  enum: [Disk, Memory]
	//  @schema
	//  -- Specifies whether etcd data is stored in a temporary volume backed by
	//  the node's default medium, such as disk, SSD or network storage (Disk), or
	//  RAM (Memory). The Memory option enables improved etcd read and write
	//  performance at the cost of additional memory usage, which counts against
	//  the memory limits of the container.
	//
	// Default value in yaml: Disk
	StorageMedium *string `json:"storageMedium,omitempty" yaml:"storageMedium,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Etcd) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver_Kvstoremesh_SecurityContext_Capabilities struct {
	// Default value in yaml:
	// - ALL
	Drop *[]string `json:"drop,omitempty" yaml:"drop,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Kvstoremesh_SecurityContext_Capabilities) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- KVStoreMesh Security context
type Cilium1163Values_Clustermesh_Apiserver_Kvstoremesh_SecurityContext struct {
	// Default value in yaml: false
	AllowPrivilegeEscalation *bool                                                                            `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty"`
	Capabilities             *Cilium1163Values_Clustermesh_Apiserver_Kvstoremesh_SecurityContext_Capabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Kvstoremesh_SecurityContext) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver_Kvstoremesh struct {
	//  -- Enable KVStoreMesh. KVStoreMesh caches the information retrieved
	//  from the remote clusters in the local etcd instance.
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- TCP port for the KVStoreMesh health API.
	//
	// Default value in yaml: 9881
	HealthPort *int64 `json:"healthPort,omitempty" yaml:"healthPort,omitempty"`
	//  -- Configuration for the KVStoreMesh readiness probe.
	ReadinessProbe *map[string]any `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty"`
	//  -- Additional KVStoreMesh arguments.
	ExtraArgs *[]any `json:"extraArgs,omitempty" yaml:"extraArgs,omitempty"`
	//  -- Additional KVStoreMesh environment variables.
	ExtraEnv *[]any `json:"extraEnv,omitempty" yaml:"extraEnv,omitempty"`
	//  -- Resource requests and limits for the KVStoreMesh container
	//    requests:
	//      cpu: 100m
	//      memory: 64Mi
	//    limits:
	//      cpu: 1000m
	//      memory: 1024M
	Resources *map[string]any `json:"resources,omitempty" yaml:"resources,omitempty"`
	//  -- Additional KVStoreMesh volumeMounts.
	ExtraVolumeMounts *[]any `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty"`
	//  -- KVStoreMesh Security context
	SecurityContext *Cilium1163Values_Clustermesh_Apiserver_Kvstoremesh_SecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`
	//  -- lifecycle setting for the KVStoreMesh container
	Lifecycle *map[string]any `json:"lifecycle,omitempty" yaml:"lifecycle,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Kvstoremesh) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver_Service struct {
	//  -- The type of service used for apiserver access.
	//
	// Default value in yaml: NodePort
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`
	//  -- Optional port to use as the node port for apiserver access.
	//
	//  WARNING: make sure to configure a different NodePort in each cluster if
	//  kube-proxy replacement is enabled, as Cilium is currently affected by a known
	//  bug (#24692) when NodePorts are handled by the KPR implementation. If a service
	//  with the same NodePort exists both in the local and the remote cluster, all
	//  traffic originating from inside the cluster and targeting the corresponding
	//  NodePort will be redirected to a local backend, regardless of whether the
	//  destination node belongs to the local or the remote cluster.
	//
	// Default value in yaml: 32379
	NodePort *int64 `json:"nodePort,omitempty" yaml:"nodePort,omitempty"`
	//  -- Annotations for the clustermesh-apiserver
	//  For GKE LoadBalancer, use annotation cloud.google.com/load-balancer-type: "Internal"
	//  For EKS LoadBalancer, use annotation service.beta.kubernetes.io/aws-load-balancer-internal: "true"
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  @schema
	//  enum: [Local, Cluster]
	//  @schema
	//  -- The externalTrafficPolicy of service used for apiserver access.
	//
	// Default value in yaml: Cluster
	ExternalTrafficPolicy *string `json:"externalTrafficPolicy,omitempty" yaml:"externalTrafficPolicy,omitempty"`
	//  @schema
	//  enum: [Local, Cluster]
	//  @schema
	//  -- The internalTrafficPolicy of service used for apiserver access.
	//
	// Default value in yaml: Cluster
	InternalTrafficPolicy *string `json:"internalTrafficPolicy,omitempty" yaml:"internalTrafficPolicy,omitempty"`
	//  @schema
	//  enum: [HAOnly, Always, Never]
	//  @schema
	//  -- Defines when to enable session affinity.
	//  Each replica in a clustermesh-apiserver deployment runs its own discrete
	//  etcd cluster. Remote clients connect to one of the replicas through a
	//  shared Kubernetes Service. A client reconnecting to a different backend
	//  will require a full resync to ensure data integrity. Session affinity
	//  can reduce the likelihood of this happening, but may not be supported
	//  by all cloud providers.
	//  Possible values:
	//   - "HAOnly" (default) Only enable session affinity for deployments with more than 1 replica.
	//   - "Always" Always enable session affinity.
	//   - "Never" Never enable session affinity. Useful in environments where
	//             session affinity is not supported, but may lead to slightly
	//             degraded performance due to more frequent reconnections.
	//
	// Default value in yaml: HAOnly
	EnableSessionAffinity *string `json:"enableSessionAffinity,omitempty" yaml:"enableSessionAffinity,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- Configure a loadBalancerClass.
	//  Allows to configure the loadBalancerClass on the clustermesh-apiserver
	//  LB service in case the Service type is set to LoadBalancer
	//  (requires Kubernetes 1.24+).
	//
	// Default value in yaml: ~
	LoadBalancerClass *string `json:"loadBalancerClass,omitempty" yaml:"loadBalancerClass,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- Configure a specific loadBalancerIP.
	//  Allows to configure a specific loadBalancerIP on the clustermesh-apiserver
	//  LB service in case the Service type is set to LoadBalancer.
	//
	// Default value in yaml: ~
	LoadBalancerIp *string `json:"loadBalancerIP,omitempty" yaml:"loadBalancerIP,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Service) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver_SecurityContext_Capabilities struct {
	// Default value in yaml:
	// - ALL
	Drop *[]string `json:"drop,omitempty" yaml:"drop,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_SecurityContext_Capabilities) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Security context to be added to clustermesh-apiserver containers
type Cilium1163Values_Clustermesh_Apiserver_SecurityContext struct {
	// Default value in yaml: false
	AllowPrivilegeEscalation *bool                                                                `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty"`
	Capabilities             *Cilium1163Values_Clustermesh_Apiserver_SecurityContext_Capabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_SecurityContext) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Security context to be added to clustermesh-apiserver pods
type Cilium1163Values_Clustermesh_Apiserver_PodSecurityContext struct {
	// Default value in yaml: true
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty"`
	// Default value in yaml: 65532
	RunAsUser *int64 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty"`
	// Default value in yaml: 65532
	RunAsGroup *int64 `json:"runAsGroup,omitempty" yaml:"runAsGroup,omitempty"`
	// Default value in yaml: 65532
	FsGroup *int64 `json:"fsGroup,omitempty" yaml:"fsGroup,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_PodSecurityContext) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  PodDisruptionBudget settings
type Cilium1163Values_Clustermesh_Apiserver_PodDisruptionBudget struct {
	//  -- enable PodDisruptionBudget
	//  ref: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  @schema
	//  type: [null, integer, string]
	//  @schema
	//  -- Minimum number/percentage of pods that should remain scheduled.
	//  When it's set, maxUnavailable must be disabled by `maxUnavailable: null`
	//
	// Default value in yaml: null
	MinAvailable *string `json:"minAvailable,omitempty" yaml:"minAvailable,omitempty"`
	//  @schema
	//  type: [null, integer, string]
	//  @schema
	//  -- Maximum number/percentage of pods that may be made unavailable
	//
	// Default value in yaml: 1
	MaxUnavailable *int64 `json:"maxUnavailable,omitempty" yaml:"maxUnavailable,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_PodDisruptionBudget) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver_Affinity_PodAntiAffinity_PreferredDuringSchedulingIgnoredDuringExecutionItem_PodAffinityTerm_LabelSelector_MatchLabels struct {
	// Default value in yaml: clustermesh-apiserver
	K8SApp *string `json:"k8s-app,omitempty" yaml:"k8s-app,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Affinity_PodAntiAffinity_PreferredDuringSchedulingIgnoredDuringExecutionItem_PodAffinityTerm_LabelSelector_MatchLabels) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver_Affinity_PodAntiAffinity_PreferredDuringSchedulingIgnoredDuringExecutionItem_PodAffinityTerm_LabelSelector struct {
	MatchLabels *Cilium1163Values_Clustermesh_Apiserver_Affinity_PodAntiAffinity_PreferredDuringSchedulingIgnoredDuringExecutionItem_PodAffinityTerm_LabelSelector_MatchLabels `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Affinity_PodAntiAffinity_PreferredDuringSchedulingIgnoredDuringExecutionItem_PodAffinityTerm_LabelSelector) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver_Affinity_PodAntiAffinity_PreferredDuringSchedulingIgnoredDuringExecutionItem_PodAffinityTerm struct {
	LabelSelector *Cilium1163Values_Clustermesh_Apiserver_Affinity_PodAntiAffinity_PreferredDuringSchedulingIgnoredDuringExecutionItem_PodAffinityTerm_LabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty"`
	// Default value in yaml: kubernetes.io/hostname
	TopologyKey *string `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Affinity_PodAntiAffinity_PreferredDuringSchedulingIgnoredDuringExecutionItem_PodAffinityTerm) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver_Affinity_PodAntiAffinity_PreferredDuringSchedulingIgnoredDuringExecutionItem struct {
	// Default value in yaml: 100
	Weight          *int64                                                                                                                               `json:"weight,omitempty" yaml:"weight,omitempty"`
	PodAffinityTerm *Cilium1163Values_Clustermesh_Apiserver_Affinity_PodAntiAffinity_PreferredDuringSchedulingIgnoredDuringExecutionItem_PodAffinityTerm `json:"podAffinityTerm,omitempty" yaml:"podAffinityTerm,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Affinity_PodAntiAffinity_PreferredDuringSchedulingIgnoredDuringExecutionItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver_Affinity_PodAntiAffinity struct {
	PreferredDuringSchedulingIgnoredDuringExecution *[]Cilium1163Values_Clustermesh_Apiserver_Affinity_PodAntiAffinity_PreferredDuringSchedulingIgnoredDuringExecutionItem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Affinity_PodAntiAffinity) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Affinity for clustermesh.apiserver
type Cilium1163Values_Clustermesh_Apiserver_Affinity struct {
	PodAntiAffinity *Cilium1163Values_Clustermesh_Apiserver_Affinity_PodAntiAffinity `json:"podAntiAffinity,omitempty" yaml:"podAntiAffinity,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Affinity) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Node labels for pod assignment
//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
type Cilium1163Values_Clustermesh_Apiserver_NodeSelector struct {
	// Default value in yaml: linux
	KubernetesIoos *string `json:"kubernetes.io/os,omitempty" yaml:"kubernetes.io/os,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_NodeSelector) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver_UpdateStrategy_RollingUpdate struct {
	//  @schema
	//  type: [integer, string]
	//  @schema
	//
	// Default value in yaml: 1
	MaxSurge *int64 `json:"maxSurge,omitempty" yaml:"maxSurge,omitempty"`
	//  @schema
	//  type: [integer, string]
	//  @schema
	//
	// Default value in yaml: 0
	MaxUnavailable *int64 `json:"maxUnavailable,omitempty" yaml:"maxUnavailable,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_UpdateStrategy_RollingUpdate) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- clustermesh-apiserver update strategy
type Cilium1163Values_Clustermesh_Apiserver_UpdateStrategy struct {
	// Default value in yaml: RollingUpdate
	Type          *string                                                              `json:"type,omitempty" yaml:"type,omitempty"`
	RollingUpdate *Cilium1163Values_Clustermesh_Apiserver_UpdateStrategy_RollingUpdate `json:"rollingUpdate,omitempty" yaml:"rollingUpdate,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_UpdateStrategy) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure automatic TLS certificates generation.
//  A Kubernetes CronJob is used the generate any
//  certificates not provided by the user at installation
//  time.
type Cilium1163Values_Clustermesh_Apiserver_Tls_Auto struct {
	//  -- When set to true, automatically generate a CA and certificates to
	//  enable mTLS between clustermesh-apiserver and external workload instances.
	//  If set to false, the certs to be provided by setting appropriate values below.
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  Sets the method to auto-generate certificates. Supported values:
	//  - helm:         This method uses Helm to generate all certificates.
	//  - cronJob:      This method uses a Kubernetes CronJob the generate any
	//                  certificates not provided by the user at installation
	//                  time.
	//  - certmanager:  This method use cert-manager to generate & rotate certificates.
	//
	// Default value in yaml: helm
	Method *string `json:"method,omitempty" yaml:"method,omitempty"`
	//  -- Generated certificates validity duration in days.
	//  -- Schedule for certificates regeneration (regardless of their expiration date).
	//  Only used if method is "cronJob". If nil, then no recurring job will be created.
	//  Instead, only the one-shot job is deployed to generate the certificates at
	//  installation time.
	//
	//  Due to the out-of-band distribution of client certs to external workloads the
	//  CA is (re)regenerated only if it is not provided as a helm value and the k8s
	//  secret is manually deleted.
	//
	//  Defaults to none. Commented syntax gives midnight of the first day of every
	//  fourth month. For syntax, see
	//  https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#schedule-syntax
	//  schedule: "0 0 1 */4 *"
	//
	// Default value in yaml: 1095
	CertValidityDuration *int64 `json:"certValidityDuration,omitempty" yaml:"certValidityDuration,omitempty"`
	//  [Example]
	//  certManagerIssuerRef:
	//    group: cert-manager.io
	//    kind: ClusterIssuer
	//    name: ca-issuer
	//  -- certmanager issuer used when clustermesh.apiserver.tls.auto.method=certmanager.
	CertManagerIssuerRef *map[string]any `json:"certManagerIssuerRef,omitempty" yaml:"certManagerIssuerRef,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Tls_Auto) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- base64 encoded PEM values for the clustermesh-apiserver server certificate and private key.
//  Used if 'auto' is not enabled.
type Cilium1163Values_Clustermesh_Apiserver_Tls_Server struct {
	Cert *string `json:"cert,omitempty" yaml:"cert,omitempty"`
	Key  *string `json:"key,omitempty" yaml:"key,omitempty"`
	//  -- Extra DNS names added to certificate when it's auto generated
	ExtraDnsNames *[]any `json:"extraDnsNames,omitempty" yaml:"extraDnsNames,omitempty"`
	//  -- Extra IP addresses added to certificate when it's auto generated
	ExtraIpAddresses *[]any `json:"extraIpAddresses,omitempty" yaml:"extraIpAddresses,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Tls_Server) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- base64 encoded PEM values for the clustermesh-apiserver admin certificate and private key.
//  Used if 'auto' is not enabled.
type Cilium1163Values_Clustermesh_Apiserver_Tls_Admin struct {
	Cert *string `json:"cert,omitempty" yaml:"cert,omitempty"`
	Key  *string `json:"key,omitempty" yaml:"key,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Tls_Admin) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- base64 encoded PEM values for the clustermesh-apiserver client certificate and private key.
//  Used if 'auto' is not enabled.
type Cilium1163Values_Clustermesh_Apiserver_Tls_Client struct {
	Cert *string `json:"cert,omitempty" yaml:"cert,omitempty"`
	Key  *string `json:"key,omitempty" yaml:"key,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Tls_Client) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- base64 encoded PEM values for the clustermesh-apiserver remote cluster certificate and private key.
//  Used if 'auto' is not enabled.
type Cilium1163Values_Clustermesh_Apiserver_Tls_Remote struct {
	Cert *string `json:"cert,omitempty" yaml:"cert,omitempty"`
	Key  *string `json:"key,omitempty" yaml:"key,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Tls_Remote) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver_Tls struct {
	//  -- Configure the clustermesh authentication mode.
	//  Supported values:
	//  - legacy:     All clusters access remote clustermesh instances with the same
	//                username (i.e., remote). The "remote" certificate must be
	//                generated with CN=remote if provided manually.
	//  - migration:  Intermediate mode required to upgrade from legacy to cluster
	//                (and vice versa) with no disruption. Specifically, it enables
	//                the creation of the per-cluster usernames, while still using
	//                the common one for authentication. The "remote" certificate must
	//                be generated with CN=remote if provided manually (same as legacy).
	//  - cluster:    Each cluster accesses remote etcd instances with a username
	//                depending on the local cluster name (i.e., remote-<cluster-name>).
	//                The "remote" certificate must be generated with CN=remote-<cluster-name>
	//                if provided manually. Cluster mode is meaningful only when the same
	//                CA is shared across all clusters part of the mesh.
	//
	// Default value in yaml: legacy
	AuthMode *string `json:"authMode,omitempty" yaml:"authMode,omitempty"`
	//  -- Allow users to provide their own certificates
	//  Users may need to provide their certificates using
	//  a mechanism that requires they provide their own secrets.
	//  This setting does not apply to any of the auto-generated
	//  mechanisms below, it only restricts the creation of secrets
	//  via the `tls-provided` templates.
	//
	// Default value in yaml: true
	EnableSecrets *bool `json:"enableSecrets,omitempty" yaml:"enableSecrets,omitempty"`
	//  -- Configure automatic TLS certificates generation.
	//  A Kubernetes CronJob is used the generate any
	//  certificates not provided by the user at installation
	//  time.
	Auto *Cilium1163Values_Clustermesh_Apiserver_Tls_Auto `json:"auto,omitempty" yaml:"auto,omitempty"`
	//  -- base64 encoded PEM values for the clustermesh-apiserver server certificate and private key.
	//  Used if 'auto' is not enabled.
	Server *Cilium1163Values_Clustermesh_Apiserver_Tls_Server `json:"server,omitempty" yaml:"server,omitempty"`
	//  -- base64 encoded PEM values for the clustermesh-apiserver admin certificate and private key.
	//  Used if 'auto' is not enabled.
	Admin *Cilium1163Values_Clustermesh_Apiserver_Tls_Admin `json:"admin,omitempty" yaml:"admin,omitempty"`
	//  -- base64 encoded PEM values for the clustermesh-apiserver client certificate and private key.
	//  Used if 'auto' is not enabled.
	Client *Cilium1163Values_Clustermesh_Apiserver_Tls_Client `json:"client,omitempty" yaml:"client,omitempty"`
	//  -- base64 encoded PEM values for the clustermesh-apiserver remote cluster certificate and private key.
	//  Used if 'auto' is not enabled.
	Remote *Cilium1163Values_Clustermesh_Apiserver_Tls_Remote `json:"remote,omitempty" yaml:"remote,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Tls) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver_Metrics_Kvstoremesh struct {
	//  -- Enables exporting KVStoreMesh metrics in OpenMetrics format.
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Configure the port the KVStoreMesh metric server listens on.
	//
	// Default value in yaml: 9964
	Port *int64 `json:"port,omitempty" yaml:"port,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Metrics_Kvstoremesh) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver_Metrics_Etcd struct {
	//  -- Enables exporting etcd metrics in OpenMetrics format.
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Set level of detail for etcd metrics; specify 'extensive' to include server side gRPC histogram metrics.
	//
	// Default value in yaml: basic
	Mode *string `json:"mode,omitempty" yaml:"mode,omitempty"`
	//  -- Configure the port the etcd metric server listens on.
	//
	// Default value in yaml: 9963
	Port *int64 `json:"port,omitempty" yaml:"port,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Metrics_Etcd) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver_Metrics_ServiceMonitor_Kvstoremesh struct {
	//  -- Interval for scrape metrics (KVStoreMesh metrics)
	//
	// Default value in yaml: 10s
	Interval *string `json:"interval,omitempty" yaml:"interval,omitempty"`
	//  @schema
	//  type: [null, array]
	//  @schema
	//  -- Relabeling configs for the ServiceMonitor clustermesh-apiserver (KVStoreMesh metrics)
	//
	// Default value in yaml: ~
	Relabelings *string `json:"relabelings,omitempty" yaml:"relabelings,omitempty"`
	//  @schema
	//  type: [null, array]
	//  @schema
	//  -- Metrics relabeling configs for the ServiceMonitor clustermesh-apiserver (KVStoreMesh metrics)
	//
	// Default value in yaml: ~
	MetricRelabelings *string `json:"metricRelabelings,omitempty" yaml:"metricRelabelings,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Metrics_ServiceMonitor_Kvstoremesh) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver_Metrics_ServiceMonitor_Etcd struct {
	//  -- Interval for scrape metrics (etcd metrics)
	//
	// Default value in yaml: 10s
	Interval *string `json:"interval,omitempty" yaml:"interval,omitempty"`
	//  @schema
	//  type: [null, array]
	//  @schema
	//  -- Relabeling configs for the ServiceMonitor clustermesh-apiserver (etcd metrics)
	//
	// Default value in yaml: ~
	Relabelings *string `json:"relabelings,omitempty" yaml:"relabelings,omitempty"`
	//  @schema
	//  type: [null, array]
	//  @schema
	//  -- Metrics relabeling configs for the ServiceMonitor clustermesh-apiserver (etcd metrics)
	//
	// Default value in yaml: ~
	MetricRelabelings *string `json:"metricRelabelings,omitempty" yaml:"metricRelabelings,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Metrics_ServiceMonitor_Etcd) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver_Metrics_ServiceMonitor struct {
	//  -- Enable service monitor.
	//  This requires the prometheus CRDs to be available (see https://github.com/prometheus-operator/prometheus-operator/blob/main/example/prometheus-operator-crd/monitoring.coreos.com_servicemonitors.yaml)
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Labels to add to ServiceMonitor clustermesh-apiserver
	Labels *map[string]any `json:"labels,omitempty" yaml:"labels,omitempty"`
	//  -- Annotations to add to ServiceMonitor clustermesh-apiserver
	//  -- Specify the Kubernetes namespace where Prometheus expects to find
	//  service monitors configured.
	//  namespace: ""
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- Interval for scrape metrics (apiserver metrics)
	//
	// Default value in yaml: 10s
	Interval *string `json:"interval,omitempty" yaml:"interval,omitempty"`
	//  @schema
	//  type: [null, array]
	//  @schema
	//  -- Relabeling configs for the ServiceMonitor clustermesh-apiserver (apiserver metrics)
	//
	// Default value in yaml: ~
	Relabelings *string `json:"relabelings,omitempty" yaml:"relabelings,omitempty"`
	//  @schema
	//  type: [null, array]
	//  @schema
	//  -- Metrics relabeling configs for the ServiceMonitor clustermesh-apiserver (apiserver metrics)
	//
	// Default value in yaml: ~
	MetricRelabelings *string                                                                    `json:"metricRelabelings,omitempty" yaml:"metricRelabelings,omitempty"`
	Kvstoremesh       *Cilium1163Values_Clustermesh_Apiserver_Metrics_ServiceMonitor_Kvstoremesh `json:"kvstoremesh,omitempty" yaml:"kvstoremesh,omitempty"`
	Etcd              *Cilium1163Values_Clustermesh_Apiserver_Metrics_ServiceMonitor_Etcd        `json:"etcd,omitempty" yaml:"etcd,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Metrics_ServiceMonitor) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  clustermesh-apiserver Prometheus metrics configuration
type Cilium1163Values_Clustermesh_Apiserver_Metrics struct {
	//  -- Enables exporting apiserver metrics in OpenMetrics format.
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Configure the port the apiserver metric server listens on.
	//
	// Default value in yaml: 9962
	Port           *int64                                                         `json:"port,omitempty" yaml:"port,omitempty"`
	Kvstoremesh    *Cilium1163Values_Clustermesh_Apiserver_Metrics_Kvstoremesh    `json:"kvstoremesh,omitempty" yaml:"kvstoremesh,omitempty"`
	Etcd           *Cilium1163Values_Clustermesh_Apiserver_Metrics_Etcd           `json:"etcd,omitempty" yaml:"etcd,omitempty"`
	ServiceMonitor *Cilium1163Values_Clustermesh_Apiserver_Metrics_ServiceMonitor `json:"serviceMonitor,omitempty" yaml:"serviceMonitor,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver_Metrics) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Clustermesh_Apiserver struct {
	//  -- Clustermesh API server image.
	Image *Cilium1163Values_Clustermesh_Apiserver_Image `json:"image,omitempty" yaml:"image,omitempty"`
	//  -- TCP port for the clustermesh-apiserver health API.
	//
	// Default value in yaml: 9880
	HealthPort *int64 `json:"healthPort,omitempty" yaml:"healthPort,omitempty"`
	//  -- Configuration for the clustermesh-apiserver readiness probe.
	ReadinessProbe *map[string]any                                     `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty"`
	Etcd           *Cilium1163Values_Clustermesh_Apiserver_Etcd        `json:"etcd,omitempty" yaml:"etcd,omitempty"`
	Kvstoremesh    *Cilium1163Values_Clustermesh_Apiserver_Kvstoremesh `json:"kvstoremesh,omitempty" yaml:"kvstoremesh,omitempty"`
	Service        *Cilium1163Values_Clustermesh_Apiserver_Service     `json:"service,omitempty" yaml:"service,omitempty"`
	//  -- Number of replicas run for the clustermesh-apiserver deployment.
	//
	// Default value in yaml: 1
	Replicas *int64 `json:"replicas,omitempty" yaml:"replicas,omitempty"`
	//  -- lifecycle setting for the apiserver container
	Lifecycle *map[string]any `json:"lifecycle,omitempty" yaml:"lifecycle,omitempty"`
	//  -- terminationGracePeriodSeconds for the clustermesh-apiserver deployment
	//
	// Default value in yaml: 30
	TerminationGracePeriodSeconds *int64 `json:"terminationGracePeriodSeconds,omitempty" yaml:"terminationGracePeriodSeconds,omitempty"`
	//  -- Additional clustermesh-apiserver arguments.
	ExtraArgs *[]any `json:"extraArgs,omitempty" yaml:"extraArgs,omitempty"`
	//  -- Additional clustermesh-apiserver environment variables.
	ExtraEnv *[]any `json:"extraEnv,omitempty" yaml:"extraEnv,omitempty"`
	//  -- Additional clustermesh-apiserver volumes.
	ExtraVolumes *[]any `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty"`
	//  -- Additional clustermesh-apiserver volumeMounts.
	ExtraVolumeMounts *[]any `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty"`
	//  -- Security context to be added to clustermesh-apiserver containers
	SecurityContext *Cilium1163Values_Clustermesh_Apiserver_SecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`
	//  -- Security context to be added to clustermesh-apiserver pods
	PodSecurityContext *Cilium1163Values_Clustermesh_Apiserver_PodSecurityContext `json:"podSecurityContext,omitempty" yaml:"podSecurityContext,omitempty"`
	//  -- Annotations to be added to clustermesh-apiserver pods
	PodAnnotations *map[string]any `json:"podAnnotations,omitempty" yaml:"podAnnotations,omitempty"`
	//  -- Labels to be added to clustermesh-apiserver pods
	PodLabels *map[string]any `json:"podLabels,omitempty" yaml:"podLabels,omitempty"`
	//  PodDisruptionBudget settings
	PodDisruptionBudget *Cilium1163Values_Clustermesh_Apiserver_PodDisruptionBudget `json:"podDisruptionBudget,omitempty" yaml:"podDisruptionBudget,omitempty"`
	//  -- Resource requests and limits for the clustermesh-apiserver
	//    requests:
	//      cpu: 100m
	//      memory: 64Mi
	//    limits:
	//      cpu: 1000m
	//      memory: 1024M
	Resources *map[string]any `json:"resources,omitempty" yaml:"resources,omitempty"`
	//  -- Affinity for clustermesh.apiserver
	Affinity *Cilium1163Values_Clustermesh_Apiserver_Affinity `json:"affinity,omitempty" yaml:"affinity,omitempty"`
	//  -- Pod topology spread constraints for clustermesh-apiserver
	//    - maxSkew: 1
	//      topologyKey: topology.kubernetes.io/zone
	//      whenUnsatisfiable: DoNotSchedule
	TopologySpreadConstraints *[]any `json:"topologySpreadConstraints,omitempty" yaml:"topologySpreadConstraints,omitempty"`
	//  -- Node labels for pod assignment
	//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
	NodeSelector *Cilium1163Values_Clustermesh_Apiserver_NodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty"`
	//  -- Node tolerations for pod assignment on nodes with taints
	//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
	Tolerations *[]any `json:"tolerations,omitempty" yaml:"tolerations,omitempty"`
	//  -- clustermesh-apiserver update strategy
	UpdateStrategy *Cilium1163Values_Clustermesh_Apiserver_UpdateStrategy `json:"updateStrategy,omitempty" yaml:"updateStrategy,omitempty"`
	//  -- The priority class to use for clustermesh-apiserver
	PriorityClassName *string                                     `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty"`
	Tls               *Cilium1163Values_Clustermesh_Apiserver_Tls `json:"tls,omitempty" yaml:"tls,omitempty"`
	//  clustermesh-apiserver Prometheus metrics configuration
	Metrics *Cilium1163Values_Clustermesh_Apiserver_Metrics `json:"metrics,omitempty" yaml:"metrics,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh_Apiserver) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  disableEnvoyVersionCheck removes the check for Envoy, which can be useful
//  on AArch64 as the images do not currently ship a version of Envoy.
// disableEnvoyVersionCheck: false
type Cilium1163Values_Clustermesh struct {
	//  -- Deploy clustermesh-apiserver for clustermesh
	//
	// Default value in yaml: false
	UseApiserver *bool `json:"useAPIServer,omitempty" yaml:"useAPIServer,omitempty"`
	//  -- The maximum number of clusters to support in a ClusterMesh. This value
	//  cannot be changed on running clusters, and all clusters in a ClusterMesh
	//  must be configured with the same value. Values > 255 will decrease the
	//  maximum allocatable cluster-local identities.
	//  Supported values are 255 and 511.
	//
	// Default value in yaml: 255
	MaxConnectedClusters *int64 `json:"maxConnectedClusters,omitempty" yaml:"maxConnectedClusters,omitempty"`
	//  -- Enable the synchronization of Kubernetes EndpointSlices corresponding to
	//  the remote endpoints of appropriately-annotated global services through ClusterMesh
	//
	// Default value in yaml: false
	EnableEndpointSliceSynchronization *bool `json:"enableEndpointSliceSynchronization,omitempty" yaml:"enableEndpointSliceSynchronization,omitempty"`
	//  -- Enable Multi-Cluster Services API support
	//
	// Default value in yaml: false
	EnableMcsapisupport *bool `json:"enableMCSAPISupport,omitempty" yaml:"enableMCSAPISupport,omitempty"`
	//  -- Annotations to be added to all top-level clustermesh objects (resources under templates/clustermesh-apiserver and templates/clustermesh-config)
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- Clustermesh explicit configuration.
	Config    *Cilium1163Values_Clustermesh_Config    `json:"config,omitempty" yaml:"config,omitempty"`
	Apiserver *Cilium1163Values_Clustermesh_Apiserver `json:"apiserver,omitempty" yaml:"apiserver,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Clustermesh) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure external workloads support
type Cilium1163Values_ExternalWorkloads struct {
	//  -- Enable support for external workloads, such as VMs (false by default).
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_ExternalWorkloads) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Cgroup_AutoMount struct {
	//  -- Enable auto mount of cgroup2 filesystem.
	//  When `autoMount` is enabled, cgroup2 filesystem is mounted at
	//  `cgroup.hostRoot` path on the underlying host and inside the cilium agent pod.
	//  If users disable `autoMount`, it's expected that users have mounted
	//  cgroup2 filesystem at the specified `cgroup.hostRoot` volume, and then the
	//  volume will be mounted inside the cilium agent pod at the same path.
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Init Container Cgroup Automount resource limits & requests
	//    limits:
	//      cpu: 100m
	//      memory: 128Mi
	//    requests:
	//      cpu: 100m
	//      memory: 128Mi
	Resources *map[string]any `json:"resources,omitempty" yaml:"resources,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Cgroup_AutoMount) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure cgroup related configuration
type Cilium1163Values_Cgroup struct {
	AutoMount *Cilium1163Values_Cgroup_AutoMount `json:"autoMount,omitempty" yaml:"autoMount,omitempty"`
	//  -- Configure cgroup root where cgroup2 filesystem is mounted on the host (see also: `cgroup.autoMount`)
	//
	// Default value in yaml: /run/cilium/cgroupv2
	HostRoot *string `json:"hostRoot,omitempty" yaml:"hostRoot,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Cgroup) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- Configure sysctl override described in #20072.
type Cilium1163Values_Sysctlfix struct {
	//  -- Enable the sysctl override. When enabled, the init container will mount the /proc of the host so that the `sysctlfix` utility can execute.
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Sysctlfix) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_DnsProxy struct {
	//  -- Timeout (in seconds) when closing the connection between the DNS proxy and the upstream server. If set to 0, the connection is closed immediately (with TCP RST). If set to -1, the connection is closed asynchronously in the background.
	//
	// Default value in yaml: 10
	SocketLingerTimeout *int64 `json:"socketLingerTimeout,omitempty" yaml:"socketLingerTimeout,omitempty"`
	//  -- DNS response code for rejecting DNS requests, available options are '[nameError refused]'.
	//
	// Default value in yaml: refused
	DnsRejectResponseCode *string `json:"dnsRejectResponseCode,omitempty" yaml:"dnsRejectResponseCode,omitempty"`
	//  -- Allow the DNS proxy to compress responses to endpoints that are larger than 512 Bytes or the EDNS0 option, if present.
	//
	// Default value in yaml: true
	EnableDnsCompression *bool `json:"enableDnsCompression,omitempty" yaml:"enableDnsCompression,omitempty"`
	//  -- Maximum number of IPs to maintain per FQDN name for each endpoint.
	//
	// Default value in yaml: 50
	EndpointMaxIpPerHostname *int64 `json:"endpointMaxIpPerHostname,omitempty" yaml:"endpointMaxIpPerHostname,omitempty"`
	//  -- Time during which idle but previously active connections with expired DNS lookups are still considered alive.
	//
	// Default value in yaml: 0s
	IdleConnectionGracePeriod *string `json:"idleConnectionGracePeriod,omitempty" yaml:"idleConnectionGracePeriod,omitempty"`
	//  -- Maximum number of IPs to retain for expired DNS lookups with still-active connections.
	//
	// Default value in yaml: 10000
	MaxDeferredConnectionDeletes *int64 `json:"maxDeferredConnectionDeletes,omitempty" yaml:"maxDeferredConnectionDeletes,omitempty"`
	//  -- The minimum time, in seconds, to use DNS data for toFQDNs policies. If
	//  the upstream DNS server returns a DNS record with a shorter TTL, Cilium
	//  overwrites the TTL with this value. Setting this value to zero means that
	//  Cilium will honor the TTLs returned by the upstream DNS server.
	//
	// Default value in yaml: 0
	MinTtl *int64 `json:"minTtl,omitempty" yaml:"minTtl,omitempty"`
	//  -- DNS cache data at this path is preloaded on agent startup.
	PreCache *string `json:"preCache,omitempty" yaml:"preCache,omitempty"`
	//  -- Global port on which the in-agent DNS proxy should listen. Default 0 is a OS-assigned port.
	//
	// Default value in yaml: 0
	ProxyPort *int64 `json:"proxyPort,omitempty" yaml:"proxyPort,omitempty"`
	//  -- The maximum time the DNS proxy holds an allowed DNS response before sending it along. Responses are sent as soon as the datapath is updated with the new IP information.
	//  -- DNS proxy operation mode (true/false, or unset to use version dependent defaults)
	//  enableTransparentMode: true
	//
	// Default value in yaml: 100ms
	ProxyResponseMaxDelay *string `json:"proxyResponseMaxDelay,omitempty" yaml:"proxyResponseMaxDelay,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_DnsProxy) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- SCTP Configuration Values
type Cilium1163Values_Sctp struct {
	//  -- Enable SCTP support. NOTE: Currently, SCTP support does not support rewriting ports or multihoming.
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Sctp) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- init container image of SPIRE agent and server
type Cilium1163Values_Authentication_Mutual_Spire_Install_InitImage struct {
	//  @schema
	//  type: [null, string]
	//  @schema
	//
	// Default value in yaml: ~
	Override *string `json:"override,omitempty" yaml:"override,omitempty"`
	// Default value in yaml: docker.io/library/busybox
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	// Default value in yaml: 1.36.1
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	// Default value in yaml: sha256:c230832bd3b0be59a6c47ed64294f9ce71e91b327957920b6929a0caa8353140
	Digest *string `json:"digest,omitempty" yaml:"digest,omitempty"`
	// Default value in yaml: true
	UseDigest *bool `json:"useDigest,omitempty" yaml:"useDigest,omitempty"`
	// Default value in yaml: IfNotPresent
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Authentication_Mutual_Spire_Install_InitImage) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- SPIRE agent image
type Cilium1163Values_Authentication_Mutual_Spire_Install_Agent_Image struct {
	//  @schema
	//  type: [null, string]
	//  @schema
	//
	// Default value in yaml: ~
	Override *string `json:"override,omitempty" yaml:"override,omitempty"`
	// Default value in yaml: ghcr.io/spiffe/spire-agent
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	// Default value in yaml: 1.9.6
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	// Default value in yaml: sha256:5106ac601272a88684db14daf7f54b9a45f31f77bb16a906bd5e87756ee7b97c
	Digest *string `json:"digest,omitempty" yaml:"digest,omitempty"`
	// Default value in yaml: true
	UseDigest *bool `json:"useDigest,omitempty" yaml:"useDigest,omitempty"`
	// Default value in yaml: IfNotPresent
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Authentication_Mutual_Spire_Install_Agent_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- SPIRE agent service account
type Cilium1163Values_Authentication_Mutual_Spire_Install_Agent_ServiceAccount struct {
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	// Default value in yaml: spire-agent
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Authentication_Mutual_Spire_Install_Agent_ServiceAccount) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- SPIRE agent tolerations configuration
//  By default it follows the same tolerations as the agent itself
//  to allow the Cilium agent on this node to connect to SPIRE.
//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
type Cilium1163Values_Authentication_Mutual_Spire_Install_Agent_TolerationsItem struct {
	// Default value in yaml: node.kubernetes.io/not-ready
	Key *string `json:"key,omitempty" yaml:"key,omitempty"`
	// Default value in yaml: NoSchedule
	Effect *string `json:"effect,omitempty" yaml:"effect,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Authentication_Mutual_Spire_Install_Agent_TolerationsItem) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  SPIRE agent configuration
type Cilium1163Values_Authentication_Mutual_Spire_Install_Agent struct {
	//  -- SPIRE agent image
	Image *Cilium1163Values_Authentication_Mutual_Spire_Install_Agent_Image `json:"image,omitempty" yaml:"image,omitempty"`
	//  -- SPIRE agent service account
	ServiceAccount *Cilium1163Values_Authentication_Mutual_Spire_Install_Agent_ServiceAccount `json:"serviceAccount,omitempty" yaml:"serviceAccount,omitempty"`
	//  -- SPIRE agent annotations
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- SPIRE agent labels
	Labels *map[string]any `json:"labels,omitempty" yaml:"labels,omitempty"`
	//  -- SPIRE Workload Attestor kubelet verification.
	//
	// Default value in yaml: true
	SkipKubeletVerification *bool `json:"skipKubeletVerification,omitempty" yaml:"skipKubeletVerification,omitempty"`
	//  -- SPIRE agent tolerations configuration
	//  By default it follows the same tolerations as the agent itself
	//  to allow the Cilium agent on this node to connect to SPIRE.
	//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
	Tolerations *[]Cilium1163Values_Authentication_Mutual_Spire_Install_Agent_TolerationsItem `json:"tolerations,omitempty" yaml:"tolerations,omitempty"`
	//  -- SPIRE agent affinity configuration
	Affinity *map[string]any `json:"affinity,omitempty" yaml:"affinity,omitempty"`
	//  -- SPIRE agent nodeSelector configuration
	//  ref: ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
	NodeSelector *map[string]any `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty"`
	//  -- Security context to be added to spire agent pods.
	//  SecurityContext holds pod-level security attributes and common container settings.
	//  ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
	PodSecurityContext *map[string]any `json:"podSecurityContext,omitempty" yaml:"podSecurityContext,omitempty"`
	//  -- Security context to be added to spire agent containers.
	//  SecurityContext holds pod-level security attributes and common container settings.
	//  ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
	SecurityContext *map[string]any `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Authentication_Mutual_Spire_Install_Agent) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- SPIRE server image
type Cilium1163Values_Authentication_Mutual_Spire_Install_Server_Image struct {
	//  @schema
	//  type: [null, string]
	//  @schema
	//
	// Default value in yaml: ~
	Override *string `json:"override,omitempty" yaml:"override,omitempty"`
	// Default value in yaml: ghcr.io/spiffe/spire-server
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty"`
	// Default value in yaml: 1.9.6
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty"`
	// Default value in yaml: sha256:59a0b92b39773515e25e68a46c40d3b931b9c1860bc445a79ceb45a805cab8b4
	Digest *string `json:"digest,omitempty" yaml:"digest,omitempty"`
	// Default value in yaml: true
	UseDigest *bool `json:"useDigest,omitempty" yaml:"useDigest,omitempty"`
	// Default value in yaml: IfNotPresent
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Authentication_Mutual_Spire_Install_Server_Image) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- SPIRE server service account
type Cilium1163Values_Authentication_Mutual_Spire_Install_Server_ServiceAccount struct {
	// Default value in yaml: true
	Create *bool `json:"create,omitempty" yaml:"create,omitempty"`
	// Default value in yaml: spire-server
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Authentication_Mutual_Spire_Install_Server_ServiceAccount) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  SPIRE server service configuration
type Cilium1163Values_Authentication_Mutual_Spire_Install_Server_Service struct {
	//  -- Service type for the SPIRE server service
	//
	// Default value in yaml: ClusterIP
	Type *string `json:"type,omitempty" yaml:"type,omitempty"`
	//  -- Annotations to be added to the SPIRE server service
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- Labels to be added to the SPIRE server service
	Labels *map[string]any `json:"labels,omitempty" yaml:"labels,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Authentication_Mutual_Spire_Install_Server_Service) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  SPIRE server datastorage configuration
type Cilium1163Values_Authentication_Mutual_Spire_Install_Server_DataStorage struct {
	//  -- Enable SPIRE server data storage
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Size of the SPIRE server data storage
	//
	// Default value in yaml: 1Gi
	Size *string `json:"size,omitempty" yaml:"size,omitempty"`
	//  -- Access mode of the SPIRE server data storage
	//
	// Default value in yaml: ReadWriteOnce
	AccessMode *string `json:"accessMode,omitempty" yaml:"accessMode,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- StorageClass of the SPIRE server data storage
	//
	// Default value in yaml: null
	StorageClass *string `json:"storageClass,omitempty" yaml:"storageClass,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Authentication_Mutual_Spire_Install_Server_DataStorage) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  -- SPIRE CA Subject
type Cilium1163Values_Authentication_Mutual_Spire_Install_Server_Ca_Subject struct {
	// Default value in yaml: US
	Country *string `json:"country,omitempty" yaml:"country,omitempty"`
	// Default value in yaml: SPIRE
	Organization *string `json:"organization,omitempty" yaml:"organization,omitempty"`
	// Default value in yaml: Cilium SPIRE CA
	CommonName *string `json:"commonName,omitempty" yaml:"commonName,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Authentication_Mutual_Spire_Install_Server_Ca_Subject) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  SPIRE CA configuration
type Cilium1163Values_Authentication_Mutual_Spire_Install_Server_Ca struct {
	//  -- SPIRE CA key type
	//  AWS requires the use of RSA. EC cryptography is not supported
	//
	// Default value in yaml: rsa-4096
	KeyType *string `json:"keyType,omitempty" yaml:"keyType,omitempty"`
	//  -- SPIRE CA Subject
	Subject *Cilium1163Values_Authentication_Mutual_Spire_Install_Server_Ca_Subject `json:"subject,omitempty" yaml:"subject,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Authentication_Mutual_Spire_Install_Server_Ca) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

type Cilium1163Values_Authentication_Mutual_Spire_Install_Server struct {
	//  -- SPIRE server image
	Image *Cilium1163Values_Authentication_Mutual_Spire_Install_Server_Image `json:"image,omitempty" yaml:"image,omitempty"`
	//  -- SPIRE server service account
	ServiceAccount *Cilium1163Values_Authentication_Mutual_Spire_Install_Server_ServiceAccount `json:"serviceAccount,omitempty" yaml:"serviceAccount,omitempty"`
	//  -- SPIRE server init containers
	InitContainers *[]any `json:"initContainers,omitempty" yaml:"initContainers,omitempty"`
	//  -- SPIRE server annotations
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- SPIRE server labels
	Labels *map[string]any `json:"labels,omitempty" yaml:"labels,omitempty"`
	//  SPIRE server service configuration
	Service *Cilium1163Values_Authentication_Mutual_Spire_Install_Server_Service `json:"service,omitempty" yaml:"service,omitempty"`
	//  -- SPIRE server affinity configuration
	Affinity *map[string]any `json:"affinity,omitempty" yaml:"affinity,omitempty"`
	//  -- SPIRE server nodeSelector configuration
	//  ref: ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
	NodeSelector *map[string]any `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty"`
	//  -- SPIRE server tolerations configuration
	//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
	Tolerations *[]any `json:"tolerations,omitempty" yaml:"tolerations,omitempty"`
	//  SPIRE server datastorage configuration
	DataStorage *Cilium1163Values_Authentication_Mutual_Spire_Install_Server_DataStorage `json:"dataStorage,omitempty" yaml:"dataStorage,omitempty"`
	//  -- Security context to be added to spire server pods.
	//  SecurityContext holds pod-level security attributes and common container settings.
	//  ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
	PodSecurityContext *map[string]any `json:"podSecurityContext,omitempty" yaml:"podSecurityContext,omitempty"`
	//  -- Security context to be added to spire server containers.
	//  SecurityContext holds pod-level security attributes and common container settings.
	//  ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
	SecurityContext *map[string]any `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`
	//  SPIRE CA configuration
	Ca *Cilium1163Values_Authentication_Mutual_Spire_Install_Server_Ca `json:"ca,omitempty" yaml:"ca,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Authentication_Mutual_Spire_Install_Server) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Settings to control the SPIRE installation and configuration
type Cilium1163Values_Authentication_Mutual_Spire_Install struct {
	//  -- Enable SPIRE installation.
	//  This will only take effect only if authentication.mutual.spire.enabled is true
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- SPIRE namespace to install into
	//
	// Default value in yaml: cilium-spire
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty"`
	//  -- SPIRE namespace already exists. Set to true if Helm should not create, manage, and import the SPIRE namespace.
	//
	// Default value in yaml: false
	ExistingNamespace *bool `json:"existingNamespace,omitempty" yaml:"existingNamespace,omitempty"`
	//  -- init container image of SPIRE agent and server
	InitImage *Cilium1163Values_Authentication_Mutual_Spire_Install_InitImage `json:"initImage,omitempty" yaml:"initImage,omitempty"`
	//  SPIRE agent configuration
	Agent  *Cilium1163Values_Authentication_Mutual_Spire_Install_Agent  `json:"agent,omitempty" yaml:"agent,omitempty"`
	Server *Cilium1163Values_Authentication_Mutual_Spire_Install_Server `json:"server,omitempty" yaml:"server,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Authentication_Mutual_Spire_Install) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Settings for SPIRE
type Cilium1163Values_Authentication_Mutual_Spire struct {
	//  -- Enable SPIRE integration (beta)
	//
	// Default value in yaml: false
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Annotations to be added to all top-level spire objects (resources under templates/spire)
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  Settings to control the SPIRE installation and configuration
	Install *Cilium1163Values_Authentication_Mutual_Spire_Install `json:"install,omitempty" yaml:"install,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- SPIRE server address used by Cilium Operator
	//
	//  If k8s Service DNS along with port number is used (e.g. <service-name>.<namespace>.svc(.*):<port-number> format),
	//  Cilium Operator will resolve its address by looking up the clusterIP from Service resource.
	//
	//  Example values: 10.0.0.1:8081, spire-server.cilium-spire.svc:8081
	//
	// Default value in yaml: ~
	ServerAddress *string `json:"serverAddress,omitempty" yaml:"serverAddress,omitempty"`
	//  -- SPIFFE trust domain to use for fetching certificates
	//
	// Default value in yaml: spiffe.cilium
	TrustDomain *string `json:"trustDomain,omitempty" yaml:"trustDomain,omitempty"`
	//  -- SPIRE socket path where the SPIRE delegated api agent is listening
	//
	// Default value in yaml: /run/spire/sockets/admin.sock
	AdminSocketPath *string `json:"adminSocketPath,omitempty" yaml:"adminSocketPath,omitempty"`
	//  -- SPIRE socket path where the SPIRE workload agent is listening.
	//  Applies to both the Cilium Agent and Operator
	//
	// Default value in yaml: /run/spire/sockets/agent/agent.sock
	AgentSocketPath *string `json:"agentSocketPath,omitempty" yaml:"agentSocketPath,omitempty"`
	//  -- SPIRE connection timeout
	//
	// Default value in yaml: 30s
	ConnectionTimeout *string `json:"connectionTimeout,omitempty" yaml:"connectionTimeout,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Authentication_Mutual_Spire) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Configuration for Cilium's service-to-service mutual authentication using TLS handshakes.
//  Note that this is not full mTLS support without also enabling encryption of some form.
//  Current encryption options are WireGuard or IPsec, configured in encryption block above.
type Cilium1163Values_Authentication_Mutual struct {
	//  -- Port on the agent where mutual authentication handshakes between agents will be performed
	//
	// Default value in yaml: 4250
	Port *int64 `json:"port,omitempty" yaml:"port,omitempty"`
	//  -- Timeout for connecting to the remote node TCP socket
	//
	// Default value in yaml: 5s
	ConnectTimeout *string `json:"connectTimeout,omitempty" yaml:"connectTimeout,omitempty"`
	//  Settings for SPIRE
	Spire *Cilium1163Values_Authentication_Mutual_Spire `json:"spire,omitempty" yaml:"spire,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Authentication_Mutual) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

//  Configuration for types of authentication for Cilium (beta)
type Cilium1163Values_Authentication struct {
	//  -- Enable authentication processing and garbage collection.
	//  Note that if disabled, policy enforcement will still block requests that require authentication.
	//  But the resulting authentication requests for these requests will not be processed, therefore the requests not be allowed.
	//
	// Default value in yaml: true
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	//  -- Buffer size of the channel Cilium uses to receive authentication events from the signal map.
	//
	// Default value in yaml: 1024
	QueueSize *int64 `json:"queueSize,omitempty" yaml:"queueSize,omitempty"`
	//  -- Buffer size of the channel Cilium uses to receive certificate expiration events from auth handlers.
	//
	// Default value in yaml: 1024
	RotatedIdentitiesQueueSize *int64 `json:"rotatedIdentitiesQueueSize,omitempty" yaml:"rotatedIdentitiesQueueSize,omitempty"`
	//  -- Interval for garbage collection of auth map entries.
	//
	// Default value in yaml: 5m0s
	GcInterval *string `json:"gcInterval,omitempty" yaml:"gcInterval,omitempty"`
	//  Configuration for Cilium's service-to-service mutual authentication using TLS handshakes.
	//  Note that this is not full mTLS support without also enabling encryption of some form.
	//  Current encryption options are WireGuard or IPsec, configured in encryption block above.
	Mutual *Cilium1163Values_Authentication_Mutual `json:"mutual,omitempty" yaml:"mutual,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values_Authentication) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

// Cilium1163Values represents the values of the cilium-1.16.3_values.yaml chart
type Cilium1163Values struct {
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- upgradeCompatibility helps users upgrading to ensure that the configMap for
	//  Cilium will not change critical values to ensure continued operation
	//  This flag is not required for new installations.
	//  For example: '1.7', '1.8', '1.9'
	//
	// Default value in yaml: null
	UpgradeCompatibility *string                 `json:"upgradeCompatibility,omitempty" yaml:"upgradeCompatibility,omitempty"`
	Debug                *Cilium1163Values_Debug `json:"debug,omitempty" yaml:"debug,omitempty"`
	Rbac                 *Cilium1163Values_Rbac  `json:"rbac,omitempty" yaml:"rbac,omitempty"`
	//  -- Configure image pull secrets for pulling container images
	//  - name: "image-pull-secret"
	ImagePullSecrets *[]any `json:"imagePullSecrets,omitempty" yaml:"imagePullSecrets,omitempty"`
	//  -- (string) Kubernetes config path
	//  @default -- `"~/.kube/config"`
	KubeConfigPath *string `json:"kubeConfigPath,omitempty" yaml:"kubeConfigPath,omitempty"`
	//  -- (string) Kubernetes service host - use "auto" for automatic lookup from the cluster-info ConfigMap (kubeadm-based clusters only)
	K8SServiceHost *string `json:"k8sServiceHost,omitempty" yaml:"k8sServiceHost,omitempty"`
	//  @schema
	//  type: [string, integer]
	//  @schema
	//  -- (string) Kubernetes service port
	K8SServicePort *string `json:"k8sServicePort,omitempty" yaml:"k8sServicePort,omitempty"`
	//  -- Configure the client side rate limit for the agent and operator
	//
	//  If the amount of requests to the Kubernetes API server exceeds the configured
	//  rate limit, the agent and operator will start to throttle requests by delaying
	//  them until there is budget or the request times out.
	K8SClientRateLimit *Cilium1163Values_K8SClientRateLimit `json:"k8sClientRateLimit,omitempty" yaml:"k8sClientRateLimit,omitempty"`
	Cluster            *Cilium1163Values_Cluster            `json:"cluster,omitempty" yaml:"cluster,omitempty"`
	//  -- Define serviceAccount names for components.
	//  @default -- Component's fully qualified name.
	ServiceAccounts *Cilium1163Values_ServiceAccounts `json:"serviceAccounts,omitempty" yaml:"serviceAccounts,omitempty"`
	//  -- Configure termination grace period for cilium-agent DaemonSet.
	//
	// Default value in yaml: 1
	TerminationGracePeriodSeconds *int64 `json:"terminationGracePeriodSeconds,omitempty" yaml:"terminationGracePeriodSeconds,omitempty"`
	//  -- Install the cilium agent resources.
	//
	// Default value in yaml: true
	Agent *bool `json:"agent,omitempty" yaml:"agent,omitempty"`
	//  -- Agent container name.
	//
	// Default value in yaml: cilium
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
	//  -- Roll out cilium agent pods automatically when configmap is updated.
	//
	// Default value in yaml: false
	RollOutCiliumPods *bool `json:"rollOutCiliumPods,omitempty" yaml:"rollOutCiliumPods,omitempty"`
	//  -- Agent container image.
	Image *Cilium1163Values_Image `json:"image,omitempty" yaml:"image,omitempty"`
	//  -- Affinity for cilium-agent.
	Affinity *Cilium1163Values_Affinity `json:"affinity,omitempty" yaml:"affinity,omitempty"`
	//  -- Node selector for cilium-agent.
	NodeSelector *Cilium1163Values_NodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty"`
	//  -- Node tolerations for agent scheduling to nodes with taints
	//  ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
	Tolerations *[]Cilium1163Values_TolerationsItem `json:"tolerations,omitempty" yaml:"tolerations,omitempty"`
	//  -- The priority class to use for cilium-agent.
	PriorityClassName *string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty"`
	//  -- DNS policy for Cilium agent pods.
	//  Ref: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
	DnsPolicy *string `json:"dnsPolicy,omitempty" yaml:"dnsPolicy,omitempty"`
	//  -- Additional containers added to the cilium DaemonSet.
	ExtraContainers *[]any `json:"extraContainers,omitempty" yaml:"extraContainers,omitempty"`
	//  -- Additional initContainers added to the cilium Daemonset.
	ExtraInitContainers *[]any `json:"extraInitContainers,omitempty" yaml:"extraInitContainers,omitempty"`
	//  -- Additional agent container arguments.
	ExtraArgs *[]any `json:"extraArgs,omitempty" yaml:"extraArgs,omitempty"`
	//  -- Additional agent container environment variables.
	ExtraEnv *[]any `json:"extraEnv,omitempty" yaml:"extraEnv,omitempty"`
	//  -- Additional agent hostPath mounts.
	//  - name: host-mnt-data
	//    mountPath: /host/mnt/data
	//    hostPath: /mnt/data
	//    hostPathType: Directory
	//    readOnly: true
	//    mountPropagation: HostToContainer
	ExtraHostPathMounts *[]any `json:"extraHostPathMounts,omitempty" yaml:"extraHostPathMounts,omitempty"`
	//  -- Additional agent volumes.
	ExtraVolumes *[]any `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty"`
	//  -- Additional agent volumeMounts.
	ExtraVolumeMounts *[]any `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty"`
	//  -- extraConfig allows you to specify additional configuration parameters to be
	//  included in the cilium-config configmap.
	//   my-config-a: "1234"
	//   my-config-b: |-
	//     test 1
	//     test 2
	//     test 3
	ExtraConfig *map[string]any `json:"extraConfig,omitempty" yaml:"extraConfig,omitempty"`
	//  -- Annotations to be added to all top-level cilium-agent objects (resources under templates/cilium-agent)
	Annotations *map[string]any `json:"annotations,omitempty" yaml:"annotations,omitempty"`
	//  -- Security Context for cilium-agent pods.
	PodSecurityContext *Cilium1163Values_PodSecurityContext `json:"podSecurityContext,omitempty" yaml:"podSecurityContext,omitempty"`
	//  -- Annotations to be added to agent pods
	PodAnnotations *map[string]any `json:"podAnnotations,omitempty" yaml:"podAnnotations,omitempty"`
	//  -- Labels to be added to agent pods
	PodLabels *map[string]any `json:"podLabels,omitempty" yaml:"podLabels,omitempty"`
	//  -- Agent resource limits & requests
	//  ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	//    limits:
	//      cpu: 4000m
	//      memory: 4Gi
	//    requests:
	//      cpu: 100m
	//      memory: 512Mi
	Resources *map[string]any `json:"resources,omitempty" yaml:"resources,omitempty"`
	//  -- resources & limits for the agent init containers
	InitResources   *map[string]any                   `json:"initResources,omitempty" yaml:"initResources,omitempty"`
	SecurityContext *Cilium1163Values_SecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`
	//  -- Cilium agent update strategy
	UpdateStrategy *Cilium1163Values_UpdateStrategy `json:"updateStrategy,omitempty" yaml:"updateStrategy,omitempty"`
	//  Configuration Values for cilium-agent
	Aksbyocni *Cilium1163Values_Aksbyocni `json:"aksbyocni,omitempty" yaml:"aksbyocni,omitempty"`
	//  @schema
	//  type: [boolean, string]
	//  @schema
	//  -- Enable installation of PodCIDR routes between worker
	//  nodes if worker nodes share a common L2 network segment.
	//
	// Default value in yaml: false
	AutoDirectNodeRoutes *bool `json:"autoDirectNodeRoutes,omitempty" yaml:"autoDirectNodeRoutes,omitempty"`
	//  -- Enable skipping of PodCIDR routes between worker
	//  nodes if the worker nodes are in a different L2 network segment.
	//
	// Default value in yaml: false
	DirectRoutingSkipUnreachable *bool `json:"directRoutingSkipUnreachable,omitempty" yaml:"directRoutingSkipUnreachable,omitempty"`
	//  -- Annotate k8s node upon initialization with Cilium's metadata.
	//
	// Default value in yaml: false
	AnnotateK8SNode *bool                          `json:"annotateK8sNode,omitempty" yaml:"annotateK8sNode,omitempty"`
	Azure           *Cilium1163Values_Azure        `json:"azure,omitempty" yaml:"azure,omitempty"`
	Alibabacloud    *Cilium1163Values_Alibabacloud `json:"alibabacloud,omitempty" yaml:"alibabacloud,omitempty"`
	//  -- Enable bandwidth manager to optimize TCP and UDP workloads and allow
	//  for rate-limiting traffic from individual Pods with EDT (Earliest Departure
	//  Time) through the "kubernetes.io/egress-bandwidth" Pod annotation.
	BandwidthManager *Cilium1163Values_BandwidthManager `json:"bandwidthManager,omitempty" yaml:"bandwidthManager,omitempty"`
	//  -- Configure standalone NAT46/NAT64 gateway
	Nat46X64Gateway *Cilium1163Values_Nat46X64Gateway `json:"nat46x64Gateway,omitempty" yaml:"nat46x64Gateway,omitempty"`
	//  -- EnableHighScaleIPcache enables the special ipcache mode for high scale
	//  clusters. The ipcache content will be reduced to the strict minimum and
	//  traffic will be encapsulated to carry security identities.
	HighScaleIpcache *Cilium1163Values_HighScaleIpcache `json:"highScaleIPcache,omitempty" yaml:"highScaleIPcache,omitempty"`
	//  -- Configure L2 announcements
	L2Announcements *Cilium1163Values_L2Announcements `json:"l2announcements,omitempty" yaml:"l2announcements,omitempty"`
	//  -- Configure L2 pod announcements
	L2PodAnnouncements *Cilium1163Values_L2PodAnnouncements `json:"l2podAnnouncements,omitempty" yaml:"l2podAnnouncements,omitempty"`
	//  -- Configure BGP
	Bgp *Cilium1163Values_Bgp `json:"bgp,omitempty" yaml:"bgp,omitempty"`
	//  -- This feature set enables virtual BGP routers to be created via
	//  CiliumBGPPeeringPolicy CRDs.
	BgpControlPlane *Cilium1163Values_BgpControlPlane `json:"bgpControlPlane,omitempty" yaml:"bgpControlPlane,omitempty"`
	PmtuDiscovery   *Cilium1163Values_PmtuDiscovery   `json:"pmtuDiscovery,omitempty" yaml:"pmtuDiscovery,omitempty"`
	Bpf             *Cilium1163Values_Bpf             `json:"bpf,omitempty" yaml:"bpf,omitempty"`
	//  -- Enable BPF clock source probing for more efficient tick retrieval.
	//
	// Default value in yaml: false
	BpfClockProbe *bool `json:"bpfClockProbe,omitempty" yaml:"bpfClockProbe,omitempty"`
	//  -- Clean all eBPF datapath state from the initContainer of the cilium-agent
	//  DaemonSet.
	//
	//  WARNING: Use with care!
	//
	// Default value in yaml: false
	CleanBpfState *bool `json:"cleanBpfState,omitempty" yaml:"cleanBpfState,omitempty"`
	//  -- Clean all local Cilium state from the initContainer of the cilium-agent
	//  DaemonSet. Implies cleanBpfState: true.
	//
	//  WARNING: Use with care!
	//
	// Default value in yaml: false
	CleanState *bool `json:"cleanState,omitempty" yaml:"cleanState,omitempty"`
	//  -- Wait for KUBE-PROXY-CANARY iptables rule to appear in "wait-for-kube-proxy"
	//  init container before launching cilium-agent.
	//  More context can be found in the commit message of below PR
	//  https://github.com/cilium/cilium/pull/20123
	//
	// Default value in yaml: false
	WaitForKubeProxy *bool                 `json:"waitForKubeProxy,omitempty" yaml:"waitForKubeProxy,omitempty"`
	Cni              *Cilium1163Values_Cni `json:"cni,omitempty" yaml:"cni,omitempty"`
	//  -- (string) Configure how frequently garbage collection should occur for the datapath
	//  connection tracking table.
	//  @default -- `"0s"`
	ConntrackGcinterval *string `json:"conntrackGCInterval,omitempty" yaml:"conntrackGCInterval,omitempty"`
	//  -- (string) Configure the maximum frequency for the garbage collection of the
	//  connection tracking table. Only affects the automatic computation for the frequency
	//  and has no effect when 'conntrackGCInterval' is set. This can be set to more frequently
	//  clean up unused identities created from ToFQDN policies.
	ConntrackGcmaxInterval *string `json:"conntrackGCMaxInterval,omitempty" yaml:"conntrackGCMaxInterval,omitempty"`
	//  -- (string) Configure timeout in which Cilium will exit if CRDs are not available
	//  @default -- `"5m"`
	CrdWaitTimeout *string `json:"crdWaitTimeout,omitempty" yaml:"crdWaitTimeout,omitempty"`
	//  -- Tail call hooks for custom eBPF programs.
	CustomCalls *Cilium1163Values_CustomCalls `json:"customCalls,omitempty" yaml:"customCalls,omitempty"`
	//  -- Specify which network interfaces can run the eBPF datapath. This means
	//  that a packet sent from a pod to a destination outside the cluster will be
	//  masqueraded (to an output device IPv4 address), if the output device runs the
	//  program. When not specified, probing will automatically detect devices that have
	//  a non-local route. This should be used only when autodetection is not suitable.
	//  devices: ""
	Daemon *Cilium1163Values_Daemon `json:"daemon,omitempty" yaml:"daemon,omitempty"`
	//  -- Enables experimental support for the detection of new and removed datapath
	//  devices. When devices change the eBPF datapath is reloaded and services updated.
	//  If "devices" is set then only those devices, or devices matching a wildcard will
	//  be considered.
	//
	//  This option has been deprecated and is a no-op.
	//
	// Default value in yaml: true
	EnableRuntimeDeviceDetection *bool `json:"enableRuntimeDeviceDetection,omitempty" yaml:"enableRuntimeDeviceDetection,omitempty"`
	//  -- Forces the auto-detection of devices, even if specific devices are explicitly listed
	//  -- Chains to ignore when installing feeder rules.
	//  disableIptablesFeederRules: ""
	//
	// Default value in yaml: false
	ForceDeviceDetection *bool `json:"forceDeviceDetection,omitempty" yaml:"forceDeviceDetection,omitempty"`
	//  -- Limit iptables-based egress masquerading to interface selector.
	//  egressMasqueradeInterfaces: ""
	//
	//  -- Enable setting identity mark for local traffic.
	//  enableIdentityMark: true
	//
	//  -- Enable Kubernetes EndpointSlice feature in Cilium if the cluster supports it.
	//  enableK8sEndpointSlice: true
	//
	//  -- Enable CiliumEndpointSlice feature (deprecated, please use `ciliumEndpointSlice.enabled` instead).
	//
	// Default value in yaml: false
	EnableCiliumEndpointSlice *bool                                 `json:"enableCiliumEndpointSlice,omitempty" yaml:"enableCiliumEndpointSlice,omitempty"`
	CiliumEndpointSlice       *Cilium1163Values_CiliumEndpointSlice `json:"ciliumEndpointSlice,omitempty" yaml:"ciliumEndpointSlice,omitempty"`
	EnvoyConfig               *Cilium1163Values_EnvoyConfig         `json:"envoyConfig,omitempty" yaml:"envoyConfig,omitempty"`
	IngressController         *Cilium1163Values_IngressController   `json:"ingressController,omitempty" yaml:"ingressController,omitempty"`
	GatewayApi                *Cilium1163Values_GatewayApi          `json:"gatewayAPI,omitempty" yaml:"gatewayAPI,omitempty"`
	//  -- Enables the fallback compatibility solution for when the xt_socket kernel
	//  module is missing and it is needed for the datapath L7 redirection to work
	//  properly. See documentation for details on when this can be disabled:
	//  https://docs.cilium.io/en/stable/operations/system_requirements/#linux-kernel.
	//
	// Default value in yaml: true
	EnableXtsocketFallback *bool                                    `json:"enableXTSocketFallback,omitempty" yaml:"enableXTSocketFallback,omitempty"`
	Encryption             *Cilium1163Values_Encryption             `json:"encryption,omitempty" yaml:"encryption,omitempty"`
	EndpointHealthChecking *Cilium1163Values_EndpointHealthChecking `json:"endpointHealthChecking,omitempty" yaml:"endpointHealthChecking,omitempty"`
	EndpointRoutes         *Cilium1163Values_EndpointRoutes         `json:"endpointRoutes,omitempty" yaml:"endpointRoutes,omitempty"`
	K8SNetworkPolicy       *Cilium1163Values_K8SNetworkPolicy       `json:"k8sNetworkPolicy,omitempty" yaml:"k8sNetworkPolicy,omitempty"`
	Eni                    *Cilium1163Values_Eni                    `json:"eni,omitempty" yaml:"eni,omitempty"`
	ExternalIps            *Cilium1163Values_ExternalIps            `json:"externalIPs,omitempty" yaml:"externalIPs,omitempty"`
	//  fragmentTracking enables IPv4 fragment tracking support in the datapath.
	//  fragmentTracking: true
	Gke *Cilium1163Values_Gke `json:"gke,omitempty" yaml:"gke,omitempty"`
	//  -- Enable connectivity health checking.
	//
	// Default value in yaml: true
	HealthChecking *bool `json:"healthChecking,omitempty" yaml:"healthChecking,omitempty"`
	//  -- TCP port for the agent health API. This is not the port for cilium-health.
	//
	// Default value in yaml: 9879
	HealthPort *int64 `json:"healthPort,omitempty" yaml:"healthPort,omitempty"`
	//  -- Configure the host firewall.
	HostFirewall *Cilium1163Values_HostFirewall `json:"hostFirewall,omitempty" yaml:"hostFirewall,omitempty"`
	HostPort     *Cilium1163Values_HostPort     `json:"hostPort,omitempty" yaml:"hostPort,omitempty"`
	//  -- Configure socket LB
	SocketLb *Cilium1163Values_SocketLb `json:"socketLB,omitempty" yaml:"socketLB,omitempty"`
	//  -- Configure certificate generation for Hubble integration.
	//  If hubble.tls.auto.method=cronJob, these values are used
	//  for the Kubernetes CronJob which will be scheduled regularly to
	//  (re)generate any certificates not provided manually.
	Certgen *Cilium1163Values_Certgen `json:"certgen,omitempty" yaml:"certgen,omitempty"`
	Hubble  *Cilium1163Values_Hubble  `json:"hubble,omitempty" yaml:"hubble,omitempty"`
	//  -- Method to use for identity allocation (`crd` or `kvstore`).
	//
	// Default value in yaml: crd
	IdentityAllocationMode *string `json:"identityAllocationMode,omitempty" yaml:"identityAllocationMode,omitempty"`
	//  -- (string) Time to wait before using new identity on endpoint identity change.
	//  @default -- `"5s"`
	IdentityChangeGracePeriod *string `json:"identityChangeGracePeriod,omitempty" yaml:"identityChangeGracePeriod,omitempty"`
	//  -- Install Iptables rules to skip netfilter connection tracking on all pod
	//  traffic. This option is only effective when Cilium is running in direct
	//  routing and full KPR mode. Moreover, this option cannot be enabled when Cilium
	//  is running in a managed Kubernetes environment or in a chained CNI setup.
	//
	// Default value in yaml: false
	InstallNoConntrackIptablesRules *bool                      `json:"installNoConntrackIptablesRules,omitempty" yaml:"installNoConntrackIptablesRules,omitempty"`
	Ipam                            *Cilium1163Values_Ipam     `json:"ipam,omitempty" yaml:"ipam,omitempty"`
	NodeIpam                        *Cilium1163Values_NodeIpam `json:"nodeIPAM,omitempty" yaml:"nodeIPAM,omitempty"`
	//  @schema
	//  type: [null, string]
	//  @schema
	//  -- The api-rate-limit option can be used to overwrite individual settings of the default configuration for rate limiting calls to the Cilium Agent API
	//
	// Default value in yaml: ~
	ApiRateLimit *string `json:"apiRateLimit,omitempty" yaml:"apiRateLimit,omitempty"`
	//  -- Configure the eBPF-based ip-masq-agent
	//  the config of nonMasqueradeCIDRs
	//  config:
	//    nonMasqueradeCIDRs: []
	//    masqLinkLocal: false
	//    masqLinkLocalIPv6: false
	IpMasqAgent *Cilium1163Values_IpMasqAgent `json:"ipMasqAgent,omitempty" yaml:"ipMasqAgent,omitempty"`
	//  iptablesLockTimeout defines the iptables "--wait" option when invoked from Cilium.
	//  iptablesLockTimeout: "5s"
	Ipv4 *Cilium1163Values_Ipv4 `json:"ipv4,omitempty" yaml:"ipv4,omitempty"`
	Ipv6 *Cilium1163Values_Ipv6 `json:"ipv6,omitempty" yaml:"ipv6,omitempty"`
	//  -- Configure Kubernetes specific configuration
	K8S *Cilium1163Values_K8S `json:"k8s,omitempty" yaml:"k8s,omitempty"`
	//  -- Keep the deprecated selector labels when deploying Cilium DaemonSet.
	//
	// Default value in yaml: false
	KeepDeprecatedLabels *bool `json:"keepDeprecatedLabels,omitempty" yaml:"keepDeprecatedLabels,omitempty"`
	//  -- Keep the deprecated probes when deploying Cilium DaemonSet
	//
	// Default value in yaml: false
	KeepDeprecatedProbes *bool                           `json:"keepDeprecatedProbes,omitempty" yaml:"keepDeprecatedProbes,omitempty"`
	StartupProbe         *Cilium1163Values_StartupProbe  `json:"startupProbe,omitempty" yaml:"startupProbe,omitempty"`
	LivenessProbe        *Cilium1163Values_LivenessProbe `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty"`
	//  -- Configure the kube-proxy replacement in Cilium BPF datapath
	//  Valid options are "true" or "false".
	//  ref: https://docs.cilium.io/en/stable/network/kubernetes/kubeproxy-free/
	// kubeProxyReplacement: "false"
	ReadinessProbe *Cilium1163Values_ReadinessProbe `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty"`
	//  -- healthz server bind address for the kube-proxy replacement.
	//  To enable set the value to '0.0.0.0:10256' for all ipv4
	//  addresses and this '[::]:10256' for all ipv6 addresses.
	//  By default it is disabled.
	KubeProxyReplacementHealthzBindAddr *string                            `json:"kubeProxyReplacementHealthzBindAddr,omitempty" yaml:"kubeProxyReplacementHealthzBindAddr,omitempty"`
	L2NeighDiscovery                    *Cilium1163Values_L2NeighDiscovery `json:"l2NeighDiscovery,omitempty" yaml:"l2NeighDiscovery,omitempty"`
	//  -- Enable Layer 7 network policy.
	//
	// Default value in yaml: true
	L7Proxy *bool `json:"l7Proxy,omitempty" yaml:"l7Proxy,omitempty"`
	//  -- Enable Local Redirect Policy.
	//  To include or exclude matched resources from cilium identity evaluation
	//  labels: ""
	//
	// Default value in yaml: false
	LocalRedirectPolicy *bool `json:"localRedirectPolicy,omitempty" yaml:"localRedirectPolicy,omitempty"`
	//  logOptions allows you to define logging options. eg:
	//  logOptions:
	//    format: json
	//
	//  -- Enables periodic logging of system load
	//
	// Default value in yaml: false
	LogSystemLoad *bool `json:"logSystemLoad,omitempty" yaml:"logSystemLoad,omitempty"`
	//  -- Configure maglev consistent hashing
	//  -- tableSize is the size (parameter M) for the backend table of one
	//  service entry
	//  tableSize:
	Maglev *map[string]any `json:"maglev,omitempty" yaml:"maglev,omitempty"`
	//  -- hashSeed is the cluster-wide base64 encoded seed for the hashing
	//  hashSeed:
	//
	//  -- Enables masquerading of IPv4 traffic leaving the node from endpoints.
	//
	// Default value in yaml: true
	EnableIpv4Masquerade *bool `json:"enableIPv4Masquerade,omitempty" yaml:"enableIPv4Masquerade,omitempty"`
	//  -- Enables masquerading of IPv6 traffic leaving the node from endpoints.
	//
	// Default value in yaml: true
	EnableIpv6Masquerade *bool `json:"enableIPv6Masquerade,omitempty" yaml:"enableIPv6Masquerade,omitempty"`
	//  -- Enables masquerading to the source of the route for traffic leaving the node from endpoints.
	//
	// Default value in yaml: false
	EnableMasqueradeRouteSource *bool `json:"enableMasqueradeRouteSource,omitempty" yaml:"enableMasqueradeRouteSource,omitempty"`
	//  -- Enables IPv4 BIG TCP support which increases maximum IPv4 GSO/GRO limits for nodes and pods
	//
	// Default value in yaml: false
	EnableIpv4Bigtcp *bool `json:"enableIPv4BIGTCP,omitempty" yaml:"enableIPv4BIGTCP,omitempty"`
	//  -- Enables IPv6 BIG TCP support which increases maximum IPv6 GSO/GRO limits for nodes and pods
	//
	// Default value in yaml: false
	EnableIpv6Bigtcp *bool                           `json:"enableIPv6BIGTCP,omitempty" yaml:"enableIPv6BIGTCP,omitempty"`
	Nat              *Cilium1163Values_Nat           `json:"nat,omitempty" yaml:"nat,omitempty"`
	EgressGateway    *Cilium1163Values_EgressGateway `json:"egressGateway,omitempty" yaml:"egressGateway,omitempty"`
	Vtep             *Cilium1163Values_Vtep          `json:"vtep,omitempty" yaml:"vtep,omitempty"`
	//  -- (string) Allows to explicitly specify the IPv4 CIDR for native routing.
	//  When specified, Cilium assumes networking for this CIDR is preconfigured and
	//  hands traffic destined for that range to the Linux network stack without
	//  applying any SNAT.
	//  Generally speaking, specifying a native routing CIDR implies that Cilium can
	//  depend on the underlying networking stack to route packets to their
	//  destination. To offer a concrete example, if Cilium is configured to use
	//  direct routing and the Kubernetes CIDR is included in the native routing CIDR,
	//  the user must configure the routes to reach pods, either manually or by
	//  setting the auto-direct-node-routes flag.
	Ipv4NativeRoutingCidr *string `json:"ipv4NativeRoutingCIDR,omitempty" yaml:"ipv4NativeRoutingCIDR,omitempty"`
	//  -- (string) Allows to explicitly specify the IPv6 CIDR for native routing.
	//  When specified, Cilium assumes networking for this CIDR is preconfigured and
	//  hands traffic destined for that range to the Linux network stack without
	//  applying any SNAT.
	//  Generally speaking, specifying a native routing CIDR implies that Cilium can
	//  depend on the underlying networking stack to route packets to their
	//  destination. To offer a concrete example, if Cilium is configured to use
	//  direct routing and the Kubernetes CIDR is included in the native routing CIDR,
	//  the user must configure the routes to reach pods, either manually or by
	//  setting the auto-direct-node-routes flag.
	Ipv6NativeRoutingCidr *string `json:"ipv6NativeRoutingCIDR,omitempty" yaml:"ipv6NativeRoutingCIDR,omitempty"`
	//  -- cilium-monitor sidecar.
	Monitor *Cilium1163Values_Monitor `json:"monitor,omitempty" yaml:"monitor,omitempty"`
	//  -- Configure service load balancing
	LoadBalancer *Cilium1163Values_LoadBalancer `json:"loadBalancer,omitempty" yaml:"loadBalancer,omitempty"`
	//  -- Configure N-S k8s service loadbalancing
	//  policyAuditMode: false
	NodePort *Cilium1163Values_NodePort `json:"nodePort,omitempty" yaml:"nodePort,omitempty"`
	//  -- The agent can be put into one of the three policy enforcement modes:
	//  default, always and never.
	//  ref: https://docs.cilium.io/en/stable/security/policy/intro/#policy-enforcement-modes
	//
	// Default value in yaml: default
	PolicyEnforcementMode *string `json:"policyEnforcementMode,omitempty" yaml:"policyEnforcementMode,omitempty"`
	//  @schema
	//  type: [null, string, array]
	//  @schema
	//  -- policyCIDRMatchMode is a list of entities that may be selected by CIDR selector.
	//  The possible value is "nodes".
	PolicyCidrmatchMode *string                 `json:"policyCIDRMatchMode,omitempty" yaml:"policyCIDRMatchMode,omitempty"`
	Pprof               *Cilium1163Values_Pprof `json:"pprof,omitempty" yaml:"pprof,omitempty"`
	//  -- Configure prometheus metrics on the configured port at /metrics
	Prometheus *Cilium1163Values_Prometheus `json:"prometheus,omitempty" yaml:"prometheus,omitempty"`
	//  -- Grafana dashboards for cilium-agent
	//  grafana can import dashboards based on the label and value
	//  ref: https://github.com/grafana/helm-charts/tree/main/charts/grafana#sidecar-for-dashboards
	Dashboards *Cilium1163Values_Dashboards `json:"dashboards,omitempty" yaml:"dashboards,omitempty"`
	//  Configure Cilium Envoy options.
	Envoy *Cilium1163Values_Envoy `json:"envoy,omitempty" yaml:"envoy,omitempty"`
	//  -- Enable/Disable use of node label based identity
	//
	// Default value in yaml: false
	NodeSelectorLabels *bool `json:"nodeSelectorLabels,omitempty" yaml:"nodeSelectorLabels,omitempty"`
	//  -- Enable resource quotas for priority classes used in the cluster.
	//  Need to document default
	//
	// sessionAffinity: false
	ResourceQuotas *Cilium1163Values_ResourceQuotas `json:"resourceQuotas,omitempty" yaml:"resourceQuotas,omitempty"`
	//  -- Do not run Cilium agent when running with clean mode. Useful to completely
	//  uninstall Cilium as it will stop Cilium from starting and create artifacts
	//  in the node.
	//
	// Default value in yaml: false
	SleepAfterInit *bool `json:"sleepAfterInit,omitempty" yaml:"sleepAfterInit,omitempty"`
	//  -- Enable check of service source ranges (currently, only for LoadBalancer).
	//
	// Default value in yaml: true
	SvcSourceRangeCheck *bool `json:"svcSourceRangeCheck,omitempty" yaml:"svcSourceRangeCheck,omitempty"`
	//  -- Synchronize Kubernetes nodes to kvstore and perform CNP GC.
	//
	// Default value in yaml: true
	SynchronizeK8SNodes *bool `json:"synchronizeK8sNodes,omitempty" yaml:"synchronizeK8sNodes,omitempty"`
	//  -- Configure TLS configuration in the agent.
	Tls *Cilium1163Values_Tls `json:"tls,omitempty" yaml:"tls,omitempty"`
	//  -- Tunneling protocol to use in tunneling mode and for ad-hoc tunnels.
	//  Possible values:
	//    - ""
	//    - vxlan
	//    - geneve
	//  @default -- `"vxlan"`
	TunnelProtocol *string `json:"tunnelProtocol,omitempty" yaml:"tunnelProtocol,omitempty"`
	//  -- Enable native-routing mode or tunneling mode.
	//  Possible values:
	//    - ""
	//    - native
	//    - tunnel
	//  @default -- `"tunnel"`
	RoutingMode *string `json:"routingMode,omitempty" yaml:"routingMode,omitempty"`
	//  -- Configure VXLAN and Geneve tunnel port.
	//  @default -- Port 8472 for VXLAN, Port 6081 for Geneve
	//
	// Default value in yaml: 0
	TunnelPort *int64 `json:"tunnelPort,omitempty" yaml:"tunnelPort,omitempty"`
	//  -- Configure what the response should be to traffic for a service without backends.
	//  "reject" only works on kernels >= 5.10, on lower kernels we fallback to "drop".
	//  Possible values:
	//   - reject (default)
	//   - drop
	//
	// Default value in yaml: reject
	ServiceNoBackendResponse *string `json:"serviceNoBackendResponse,omitempty" yaml:"serviceNoBackendResponse,omitempty"`
	//  -- Configure the underlying network MTU to overwrite auto-detected MTU.
	//  This value doesn't change the host network interface MTU i.e. eth0 or ens0.
	//  It changes the MTU for cilium_net@cilium_host, cilium_host@cilium_net,
	//  cilium_vxlan and lxc_health interfaces.
	//
	// Default value in yaml: 0
	Mtu *int64 `json:"MTU,omitempty" yaml:"MTU,omitempty"`
	//  -- Disable the usage of CiliumEndpoint CRD.
	//
	// Default value in yaml: false
	DisableEndpointCrd  *bool                                 `json:"disableEndpointCRD,omitempty" yaml:"disableEndpointCRD,omitempty"`
	WellKnownIdentities *Cilium1163Values_WellKnownIdentities `json:"wellKnownIdentities,omitempty" yaml:"wellKnownIdentities,omitempty"`
	Etcd                *Cilium1163Values_Etcd                `json:"etcd,omitempty" yaml:"etcd,omitempty"`
	Operator            *Cilium1163Values_Operator            `json:"operator,omitempty" yaml:"operator,omitempty"`
	Nodeinit            *Cilium1163Values_Nodeinit            `json:"nodeinit,omitempty" yaml:"nodeinit,omitempty"`
	Preflight           *Cilium1163Values_Preflight           `json:"preflight,omitempty" yaml:"preflight,omitempty"`
	//  -- Explicitly enable or disable priority class.
	//  .Capabilities.KubeVersion is unsettable in `helm template` calls,
	//  it depends on k8s libraries version that Helm was compiled against.
	//  This option allows to explicitly disable setting the priority class, which
	//  is useful for rendering charts for gke clusters in advance.
	//
	// Default value in yaml: true
	EnableCriticalPriorityClass *bool `json:"enableCriticalPriorityClass,omitempty" yaml:"enableCriticalPriorityClass,omitempty"`
	//  disableEnvoyVersionCheck removes the check for Envoy, which can be useful
	//  on AArch64 as the images do not currently ship a version of Envoy.
	// disableEnvoyVersionCheck: false
	Clustermesh *Cilium1163Values_Clustermesh `json:"clustermesh,omitempty" yaml:"clustermesh,omitempty"`
	//  -- Configure external workloads support
	ExternalWorkloads *Cilium1163Values_ExternalWorkloads `json:"externalWorkloads,omitempty" yaml:"externalWorkloads,omitempty"`
	//  -- Configure cgroup related configuration
	Cgroup *Cilium1163Values_Cgroup `json:"cgroup,omitempty" yaml:"cgroup,omitempty"`
	//  -- Configure sysctl override described in #20072.
	Sysctlfix *Cilium1163Values_Sysctlfix `json:"sysctlfix,omitempty" yaml:"sysctlfix,omitempty"`
	//  -- Configure whether to enable auto detect of terminating state for endpoints
	//  in order to support graceful termination.
	//  -- Configure whether to unload DNS policy rules on graceful shutdown
	//  dnsPolicyUnloadOnShutdown: false
	//
	// Default value in yaml: true
	EnableK8STerminatingEndpoint *bool `json:"enableK8sTerminatingEndpoint,omitempty" yaml:"enableK8sTerminatingEndpoint,omitempty"`
	//  -- Configure the key of the taint indicating that Cilium is not ready on the node.
	//  When set to a value starting with `ignore-taint.cluster-autoscaler.kubernetes.io/`, the Cluster Autoscaler will ignore the taint on its decisions, allowing the cluster to scale up.
	//
	// Default value in yaml: node.cilium.io/agent-not-ready
	AgentNotReadyTaintKey *string                    `json:"agentNotReadyTaintKey,omitempty" yaml:"agentNotReadyTaintKey,omitempty"`
	DnsProxy              *Cilium1163Values_DnsProxy `json:"dnsProxy,omitempty" yaml:"dnsProxy,omitempty"`
	//  -- SCTP Configuration Values
	Sctp *Cilium1163Values_Sctp `json:"sctp,omitempty" yaml:"sctp,omitempty"`
	//  Configuration for types of authentication for Cilium (beta)
	Authentication *Cilium1163Values_Authentication `json:"authentication,omitempty" yaml:"authentication,omitempty"`

	// UNSAFE. USE WITH CAUTION
	//
	// UNSAFE_MISC_FIELDS is a place for any additional fields that are not handled by the generator
	// The value of this field is going to be available as is in the output of `.ToMap()` method.
	// The fields in this map will overwrite other fields if their names match.
	// Field A has the same name as field B in the UNSAFE_MISC_FIELDS map, if the json format
	// of field A is exactly equal to the actual string literal of field B.
	// Example:
	// 	type Values struct {
	// 		FieldA string `json:"myField"`
	//		UNSAFE_MISC_FIELDS map[string]any
	// 	}
	// 	v := Values{
	//		FieldA:	"originalValue"
	// 		UNSAFE_MISC_FIELDS: map[string]any{
	// 			"myField": "newValue", // same as FieldA json format
	//			"anotherField": "anotherValue", // new field that will be included in the map output
	// 		}
	// 	}
	//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
	//
	// NOTE: Parent UNSAFE_MISC_FIELDS fields will overwrite the child fields if they have the same name.
	UNSAFE_MISC_FIELDS map[string]any `json:"-" yaml:"-"`
}

func (v *Cilium1163Values) ToMap() (map[string]any, error) {
	if v == nil {
		return map[string]any{}, nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
	}
	res := map[string]any{}
	if err := json.Unmarshal(b, &res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
	}

	// Handle nested structs to take care of the nested UNSAFE_MISC_FIELDS(s)
	val := reflect.ValueOf(v).Elem()
	typ := val.Type()
	for i := range val.NumField() {
		field := typ.Field(i)
		fieldValue := val.Field(i)

		fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
		if fieldName == "-" || fieldName == "" {
			fieldName = field.Name
		}

		// If the field is a nested struct, recurse
		if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
			if fieldValue.Elem().Kind() == reflect.Struct {
				toMapMethod := fieldValue.MethodByName("ToMap")
				if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
					result := toMapMethod.Call(nil)
					if len(result) != 2 {
						continue
					}
					if !result[1].IsNil() {
						err := result[1].Interface().(error)
						return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
					}

					toMapOutput := result[0].Interface()
					if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
						mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
					}
				} else {
					// ToMap method not found.
					continue
				}
			}
		} else if fieldValue.Kind() == reflect.Struct {
			toMapMethod := fieldValue.Addr().MethodByName("ToMap")
			if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
				result := toMapMethod.Call(nil)
				if len(result) != 2 {
					continue
				}
				if !result[1].IsNil() {
					err := result[1].Interface().(error)
					return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
				}

				toMapOutput := result[0].Interface()
				if outputMap, ok := toMapOutput.(map[string]interface{}); ok {
					mergeMapsCilium1163Values(res[fieldName].(map[string]any), outputMap)
				}
			} else {
				// ToMap method not found.
				continue
			}
		}
	}
	if v.UNSAFE_MISC_FIELDS != nil {
		mergeMapsCilium1163Values(res, v.UNSAFE_MISC_FIELDS)
	}
	return res, nil
}

// mergeMaps recursively merges map B into map A.
// The name is unique to prevent conflicts with other autogenerated files in this package.
func mergeMapsCilium1163Values(a, b map[string]any) {
	for key, bValue := range b {
		if aValue, ok := a[key]; ok {
			aMap, aIsMap := aValue.(map[string]any)
			bMap, bIsMap := bValue.(map[string]any)
			if aIsMap && bIsMap {
				mergeMapsCilium1163Values(aMap, bMap)
				continue
			}
		}
		a[key] = bValue
	}
}
