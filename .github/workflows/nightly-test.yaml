name: Nightly

on:
  schedule:
    - cron: "0 0 * * *" # Runs every midnight
  pull_request:
    paths:
      - .github/workflows/e2e-tests.yaml
      - .github/workflows/security-scan.yaml
      - .github/workflows/nightly-test.yaml

permissions:
  contents: read
  actions: read

jobs:
  test-integration:
    name: Integration
    strategy:
      matrix:
        os: ["ubuntu:22.04"]
        arch: ["amd64"]
        # TODO: Automatically fetch all supported releases.
        channel:
          [
            "latest/edge",
            "1.34-classic/edge",
            #"1.33-classic/edge",
            #"1.32-classic/edge",
          ]
      fail-fast: false
    uses: ./.github/workflows/e2e-tests.yaml
    with:
      arch: ${{ matrix.arch }}
      os: ${{ matrix.os }}
      channel: ${{ matrix.channel }}
      test-tags: "up_to_nightly"
      parallel: false
      upload-results: true


 #test-performance:
 #  name: Run performance tests for ${{ matrix.os }}-${{ matrix.arch }}
 #  strategy:
 #    matrix:
 #      os: ["ubuntu:22.04", "ubuntu:24.04"]
 #      arch: ["amd64", "arm64"]
 #  uses: ./.github/workflows/compare-performance.yaml
 #  with:
 #    arch: ${{ matrix.arch }}
 #    os: ${{ matrix.os }}
 #    channel-1: latest/edge
 #    channel-2: 1.32-classic/stable

  collect-results:
    name: Collect integration test results
    if: ${{ always() }}
    runs-on: ubuntu-24.04
    needs: [test-integration]
    outputs:
      matrix: ${{ steps.aggregate.outputs.matrix }}
    steps:
      - uses: actions/download-artifact@v4
      - run: |
          results=$(find . -type f -name 'result.json' -exec cat {} \; | jq -c --slurp .)
          echo "$results" > aggregated-results.json
          echo "matrix=$results" >> $GITHUB_OUTPUT
        id: aggregate
      - uses: actions/upload-artifact@v4
        with:
          name: aggregated-results
          path: aggregated-results.json

  Mattermost:
    name: Notify Mattermost
    # Notify on success or failure but only if the event is a scheduled run.
    # We don't want to ping people of failed PRs.
    # TODO revert before merge
    if: ${{ always() }} #&& github.event_name == 'schedule' }}
    # Note: Update results check below if you change the "needs" list.
    needs: [test-integration, collect-results]
    runs-on: ubuntu-latest
    steps:
      - name: Set current formatted date as env variable
        run: echo "FORMATTED_DATE=$(date +'%d/%m/%Y')" >> $GITHUB_ENV

      - name: Download integration test results
        uses: actions/download-artifact@v4
        with:
          name: aggregated-results

      - name: Aggregate per-channel results
        id: aggregate
        shell: bash
        run: |
          RESULTS_JSON=$(jq -s 'add' aggregated-results.json)
          MESSAGE=""

          channels=($(echo "$RESULTS_JSON" | jq -r '.[].channel' | sort -u))
          last_channel_index=$((${#channels[@]} - 1))

          for ci in "${!channels[@]}"; do
              channel="${channels[$ci]}"
              is_last_channel=$([ "$ci" -eq "$last_channel_index" ] && echo true || echo false)
              MESSAGE="${MESSAGE}\n* $channel"

              os_list=($(echo "$RESULTS_JSON" | jq -r --arg channel "$channel" '.[] | select(.channel==$channel) | .os' | sort -u))
              last_os_index=$((${#os_list[@]} - 1))

              for oi in "${!os_list[@]}"; do
                  os="${os_list[$oi]}"
                  is_last_os=$([ "$oi" -eq "$last_os_index" ] && echo true || echo false)
                  os_prefix=$([ "$is_last_os" = true ] && echo "└──" || echo "├──")
                  MESSAGE="${MESSAGE}\n    ${os_prefix} $os"

                  arch_list=($(echo "$RESULTS_JSON" | jq -r --arg channel "$channel" --arg os "$os" '.[] | select(.channel==$channel and .os==$os) | .arch' | sort -u))
                  last_arch_index=$((${#arch_list[@]} - 1))

                  for ai in "${!arch_list[@]}"; do
                      arch="${arch_list[$ai]}"
                      is_last_arch=$([ "$ai" -eq "$last_arch_index" ] && echo true || echo false)
                      arch_prefix=$([ "$is_last_arch" = true ] && echo "└──" || echo "├──")

                      ENTRY=$(echo "$RESULTS_JSON" | jq -r --arg channel "$channel" --arg os "$os" --arg arch "$arch" '[.[] | select(.channel==$channel and .os==$os and .arch==$arch)][0]')
                      STATUS=$(echo "$ENTRY" | jq -r '.status')
                      NUM_FAILED=$(echo "$ENTRY" | jq -r '.failed_tests // 0')

                      EMOJI=":white_check_mark:"
                      LABEL="Succeeded"
                      if [[ "$STATUS" != "success" ]]; then
                          EMOJI=":x:"
                          LABEL="Failed"
                      fi
                      RUN_LINK="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

                      if [ "$is_last_os" = true ]; then
                          indent="        "
                      else
                          indent="    │   "
                      fi

                      MESSAGE="${MESSAGE}\n${indent}${arch_prefix} $arch: $EMOJI$LABEL ($NUM_FAILED tests failed) [Run]($RUN_LINK)"
                  done
              done
          done

          echo -e "$MESSAGE"

          echo "MM_TEXT<<EOF" >> $GITHUB_ENV
          echo -e "$MESSAGE" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Notify Mattermost
        uses: mattermost/action-mattermost-notify@master
        with:
          MATTERMOST_WEBHOOK_URL: ${{ secrets.MATTERMOST_BOT_WEBHOOK_URL }}
          PAYLOAD: |
            {
              "attachments": [
                {
                  "fallback": "k8s-snap Nightly CI Status",
                  "color": ${{ fromJSON('{"success":"good","failure":"danger"}')[ (env.MM_TEXT != '' && contains(env.MM_TEXT, ':x:')) && 'failure' || 'success' ] }}
                  "title": "k8s-snap Nightly CI Status - ${{ env.FORMATTED_DATE }}",
                  "text": "${{ env.MM_TEXT }}"
                }
              ]
            }
