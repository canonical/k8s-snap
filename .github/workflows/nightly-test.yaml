name: Nightly

on:
  schedule:
    - cron: "0 0 * * *" # Runs every midnight
  pull_request:
    paths:
      - .github/workflows/e2e-tests.yaml
      - .github/workflows/security-scan.yaml
      - .github/workflows/nightly-test.yaml

permissions:
  contents: read

jobs:
  supported_releases:
    name: Prepare Test Configurations
    runs-on: ubuntu-latest
    outputs:
      integration_test_matrix: ${{ steps.generate_json.outputs.integration_matrix_config }}
      trivy_matrix: ${{ steps.generate_json.outputs.trivy_matrix }}
    steps:
      - uses: actions/checkout@v4
      - name: Generate Matrix Configurations
        id: generate_json
        run: |
          # Get stable channels like ["1.32-classic/stable", "1.33-classic/stable"]
          STABLE_CHANNELS_JSON_STR=$(python3 build-scripts/k8s_release.py --output json --as-channel supported_canonical_k8s_releases)

          # This includes stable channels + latest/edge
          ALL_CHANNELS=$(echo "$STABLE_CHANNELS_JSON_STR" | jq -c '. + ["latest/edge"]')

          OS_LIST='["ubuntu:22.04", "ubuntu:24.04"]'
          ARCH_LIST='["amd64", "arm64"]'
          INTEGRATION_MATRIX_CONFIG='[]'

          echo "Processing channels for integration matrix: $ALL_CHANNELS"
          # Iterate over ALL_CHANNELS to include latest/edge
          echo "$ALL_CHANNELS" | jq -r '.[]' | while IFS= read -r channel_str; do
            if [ -z "$channel_str" ]; then continue; fi

            checkout_ref_val=""
            if [[ "$channel_str" == latest/* ]]; then
              checkout_ref_val="main"
            else
              # Extracts VERSION from 'VERSION-track/risk' or 'VERSION/risk'
              temp_val=$(echo "$channel_str" | cut -d'/' -f1) # e.g., "1.30-classic" or "1.32"
              version_part=$(echo "$temp_val" | cut -d'-' -f1) # e.g., "1.30" or "1.32"
              checkout_ref_val="release-$version_part"
            fi

            echo "$OS_LIST" | jq -r '.[]' | while IFS= read -r os_val; do
              if [ -z "$os_val" ]; then continue; fi
              echo "$ARCH_LIST" | jq -r '.[]' | while IFS= read -r arch_val; do
                if [ -z "$arch_val" ]; then continue; fi

                new_entry=$(jq -n \
                  --arg os "$os_val" \
                  --arg arch "$arch_val" \
                  --arg ch "$channel_str" \
                  --arg cr "$checkout_ref_val" \
                  '{os: $os, arch: $arch, channel: $ch, checkout_ref: $cr}')

                INTEGRATION_MATRIX_CONFIG=$(echo "$INTEGRATION_MATRIX_CONFIG" | jq -c ". + [ $new_entry ]")
              done
            done
          done
          echo "Generated integration_matrix_config: $INTEGRATION_MATRIX_CONFIG"
          echo "integration_matrix_config=$INTEGRATION_MATRIX_CONFIG" >> $GITHUB_OUTPUT

          # Output 2: For Trivy job's matrix.include
          # Format: [ { "branch": "main", "channel": "latest/edge" }, ... ]
          TRIVY_MATRIX='[{"branch": "main", "channel": "latest/edge"}]'

          # Iterate over stable channels and append to TRIVY_MATRIX
          # The input STABLE_CHANNELS is like '["1.32-classic/stable", "1.33-classic/stable"]'
          # jq -r '.[]' outputs each element on a new line, without quotes.
          echo "$STABLE_CHANNELS" | jq -r '.[]' | while IFS= read -r channel_str; do
            if [ -z "$channel_str" ]; then continue; fi # Skip empty lines if any

            # Extract version_part (e.g., "1.32") from "1.32-classic/stable"
            version_part="${channel_str%-classic/stable}"

            # Construct the new JSON object for Trivy using jq
            # Use --arg to safely pass shell variables to jq query
            new_trivy_entry=$(jq -n --arg vp "$version_part" \
              '{branch: ("release-" + $vp), channel: ($vp + "-classic/edge")}')

            # Append this new object to the existing TRIVY_MATRIX
            # The new_trivy_entry is already a JSON object string
            TRIVY_MATRIX=$(echo "$TRIVY_MATRIX" | jq -c ". + [ $new_trivy_entry ]")
          done

          echo "trivy_matrix=$TRIVY_MATRIX" >> $GITHUB_OUTPUT

  test-integration:
    name: Integration
    needs: supported_releases
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.supported_releases.outputs.integration_test_matrix) }}
    uses: ./.github/workflows/e2e-tests.yaml
    with:
      arch: ${{ matrix.arch }}
      os: ${{ matrix.os }}
      channel: ${{ matrix.channel }}
      test-tags: 'up_to_nightly'
      checkout-ref: ${{ matrix.checkout_ref }}

  Trivy:
    if: false
    permissions:
      contents: read # for actions/checkout to fetch code
      security-events: write # for github/codeql-action/upload-sarif to upload SARIF results
    needs: supported_releases
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.supported_releases.outputs.trivy_matrix) }}
    uses: ./.github/workflows/security-scan.yaml
    with:
      channel: ${{ matrix.channel }}
      checkout-ref: ${{ matrix.branch }}
      upload-reports-to-jira: true
    secrets: inherit

  TICS:
    if: ${{ always() && github.event_name == 'schedule' }}
    permissions:
      contents: read
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - { branch: main }
    steps:
      - name: Checking out repo
        uses: actions/checkout@v4
      - name: Save tics-scan.sh script
        run: |
          # We'll need to scan other branches, let's create a copy of
          # the TICS scan script.
          cp tests/tics-scan.sh /tmp/tics-scan.sh
      - name: Checking out tested repo branch
        uses: actions/checkout@v4
        with:
          ref: ${{matrix.branch}}
      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      - name: Install Go
        uses: actions/setup-go@v5
        with:
          go-version-file: './src/k8s/go.mod'
      - name: go mod download
        working-directory: src/k8s
        run: go mod download
      - name: TICS scan
        run: |
          export TICSAUTHTOKEN=${{ secrets.TICSAUTHTOKEN }}
          /tmp/tics-scan.sh `pwd`

  Mattermost:
    name: Notify Mattermost for Integration Tests
    if: ${{ always() && github.event_name == 'schedule' }}
    needs: [test-integration] # Only depends on the overall test-integration job group
    permissions:
      actions: read # Required to fetch job details via GitHub API
    runs-on: ubuntu-latest
    steps:
      - name: Set current formatted date as env variable
        run: echo "FORMATTED_DATE=$(date +'%d/%m/%Y')" >> $GITHUB_ENV

      - name: Fetch Integration Test Job Details via API
        id: api_job_details
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
          GH_RUN_ID: ${{ github.run_id }}
        run: |
          API_URL="/repos/$GH_REPO/actions/runs/$GH_RUN_ID/jobs?per_page=100"
          echo "Fetching job details from GitHub API: $API_URL"

          # Fetch all jobs, filter for those named "Integration (...)", select relevant fields.
          # Then, parse os, arch, channel from the job_name string.
          # The job name format is 'Integration (os, arch, channel)'.
          RAW_JOB_DETAILS=$(gh api "$API_URL" --jq '.jobs | map(select(.name | startswith("Integration (") and endswith(")"))) | map({job_name: .name, status: .conclusion, url: .html_url})')

          if [[ -z "$RAW_JOB_DETAILS" || "$RAW_JOB_DETAILS" == "[]" || "$RAW_JOB_DETAILS" == "null" ]]; then
            echo "No 'Integration (...)' jobs found or error fetching details from API."
            echo "details_json=[]" >> $GITHUB_OUTPUT
          else
            PARSED_JOB_DETAILS_JSON=$(echo "$RAW_JOB_DETAILS" | jq -c 'map(
              # Extract parameters string: e.g., "noble, amd64, 1.30-classic/edge"
              (.job_name | ltrimstr("Integration (") | rtrimstr(")")) as $params_str |
              # Split into an array: e.g., ["noble", "amd64", "1.30-classic/edge"]
              ($params_str | split(", ")) as $params_array |
              {
                os: $params_array[0],
                arch: $params_array[1],
                # Reconstruct channel: elements from index 2 onwards, joined by ", "
                # This handles channel names that might themselves contain commas.
                channel: ([$params_array[2:]] | flatten | join(", ")),
                status: .status,
                url: .url,
                original_job_name: .job_name # For debugging
              }
            )')
            echo "Parsed job details: $PARSED_JOB_DETAILS_JSON"
            echo "details_json=$PARSED_JOB_DETAILS_JSON" >> $GITHUB_OUTPUT
          fi

      - name: Generate Mattermost Message
        env:
          OVERALL_INTEGRATION_STATUS: ${{ needs.test-integration.result }} # Overall status of the job group
          INTEGRATION_JOB_DETAILS_JSON: ${{ steps.api_job_details.outputs.details_json }}
          GH_RUN_URL_FOR_SCRIPT: "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          FORMATTED_DATE_FOR_SCRIPT: ${{ env.FORMATTED_DATE }}
        run: |
          TITLE_PREFIX_TEXT=""
          ATTACHMENT_COLOR="good" # Default to green

          if [[ "$OVERALL_INTEGRATION_STATUS" == "failure" ]]; then
            TITLE_PREFIX_TEXT=":x: Integration Tests Failed!"
            ATTACHMENT_COLOR="danger"
          elif [[ "$OVERALL_INTEGRATION_STATUS" == "success" ]]; then
            TITLE_PREFIX_TEXT=":white_check_mark: Integration Tests Succeeded!"
          else # Could be cancelled, skipped etc.
            TITLE_PREFIX_TEXT=":warning: Integration Tests: $(echo $OVERALL_INTEGRATION_STATUS | tr 'a-z' 'A-Z')"
            ATTACHMENT_COLOR="warning"
          fi

          MESSAGE_SECTIONS=()
          MESSAGE_SECTIONS+=("**Overall Integration Result: $(echo $OVERALL_INTEGRATION_STATUS | tr 'a-z' 'A-Z')**")
          MESSAGE_SECTIONS+=("Link to full workflow run: [GitHub Actions Run]($GH_RUN_URL_FOR_SCRIPT)")
          MESSAGE_SECTIONS+=("") # Blank line for separation
          MESSAGE_SECTIONS+=("**Individual Test Job Details:**")

          if [[ -z "$INTEGRATION_JOB_DETAILS_JSON" || "$INTEGRATION_JOB_DETAILS_JSON" == "[]" || "$INTEGRATION_JOB_DETAILS_JSON" == "null" ]]; then
            MESSAGE_SECTIONS+=("No individual job details available (possibly no tests ran or API error).")
          else
            FORMATTED_DETAILS=$(echo "$INTEGRATION_JOB_DETAILS_JSON" | jq -r '
              # Helper function to get status icon and text
              def format_status(s):
                if s == "success" then ":white_check_mark: Passed"
                elif s == "failure" then ":x: Failed"
                elif s == "skipped" then ":fast_forward: Skipped"
                elif s == "cancelled" then ":octagonal_sign: Cancelled"
                else ":grey_question: " + (s // "Unknown")
                end;

              # Group by channel, then format each job
              group_by(.channel) | map(
                "**\(.[0].channel):**\n" + # Channel name as header
                (map("  \(.os)-\(.arch): \(format_status(.status)) [Logs](\(.url))") | join("\n")) # List of os-arch statuses
              ) | join("\n\n") # Join channel groups with a blank line
            ')
            if [[ -z "$FORMATTED_DETAILS" ]]; then
              MESSAGE_SECTIONS+=("Error formatting job details or no jobs to display after filtering.")
            else
              MESSAGE_SECTIONS+=("$FORMATTED_DETAILS")
            fi
          fi

          printf -v MM_TEXT_CONTENT '%s\n' "${MESSAGE_SECTIONS[@]}"

          echo "MM_TITLE_PREFIX_TEXT=$TITLE_PREFIX_TEXT" >> $GITHUB_ENV
          echo "MM_ATTACHMENT_COLOR=$ATTACHMENT_COLOR" >> $GITHUB_ENV

          ESCAPED_MM_TEXT_CONTENT=$(echo "$MM_TEXT_CONTENT" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g' -e ':a' -e 'N' -e '$!ba' -e 's/\n/\\n/g')
          echo "ESCAPED_MM_TEXT=$ESCAPED_MM_TEXT_CONTENT" >> $GITHUB_ENV

      - name: Notify Mattermost
        uses: mattermost/action-mattermost-notify@master
        env:
          MATTERMOST_WEBHOOK_URL: ${{ secrets.MATTERMOST_BOT_WEBHOOK_URL }}
        with:
          payload: |
            {
              "attachments": [
                {
                  "fallback": "k8s-snap Nightly Integration Test Status - ${{ env.FORMATTED_DATE_FOR_SCRIPT }}",
                  "color": "${{ env.MM_ATTACHMENT_COLOR }}",
                  "title": "${{ env.MM_TITLE_PREFIX_TEXT }} k8s-snap Nightly CI - ${{ env.FORMATTED_DATE_FOR_SCRIPT }}",
                  "text": "${{ env.ESCAPED_MM_TEXT }}"
                }
              ]
            }
